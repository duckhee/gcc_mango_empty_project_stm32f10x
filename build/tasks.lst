ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	prvTaskIsTaskSuspended:
  25              	.LFB42:
  26              		.file 1 "FreeRTOS/Src/tasks.c"
   1:FreeRTOS/Src/tasks.c **** /*
   2:FreeRTOS/Src/tasks.c ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/Src/tasks.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Src/tasks.c ****  *
   5:FreeRTOS/Src/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Src/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Src/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Src/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Src/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Src/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Src/tasks.c ****  *
  12:FreeRTOS/Src/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Src/tasks.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Src/tasks.c ****  *
  15:FreeRTOS/Src/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Src/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Src/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Src/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Src/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Src/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Src/tasks.c ****  *
  22:FreeRTOS/Src/tasks.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Src/tasks.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Src/tasks.c ****  *
  25:FreeRTOS/Src/tasks.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Src/tasks.c ****  */
  27:FreeRTOS/Src/tasks.c **** 
  28:FreeRTOS/Src/tasks.c **** /* Standard includes. */
  29:FreeRTOS/Src/tasks.c **** #include <stdlib.h>
  30:FreeRTOS/Src/tasks.c **** #include <string.h>
  31:FreeRTOS/Src/tasks.c **** 
  32:FreeRTOS/Src/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 2


  33:FreeRTOS/Src/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Src/tasks.c **** task.h is included from an application file. */
  35:FreeRTOS/Src/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/Src/tasks.c **** 
  37:FreeRTOS/Src/tasks.c **** /* FreeRTOS includes. */
  38:FreeRTOS/Src/tasks.c **** #include "FreeRTOS.h"
  39:FreeRTOS/Src/tasks.c **** #include "task.h"
  40:FreeRTOS/Src/tasks.c **** #include "timers.h"
  41:FreeRTOS/Src/tasks.c **** #include "stack_macros.h"
  42:FreeRTOS/Src/tasks.c **** 
  43:FreeRTOS/Src/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:FreeRTOS/Src/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:FreeRTOS/Src/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:FreeRTOS/Src/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:FreeRTOS/Src/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:FreeRTOS/Src/tasks.c **** 
  49:FreeRTOS/Src/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:FreeRTOS/Src/tasks.c **** functions but without including stdio.h here. */
  51:FreeRTOS/Src/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:FreeRTOS/Src/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:FreeRTOS/Src/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:FreeRTOS/Src/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:FreeRTOS/Src/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:FreeRTOS/Src/tasks.c **** 	#include <stdio.h>
  57:FreeRTOS/Src/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:FreeRTOS/Src/tasks.c **** 
  59:FreeRTOS/Src/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:FreeRTOS/Src/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:FreeRTOS/Src/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:FreeRTOS/Src/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:FreeRTOS/Src/tasks.c **** #else
  64:FreeRTOS/Src/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:FreeRTOS/Src/tasks.c **** #endif
  66:FreeRTOS/Src/tasks.c **** 
  67:FreeRTOS/Src/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:FreeRTOS/Src/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:FreeRTOS/Src/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:FreeRTOS/Src/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:FreeRTOS/Src/tasks.c **** 
  72:FreeRTOS/Src/tasks.c **** /*
  73:FreeRTOS/Src/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:FreeRTOS/Src/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:FreeRTOS/Src/tasks.c ****  */
  76:FreeRTOS/Src/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:FreeRTOS/Src/tasks.c **** 
  78:FreeRTOS/Src/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  79:FreeRTOS/Src/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  80:FreeRTOS/Src/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  81:FreeRTOS/Src/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  82:FreeRTOS/Src/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  83:FreeRTOS/Src/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  84:FreeRTOS/Src/tasks.c **** settings allow a task to be created using either statically or dynamically
  85:FreeRTOS/Src/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  86:FreeRTOS/Src/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  87:FreeRTOS/Src/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  88:FreeRTOS/Src/tasks.c **** made to free the RAM that was allocated statically.
  89:FreeRTOS/Src/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 3


  90:FreeRTOS/Src/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  91:FreeRTOS/Src/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  92:FreeRTOS/Src/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  93:FreeRTOS/Src/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  94:FreeRTOS/Src/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  95:FreeRTOS/Src/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  96:FreeRTOS/Src/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  97:FreeRTOS/Src/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  98:FreeRTOS/Src/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  99:FreeRTOS/Src/tasks.c **** 
 100:FreeRTOS/Src/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 101:FreeRTOS/Src/tasks.c **** value so the high water mark can be determined.  If none of the following are
 102:FreeRTOS/Src/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 103:FreeRTOS/Src/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 104:FreeRTOS/Src/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 105:FreeRTOS/Src/tasks.c **** #else
 106:FreeRTOS/Src/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 107:FreeRTOS/Src/tasks.c **** #endif
 108:FreeRTOS/Src/tasks.c **** 
 109:FreeRTOS/Src/tasks.c **** /*
 110:FreeRTOS/Src/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 111:FreeRTOS/Src/tasks.c ****  */
 112:FreeRTOS/Src/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
 113:FreeRTOS/Src/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:FreeRTOS/Src/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:FreeRTOS/Src/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:FreeRTOS/Src/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:FreeRTOS/Src/tasks.c **** 
 118:FreeRTOS/Src/tasks.c **** /*
 119:FreeRTOS/Src/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:FreeRTOS/Src/tasks.c ****  * global, rather than file scope.
 121:FreeRTOS/Src/tasks.c ****  */
 122:FreeRTOS/Src/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:FreeRTOS/Src/tasks.c **** 	#define static
 124:FreeRTOS/Src/tasks.c **** #endif
 125:FreeRTOS/Src/tasks.c **** 
 126:FreeRTOS/Src/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:FreeRTOS/Src/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:FreeRTOS/Src/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:FreeRTOS/Src/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:FreeRTOS/Src/tasks.c **** #endif
 131:FreeRTOS/Src/tasks.c **** 
 132:FreeRTOS/Src/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:FreeRTOS/Src/tasks.c **** 
 134:FreeRTOS/Src/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:FreeRTOS/Src/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:FreeRTOS/Src/tasks.c **** 	microcontroller architecture. */
 137:FreeRTOS/Src/tasks.c **** 
 138:FreeRTOS/Src/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:FreeRTOS/Src/tasks.c **** 	state task. */
 140:FreeRTOS/Src/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:FreeRTOS/Src/tasks.c **** 	{																									\
 142:FreeRTOS/Src/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:FreeRTOS/Src/tasks.c **** 		{																								\
 144:FreeRTOS/Src/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:FreeRTOS/Src/tasks.c **** 		}																								\
 146:FreeRTOS/Src/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 4


 147:FreeRTOS/Src/tasks.c **** 
 148:FreeRTOS/Src/tasks.c **** 	/*-----------------------------------------------------------*/
 149:FreeRTOS/Src/tasks.c **** 
 150:FreeRTOS/Src/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:FreeRTOS/Src/tasks.c **** 	{																									\
 152:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:FreeRTOS/Src/tasks.c **** 																										\
 154:FreeRTOS/Src/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:FreeRTOS/Src/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:FreeRTOS/Src/tasks.c **** 		{																								\
 157:FreeRTOS/Src/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:FreeRTOS/Src/tasks.c **** 			--uxTopPriority;																			\
 159:FreeRTOS/Src/tasks.c **** 		}																								\
 160:FreeRTOS/Src/tasks.c **** 																										\
 161:FreeRTOS/Src/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:FreeRTOS/Src/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:FreeRTOS/Src/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:FreeRTOS/Src/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:FreeRTOS/Src/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:FreeRTOS/Src/tasks.c **** 
 167:FreeRTOS/Src/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Src/tasks.c **** 
 169:FreeRTOS/Src/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:FreeRTOS/Src/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:FreeRTOS/Src/tasks.c **** 	being used. */
 172:FreeRTOS/Src/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:FreeRTOS/Src/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:FreeRTOS/Src/tasks.c **** 
 175:FreeRTOS/Src/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:FreeRTOS/Src/tasks.c **** 
 177:FreeRTOS/Src/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:FreeRTOS/Src/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:FreeRTOS/Src/tasks.c **** 	architecture being used. */
 180:FreeRTOS/Src/tasks.c **** 
 181:FreeRTOS/Src/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:FreeRTOS/Src/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:FreeRTOS/Src/tasks.c **** 
 184:FreeRTOS/Src/tasks.c **** 	/*-----------------------------------------------------------*/
 185:FreeRTOS/Src/tasks.c **** 
 186:FreeRTOS/Src/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:FreeRTOS/Src/tasks.c **** 	{																								\
 188:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:FreeRTOS/Src/tasks.c **** 																									\
 190:FreeRTOS/Src/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:FreeRTOS/Src/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:FreeRTOS/Src/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:FreeRTOS/Src/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:FreeRTOS/Src/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:FreeRTOS/Src/tasks.c **** 
 196:FreeRTOS/Src/tasks.c **** 	/*-----------------------------------------------------------*/
 197:FreeRTOS/Src/tasks.c **** 
 198:FreeRTOS/Src/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:FreeRTOS/Src/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:FreeRTOS/Src/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:FreeRTOS/Src/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:FreeRTOS/Src/tasks.c **** 	{																									\
 203:FreeRTOS/Src/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 5


 204:FreeRTOS/Src/tasks.c **** 		{																								\
 205:FreeRTOS/Src/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:FreeRTOS/Src/tasks.c **** 		}																								\
 207:FreeRTOS/Src/tasks.c **** 	}
 208:FreeRTOS/Src/tasks.c **** 
 209:FreeRTOS/Src/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:FreeRTOS/Src/tasks.c **** 
 211:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 212:FreeRTOS/Src/tasks.c **** 
 213:FreeRTOS/Src/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:FreeRTOS/Src/tasks.c **** count overflows. */
 215:FreeRTOS/Src/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:FreeRTOS/Src/tasks.c **** {																									\
 217:FreeRTOS/Src/tasks.c **** 	List_t *pxTemp;																					\
 218:FreeRTOS/Src/tasks.c **** 																									\
 219:FreeRTOS/Src/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:FreeRTOS/Src/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:FreeRTOS/Src/tasks.c **** 																									\
 222:FreeRTOS/Src/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:FreeRTOS/Src/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:FreeRTOS/Src/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:FreeRTOS/Src/tasks.c **** 	xNumOfOverflows++;																				\
 226:FreeRTOS/Src/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:FreeRTOS/Src/tasks.c **** }
 228:FreeRTOS/Src/tasks.c **** 
 229:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 230:FreeRTOS/Src/tasks.c **** 
 231:FreeRTOS/Src/tasks.c **** /*
 232:FreeRTOS/Src/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:FreeRTOS/Src/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:FreeRTOS/Src/tasks.c ****  */
 235:FreeRTOS/Src/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:FreeRTOS/Src/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:FreeRTOS/Src/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:FreeRTOS/Src/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:FreeRTOS/Src/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 241:FreeRTOS/Src/tasks.c **** 
 242:FreeRTOS/Src/tasks.c **** /*
 243:FreeRTOS/Src/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:FreeRTOS/Src/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:FreeRTOS/Src/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:FreeRTOS/Src/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:FreeRTOS/Src/tasks.c ****  */
 248:FreeRTOS/Src/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 249:FreeRTOS/Src/tasks.c **** 
 250:FreeRTOS/Src/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:FreeRTOS/Src/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:FreeRTOS/Src/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:FreeRTOS/Src/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:FreeRTOS/Src/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:FreeRTOS/Src/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:FreeRTOS/Src/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:FreeRTOS/Src/tasks.c **** to its original value when it is released. */
 258:FreeRTOS/Src/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:FreeRTOS/Src/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:FreeRTOS/Src/tasks.c **** #else
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 6


 261:FreeRTOS/Src/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:FreeRTOS/Src/tasks.c **** #endif
 263:FreeRTOS/Src/tasks.c **** 
 264:FreeRTOS/Src/tasks.c **** /*
 265:FreeRTOS/Src/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:FreeRTOS/Src/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:FreeRTOS/Src/tasks.c ****  * (the task's run time environment, including register values)
 268:FreeRTOS/Src/tasks.c ****  */
 269:FreeRTOS/Src/tasks.c **** typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel 
 270:FreeRTOS/Src/tasks.c **** {
 271:FreeRTOS/Src/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:FreeRTOS/Src/tasks.c **** 
 273:FreeRTOS/Src/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:FreeRTOS/Src/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:FreeRTOS/Src/tasks.c **** 	#endif
 276:FreeRTOS/Src/tasks.c **** 
 277:FreeRTOS/Src/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:FreeRTOS/Src/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:FreeRTOS/Src/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:FreeRTOS/Src/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:FreeRTOS/Src/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:FreeRTOS/Src/tasks.c **** 
 283:FreeRTOS/Src/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:FreeRTOS/Src/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:FreeRTOS/Src/tasks.c **** 	#endif
 286:FreeRTOS/Src/tasks.c **** 
 287:FreeRTOS/Src/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:FreeRTOS/Src/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:FreeRTOS/Src/tasks.c **** 	#endif
 290:FreeRTOS/Src/tasks.c **** 
 291:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:FreeRTOS/Src/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:FreeRTOS/Src/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:FreeRTOS/Src/tasks.c **** 	#endif
 295:FreeRTOS/Src/tasks.c **** 
 296:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:FreeRTOS/Src/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:FreeRTOS/Src/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:FreeRTOS/Src/tasks.c **** 	#endif
 300:FreeRTOS/Src/tasks.c **** 
 301:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:FreeRTOS/Src/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:FreeRTOS/Src/tasks.c **** 	#endif
 304:FreeRTOS/Src/tasks.c **** 
 305:FreeRTOS/Src/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:FreeRTOS/Src/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:FreeRTOS/Src/tasks.c **** 	#endif
 308:FreeRTOS/Src/tasks.c **** 
 309:FreeRTOS/Src/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:FreeRTOS/Src/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:FreeRTOS/Src/tasks.c **** 	#endif
 312:FreeRTOS/Src/tasks.c **** 
 313:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:FreeRTOS/Src/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:FreeRTOS/Src/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:FreeRTOS/Src/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:FreeRTOS/Src/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 7


 318:FreeRTOS/Src/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:FreeRTOS/Src/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:FreeRTOS/Src/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:FreeRTOS/Src/tasks.c **** 		struct	_reent xNewLib_reent;
 322:FreeRTOS/Src/tasks.c **** 	#endif
 323:FreeRTOS/Src/tasks.c **** 
 324:FreeRTOS/Src/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:FreeRTOS/Src/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:FreeRTOS/Src/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:FreeRTOS/Src/tasks.c **** 	#endif
 328:FreeRTOS/Src/tasks.c **** 
 329:FreeRTOS/Src/tasks.c **** 	/* See the comments above the definition of
 330:FreeRTOS/Src/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:FreeRTOS/Src/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 332:FreeRTOS/Src/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:FreeRTOS/Src/tasks.c **** 	#endif
 334:FreeRTOS/Src/tasks.c **** 
 335:FreeRTOS/Src/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:FreeRTOS/Src/tasks.c **** 		uint8_t ucDelayAborted;
 337:FreeRTOS/Src/tasks.c **** 	#endif
 338:FreeRTOS/Src/tasks.c **** 
 339:FreeRTOS/Src/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 340:FreeRTOS/Src/tasks.c **** 		int iTaskErrno;
 341:FreeRTOS/Src/tasks.c **** 	#endif
 342:FreeRTOS/Src/tasks.c **** 
 343:FreeRTOS/Src/tasks.c **** } tskTCB;
 344:FreeRTOS/Src/tasks.c **** 
 345:FreeRTOS/Src/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 346:FreeRTOS/Src/tasks.c **** below to enable the use of older kernel aware debuggers. */
 347:FreeRTOS/Src/tasks.c **** typedef tskTCB TCB_t;
 348:FreeRTOS/Src/tasks.c **** 
 349:FreeRTOS/Src/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 350:FreeRTOS/Src/tasks.c **** which static variables must be declared volatile. */
 351:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 352:FreeRTOS/Src/tasks.c **** 
 353:FreeRTOS/Src/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 354:FreeRTOS/Src/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 355:FreeRTOS/Src/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 356:FreeRTOS/Src/tasks.c **** the static qualifier. */
 357:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 358:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 359:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 360:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 361:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 362:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 363:FreeRTOS/Src/tasks.c **** 
 364:FreeRTOS/Src/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 365:FreeRTOS/Src/tasks.c **** 
 366:FreeRTOS/Src/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 367:FreeRTOS/Src/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 368:FreeRTOS/Src/tasks.c **** 
 369:FreeRTOS/Src/tasks.c **** #endif
 370:FreeRTOS/Src/tasks.c **** 
 371:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 372:FreeRTOS/Src/tasks.c **** 
 373:FreeRTOS/Src/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 374:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 8


 375:FreeRTOS/Src/tasks.c **** #endif
 376:FreeRTOS/Src/tasks.c **** 
 377:FreeRTOS/Src/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 378:FreeRTOS/Src/tasks.c **** the errno of the currently running task. */
 379:FreeRTOS/Src/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 380:FreeRTOS/Src/tasks.c **** 	int FreeRTOS_errno = 0;
 381:FreeRTOS/Src/tasks.c **** #endif
 382:FreeRTOS/Src/tasks.c **** 
 383:FreeRTOS/Src/tasks.c **** /* Other file private variables. --------------------------------*/
 384:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 385:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 386:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 387:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 388:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 389:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 390:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 391:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 392:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 393:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 394:FreeRTOS/Src/tasks.c **** 
 395:FreeRTOS/Src/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 396:FreeRTOS/Src/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 397:FreeRTOS/Src/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 398:FreeRTOS/Src/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 399:FreeRTOS/Src/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 400:FreeRTOS/Src/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 401:FreeRTOS/Src/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 402:FreeRTOS/Src/tasks.c **** accessed from a critical section. */
 403:FreeRTOS/Src/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 404:FreeRTOS/Src/tasks.c **** 
 405:FreeRTOS/Src/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 406:FreeRTOS/Src/tasks.c **** 
 407:FreeRTOS/Src/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 408:FreeRTOS/Src/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 409:FreeRTOS/Src/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 410:FreeRTOS/Src/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 411:FreeRTOS/Src/tasks.c **** 
 412:FreeRTOS/Src/tasks.c **** #endif
 413:FreeRTOS/Src/tasks.c **** 
 414:FreeRTOS/Src/tasks.c **** /*lint -restore */
 415:FreeRTOS/Src/tasks.c **** 
 416:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 417:FreeRTOS/Src/tasks.c **** 
 418:FreeRTOS/Src/tasks.c **** /* Callback function prototypes. --------------------------*/
 419:FreeRTOS/Src/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 420:FreeRTOS/Src/tasks.c **** 
 421:FreeRTOS/Src/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 422:FreeRTOS/Src/tasks.c **** 
 423:FreeRTOS/Src/tasks.c **** #endif
 424:FreeRTOS/Src/tasks.c **** 
 425:FreeRTOS/Src/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 426:FreeRTOS/Src/tasks.c **** 
 427:FreeRTOS/Src/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 428:FreeRTOS/Src/tasks.c **** 
 429:FreeRTOS/Src/tasks.c **** #endif
 430:FreeRTOS/Src/tasks.c **** 
 431:FreeRTOS/Src/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 9


 432:FreeRTOS/Src/tasks.c **** 
 433:FreeRTOS/Src/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 434:FreeRTOS/Src/tasks.c **** 
 435:FreeRTOS/Src/tasks.c **** #endif
 436:FreeRTOS/Src/tasks.c **** 
 437:FreeRTOS/Src/tasks.c **** /* File private functions. --------------------------------*/
 438:FreeRTOS/Src/tasks.c **** 
 439:FreeRTOS/Src/tasks.c **** /**
 440:FreeRTOS/Src/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 441:FreeRTOS/Src/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 442:FreeRTOS/Src/tasks.c ****  * is in any other state.
 443:FreeRTOS/Src/tasks.c ****  */
 444:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 445:FreeRTOS/Src/tasks.c **** 
 446:FreeRTOS/Src/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 447:FreeRTOS/Src/tasks.c **** 
 448:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 449:FreeRTOS/Src/tasks.c **** 
 450:FreeRTOS/Src/tasks.c **** /*
 451:FreeRTOS/Src/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 452:FreeRTOS/Src/tasks.c ****  * automatically upon the creation of the first task.
 453:FreeRTOS/Src/tasks.c ****  */
 454:FreeRTOS/Src/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 455:FreeRTOS/Src/tasks.c **** 
 456:FreeRTOS/Src/tasks.c **** /*
 457:FreeRTOS/Src/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 458:FreeRTOS/Src/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 459:FreeRTOS/Src/tasks.c ****  * creation of the first user task.
 460:FreeRTOS/Src/tasks.c ****  *
 461:FreeRTOS/Src/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 462:FreeRTOS/Src/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 463:FreeRTOS/Src/tasks.c ****  *
 464:FreeRTOS/Src/tasks.c ****  * void prvIdleTask( void *pvParameters );
 465:FreeRTOS/Src/tasks.c ****  *
 466:FreeRTOS/Src/tasks.c ****  */
 467:FreeRTOS/Src/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 468:FreeRTOS/Src/tasks.c **** 
 469:FreeRTOS/Src/tasks.c **** /*
 470:FreeRTOS/Src/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 471:FreeRTOS/Src/tasks.c ****  * including the stack pointed to by the TCB.
 472:FreeRTOS/Src/tasks.c ****  *
 473:FreeRTOS/Src/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 474:FreeRTOS/Src/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 475:FreeRTOS/Src/tasks.c ****  */
 476:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 477:FreeRTOS/Src/tasks.c **** 
 478:FreeRTOS/Src/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 479:FreeRTOS/Src/tasks.c **** 
 480:FreeRTOS/Src/tasks.c **** #endif
 481:FreeRTOS/Src/tasks.c **** 
 482:FreeRTOS/Src/tasks.c **** /*
 483:FreeRTOS/Src/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 484:FreeRTOS/Src/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 485:FreeRTOS/Src/tasks.c ****  * and its TCB deleted.
 486:FreeRTOS/Src/tasks.c ****  */
 487:FreeRTOS/Src/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 488:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 10


 489:FreeRTOS/Src/tasks.c **** /*
 490:FreeRTOS/Src/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 491:FreeRTOS/Src/tasks.c ****  * either the current or the overflow delayed task list.
 492:FreeRTOS/Src/tasks.c ****  */
 493:FreeRTOS/Src/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 494:FreeRTOS/Src/tasks.c **** 
 495:FreeRTOS/Src/tasks.c **** /*
 496:FreeRTOS/Src/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 497:FreeRTOS/Src/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 498:FreeRTOS/Src/tasks.c ****  * a suspended list, etc.).
 499:FreeRTOS/Src/tasks.c ****  *
 500:FreeRTOS/Src/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 501:FreeRTOS/Src/tasks.c ****  * NORMAL APPLICATION CODE.
 502:FreeRTOS/Src/tasks.c ****  */
 503:FreeRTOS/Src/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 504:FreeRTOS/Src/tasks.c **** 
 505:FreeRTOS/Src/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 506:FreeRTOS/Src/tasks.c **** 
 507:FreeRTOS/Src/tasks.c **** #endif
 508:FreeRTOS/Src/tasks.c **** 
 509:FreeRTOS/Src/tasks.c **** /*
 510:FreeRTOS/Src/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 511:FreeRTOS/Src/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 512:FreeRTOS/Src/tasks.c ****  */
 513:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 514:FreeRTOS/Src/tasks.c **** 
 515:FreeRTOS/Src/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 516:FreeRTOS/Src/tasks.c **** 
 517:FreeRTOS/Src/tasks.c **** #endif
 518:FreeRTOS/Src/tasks.c **** 
 519:FreeRTOS/Src/tasks.c **** /*
 520:FreeRTOS/Src/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 521:FreeRTOS/Src/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 522:FreeRTOS/Src/tasks.c ****  * determining how much of the stack remains at the original preset value.
 523:FreeRTOS/Src/tasks.c ****  */
 524:FreeRTOS/Src/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 525:FreeRTOS/Src/tasks.c **** 
 526:FreeRTOS/Src/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 527:FreeRTOS/Src/tasks.c **** 
 528:FreeRTOS/Src/tasks.c **** #endif
 529:FreeRTOS/Src/tasks.c **** 
 530:FreeRTOS/Src/tasks.c **** /*
 531:FreeRTOS/Src/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 532:FreeRTOS/Src/tasks.c ****  * next move a task from the Blocked state to the Running state.
 533:FreeRTOS/Src/tasks.c ****  *
 534:FreeRTOS/Src/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 535:FreeRTOS/Src/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 536:FreeRTOS/Src/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 537:FreeRTOS/Src/tasks.c ****  * set to a value other than 1.
 538:FreeRTOS/Src/tasks.c ****  */
 539:FreeRTOS/Src/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 540:FreeRTOS/Src/tasks.c **** 
 541:FreeRTOS/Src/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 542:FreeRTOS/Src/tasks.c **** 
 543:FreeRTOS/Src/tasks.c **** #endif
 544:FreeRTOS/Src/tasks.c **** 
 545:FreeRTOS/Src/tasks.c **** /*
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 11


 546:FreeRTOS/Src/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 547:FreeRTOS/Src/tasks.c ****  * will exit the Blocked state.
 548:FreeRTOS/Src/tasks.c ****  */
 549:FreeRTOS/Src/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 550:FreeRTOS/Src/tasks.c **** 
 551:FreeRTOS/Src/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 552:FreeRTOS/Src/tasks.c **** 
 553:FreeRTOS/Src/tasks.c **** 	/*
 554:FreeRTOS/Src/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 555:FreeRTOS/Src/tasks.c **** 	 * human readable tables of task information.
 556:FreeRTOS/Src/tasks.c **** 	 */
 557:FreeRTOS/Src/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 558:FreeRTOS/Src/tasks.c **** 
 559:FreeRTOS/Src/tasks.c **** #endif
 560:FreeRTOS/Src/tasks.c **** 
 561:FreeRTOS/Src/tasks.c **** /*
 562:FreeRTOS/Src/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 563:FreeRTOS/Src/tasks.c ****  * dynamically to fill in the structure's members.
 564:FreeRTOS/Src/tasks.c ****  */
 565:FreeRTOS/Src/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 566:FreeRTOS/Src/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 567:FreeRTOS/Src/tasks.c **** 									const uint32_t ulStackDepth,
 568:FreeRTOS/Src/tasks.c **** 									void * const pvParameters,
 569:FreeRTOS/Src/tasks.c **** 									UBaseType_t uxPriority,
 570:FreeRTOS/Src/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 571:FreeRTOS/Src/tasks.c **** 									TCB_t *pxNewTCB,
 572:FreeRTOS/Src/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 573:FreeRTOS/Src/tasks.c **** 
 574:FreeRTOS/Src/tasks.c **** /*
 575:FreeRTOS/Src/tasks.c ****  * Called after a new task has been created and initialised to place the task
 576:FreeRTOS/Src/tasks.c ****  * under the control of the scheduler.
 577:FreeRTOS/Src/tasks.c ****  */
 578:FreeRTOS/Src/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 579:FreeRTOS/Src/tasks.c **** 
 580:FreeRTOS/Src/tasks.c **** /*
 581:FreeRTOS/Src/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 582:FreeRTOS/Src/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 583:FreeRTOS/Src/tasks.c ****  * called by the function.
 584:FreeRTOS/Src/tasks.c ****  */
 585:FreeRTOS/Src/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 586:FreeRTOS/Src/tasks.c **** 
 587:FreeRTOS/Src/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 588:FreeRTOS/Src/tasks.c **** 
 589:FreeRTOS/Src/tasks.c **** #endif
 590:FreeRTOS/Src/tasks.c **** 
 591:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 592:FreeRTOS/Src/tasks.c **** 
 593:FreeRTOS/Src/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 594:FreeRTOS/Src/tasks.c **** 
 595:FreeRTOS/Src/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 596:FreeRTOS/Src/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 597:FreeRTOS/Src/tasks.c **** 									const uint32_t ulStackDepth,
 598:FreeRTOS/Src/tasks.c **** 									void * const pvParameters,
 599:FreeRTOS/Src/tasks.c **** 									UBaseType_t uxPriority,
 600:FreeRTOS/Src/tasks.c **** 									StackType_t * const puxStackBuffer,
 601:FreeRTOS/Src/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 602:FreeRTOS/Src/tasks.c **** 	{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 12


 603:FreeRTOS/Src/tasks.c **** 	TCB_t *pxNewTCB;
 604:FreeRTOS/Src/tasks.c **** 	TaskHandle_t xReturn;
 605:FreeRTOS/Src/tasks.c **** 
 606:FreeRTOS/Src/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 607:FreeRTOS/Src/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 608:FreeRTOS/Src/tasks.c **** 
 609:FreeRTOS/Src/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 610:FreeRTOS/Src/tasks.c **** 		{
 611:FreeRTOS/Src/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 612:FreeRTOS/Src/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 613:FreeRTOS/Src/tasks.c **** 			structure. */
 614:FreeRTOS/Src/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 615:FreeRTOS/Src/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 616:FreeRTOS/Src/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 617:FreeRTOS/Src/tasks.c **** 		}
 618:FreeRTOS/Src/tasks.c **** 		#endif /* configASSERT_DEFINED */
 619:FreeRTOS/Src/tasks.c **** 
 620:FreeRTOS/Src/tasks.c **** 
 621:FreeRTOS/Src/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 622:FreeRTOS/Src/tasks.c **** 		{
 623:FreeRTOS/Src/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 624:FreeRTOS/Src/tasks.c **** 			function - use them. */
 625:FreeRTOS/Src/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 626:FreeRTOS/Src/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 627:FreeRTOS/Src/tasks.c **** 
 628:FreeRTOS/Src/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 629:FreeRTOS/Src/tasks.c **** 			{
 630:FreeRTOS/Src/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 631:FreeRTOS/Src/tasks.c **** 				task was created statically in case the task is later deleted. */
 632:FreeRTOS/Src/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 633:FreeRTOS/Src/tasks.c **** 			}
 634:FreeRTOS/Src/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 635:FreeRTOS/Src/tasks.c **** 
 636:FreeRTOS/Src/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 637:FreeRTOS/Src/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 638:FreeRTOS/Src/tasks.c **** 		}
 639:FreeRTOS/Src/tasks.c **** 		else
 640:FreeRTOS/Src/tasks.c **** 		{
 641:FreeRTOS/Src/tasks.c **** 			xReturn = NULL;
 642:FreeRTOS/Src/tasks.c **** 		}
 643:FreeRTOS/Src/tasks.c **** 
 644:FreeRTOS/Src/tasks.c **** 		return xReturn;
 645:FreeRTOS/Src/tasks.c **** 	}
 646:FreeRTOS/Src/tasks.c **** 
 647:FreeRTOS/Src/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 648:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 649:FreeRTOS/Src/tasks.c **** 
 650:FreeRTOS/Src/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 651:FreeRTOS/Src/tasks.c **** 
 652:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 653:FreeRTOS/Src/tasks.c **** 	{
 654:FreeRTOS/Src/tasks.c **** 	TCB_t *pxNewTCB;
 655:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 656:FreeRTOS/Src/tasks.c **** 
 657:FreeRTOS/Src/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 658:FreeRTOS/Src/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 659:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 13


 660:FreeRTOS/Src/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 661:FreeRTOS/Src/tasks.c **** 		{
 662:FreeRTOS/Src/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 663:FreeRTOS/Src/tasks.c **** 			on the implementation of the port malloc function and whether or
 664:FreeRTOS/Src/tasks.c **** 			not static allocation is being used. */
 665:FreeRTOS/Src/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 666:FreeRTOS/Src/tasks.c **** 
 667:FreeRTOS/Src/tasks.c **** 			/* Store the stack location in the TCB. */
 668:FreeRTOS/Src/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 669:FreeRTOS/Src/tasks.c **** 
 670:FreeRTOS/Src/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 671:FreeRTOS/Src/tasks.c **** 			{
 672:FreeRTOS/Src/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 673:FreeRTOS/Src/tasks.c **** 				task was created statically in case the task is later deleted. */
 674:FreeRTOS/Src/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 675:FreeRTOS/Src/tasks.c **** 			}
 676:FreeRTOS/Src/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 677:FreeRTOS/Src/tasks.c **** 
 678:FreeRTOS/Src/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 679:FreeRTOS/Src/tasks.c **** 									pxTaskDefinition->pcName,
 680:FreeRTOS/Src/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 681:FreeRTOS/Src/tasks.c **** 									pxTaskDefinition->pvParameters,
 682:FreeRTOS/Src/tasks.c **** 									pxTaskDefinition->uxPriority,
 683:FreeRTOS/Src/tasks.c **** 									pxCreatedTask, pxNewTCB,
 684:FreeRTOS/Src/tasks.c **** 									pxTaskDefinition->xRegions );
 685:FreeRTOS/Src/tasks.c **** 
 686:FreeRTOS/Src/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 687:FreeRTOS/Src/tasks.c **** 			xReturn = pdPASS;
 688:FreeRTOS/Src/tasks.c **** 		}
 689:FreeRTOS/Src/tasks.c **** 
 690:FreeRTOS/Src/tasks.c **** 		return xReturn;
 691:FreeRTOS/Src/tasks.c **** 	}
 692:FreeRTOS/Src/tasks.c **** 
 693:FreeRTOS/Src/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 694:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 695:FreeRTOS/Src/tasks.c **** 
 696:FreeRTOS/Src/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 697:FreeRTOS/Src/tasks.c **** 
 698:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 699:FreeRTOS/Src/tasks.c **** 	{
 700:FreeRTOS/Src/tasks.c **** 	TCB_t *pxNewTCB;
 701:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 702:FreeRTOS/Src/tasks.c **** 
 703:FreeRTOS/Src/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 704:FreeRTOS/Src/tasks.c **** 
 705:FreeRTOS/Src/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 706:FreeRTOS/Src/tasks.c **** 		{
 707:FreeRTOS/Src/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 708:FreeRTOS/Src/tasks.c **** 			on the implementation of the port malloc function and whether or
 709:FreeRTOS/Src/tasks.c **** 			not static allocation is being used. */
 710:FreeRTOS/Src/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 711:FreeRTOS/Src/tasks.c **** 
 712:FreeRTOS/Src/tasks.c **** 			if( pxNewTCB != NULL )
 713:FreeRTOS/Src/tasks.c **** 			{
 714:FreeRTOS/Src/tasks.c **** 				/* Store the stack location in the TCB. */
 715:FreeRTOS/Src/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 716:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 14


 717:FreeRTOS/Src/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 718:FreeRTOS/Src/tasks.c **** 				{
 719:FreeRTOS/Src/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 720:FreeRTOS/Src/tasks.c **** 					this task had a statically allocated stack in case it is
 721:FreeRTOS/Src/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 722:FreeRTOS/Src/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 723:FreeRTOS/Src/tasks.c **** 				}
 724:FreeRTOS/Src/tasks.c **** 				#endif
 725:FreeRTOS/Src/tasks.c **** 
 726:FreeRTOS/Src/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 727:FreeRTOS/Src/tasks.c **** 										pxTaskDefinition->pcName,
 728:FreeRTOS/Src/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 729:FreeRTOS/Src/tasks.c **** 										pxTaskDefinition->pvParameters,
 730:FreeRTOS/Src/tasks.c **** 										pxTaskDefinition->uxPriority,
 731:FreeRTOS/Src/tasks.c **** 										pxCreatedTask, pxNewTCB,
 732:FreeRTOS/Src/tasks.c **** 										pxTaskDefinition->xRegions );
 733:FreeRTOS/Src/tasks.c **** 
 734:FreeRTOS/Src/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 735:FreeRTOS/Src/tasks.c **** 				xReturn = pdPASS;
 736:FreeRTOS/Src/tasks.c **** 			}
 737:FreeRTOS/Src/tasks.c **** 		}
 738:FreeRTOS/Src/tasks.c **** 
 739:FreeRTOS/Src/tasks.c **** 		return xReturn;
 740:FreeRTOS/Src/tasks.c **** 	}
 741:FreeRTOS/Src/tasks.c **** 
 742:FreeRTOS/Src/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 743:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 744:FreeRTOS/Src/tasks.c **** 
 745:FreeRTOS/Src/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 746:FreeRTOS/Src/tasks.c **** 
 747:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 748:FreeRTOS/Src/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 749:FreeRTOS/Src/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 750:FreeRTOS/Src/tasks.c **** 							void * const pvParameters,
 751:FreeRTOS/Src/tasks.c **** 							UBaseType_t uxPriority,
 752:FreeRTOS/Src/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 753:FreeRTOS/Src/tasks.c **** 	{
 754:FreeRTOS/Src/tasks.c **** 	TCB_t *pxNewTCB;
 755:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
 756:FreeRTOS/Src/tasks.c **** 
 757:FreeRTOS/Src/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 758:FreeRTOS/Src/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 759:FreeRTOS/Src/tasks.c **** 		the TCB then the stack. */
 760:FreeRTOS/Src/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 761:FreeRTOS/Src/tasks.c **** 		{
 762:FreeRTOS/Src/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 763:FreeRTOS/Src/tasks.c **** 			the implementation of the port malloc function and whether or not static
 764:FreeRTOS/Src/tasks.c **** 			allocation is being used. */
 765:FreeRTOS/Src/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 766:FreeRTOS/Src/tasks.c **** 
 767:FreeRTOS/Src/tasks.c **** 			if( pxNewTCB != NULL )
 768:FreeRTOS/Src/tasks.c **** 			{
 769:FreeRTOS/Src/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 770:FreeRTOS/Src/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 771:FreeRTOS/Src/tasks.c **** 				be deleted later if required. */
 772:FreeRTOS/Src/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 773:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 15


 774:FreeRTOS/Src/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 775:FreeRTOS/Src/tasks.c **** 				{
 776:FreeRTOS/Src/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 777:FreeRTOS/Src/tasks.c **** 					vPortFree( pxNewTCB );
 778:FreeRTOS/Src/tasks.c **** 					pxNewTCB = NULL;
 779:FreeRTOS/Src/tasks.c **** 				}
 780:FreeRTOS/Src/tasks.c **** 			}
 781:FreeRTOS/Src/tasks.c **** 		}
 782:FreeRTOS/Src/tasks.c **** 		#else /* portSTACK_GROWTH */
 783:FreeRTOS/Src/tasks.c **** 		{
 784:FreeRTOS/Src/tasks.c **** 		StackType_t *pxStack;
 785:FreeRTOS/Src/tasks.c **** 
 786:FreeRTOS/Src/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 787:FreeRTOS/Src/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 788:FreeRTOS/Src/tasks.c **** 
 789:FreeRTOS/Src/tasks.c **** 			if( pxStack != NULL )
 790:FreeRTOS/Src/tasks.c **** 			{
 791:FreeRTOS/Src/tasks.c **** 				/* Allocate space for the TCB. */
 792:FreeRTOS/Src/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 793:FreeRTOS/Src/tasks.c **** 
 794:FreeRTOS/Src/tasks.c **** 				if( pxNewTCB != NULL )
 795:FreeRTOS/Src/tasks.c **** 				{
 796:FreeRTOS/Src/tasks.c **** 					/* Store the stack location in the TCB. */
 797:FreeRTOS/Src/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 798:FreeRTOS/Src/tasks.c **** 				}
 799:FreeRTOS/Src/tasks.c **** 				else
 800:FreeRTOS/Src/tasks.c **** 				{
 801:FreeRTOS/Src/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 802:FreeRTOS/Src/tasks.c **** 					it again. */
 803:FreeRTOS/Src/tasks.c **** 					vPortFree( pxStack );
 804:FreeRTOS/Src/tasks.c **** 				}
 805:FreeRTOS/Src/tasks.c **** 			}
 806:FreeRTOS/Src/tasks.c **** 			else
 807:FreeRTOS/Src/tasks.c **** 			{
 808:FreeRTOS/Src/tasks.c **** 				pxNewTCB = NULL;
 809:FreeRTOS/Src/tasks.c **** 			}
 810:FreeRTOS/Src/tasks.c **** 		}
 811:FreeRTOS/Src/tasks.c **** 		#endif /* portSTACK_GROWTH */
 812:FreeRTOS/Src/tasks.c **** 
 813:FreeRTOS/Src/tasks.c **** 		if( pxNewTCB != NULL )
 814:FreeRTOS/Src/tasks.c **** 		{
 815:FreeRTOS/Src/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 816:FreeRTOS/Src/tasks.c **** 			{
 817:FreeRTOS/Src/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 818:FreeRTOS/Src/tasks.c **** 				task was created dynamically in case it is later deleted. */
 819:FreeRTOS/Src/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 820:FreeRTOS/Src/tasks.c **** 			}
 821:FreeRTOS/Src/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 822:FreeRTOS/Src/tasks.c **** 
 823:FreeRTOS/Src/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 824:FreeRTOS/Src/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 825:FreeRTOS/Src/tasks.c **** 			xReturn = pdPASS;
 826:FreeRTOS/Src/tasks.c **** 		}
 827:FreeRTOS/Src/tasks.c **** 		else
 828:FreeRTOS/Src/tasks.c **** 		{
 829:FreeRTOS/Src/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 830:FreeRTOS/Src/tasks.c **** 		}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 16


 831:FreeRTOS/Src/tasks.c **** 
 832:FreeRTOS/Src/tasks.c **** 		return xReturn;
 833:FreeRTOS/Src/tasks.c **** 	}
 834:FreeRTOS/Src/tasks.c **** 
 835:FreeRTOS/Src/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 836:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 837:FreeRTOS/Src/tasks.c **** 
 838:FreeRTOS/Src/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 839:FreeRTOS/Src/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 840:FreeRTOS/Src/tasks.c **** 									const uint32_t ulStackDepth,
 841:FreeRTOS/Src/tasks.c **** 									void * const pvParameters,
 842:FreeRTOS/Src/tasks.c **** 									UBaseType_t uxPriority,
 843:FreeRTOS/Src/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 844:FreeRTOS/Src/tasks.c **** 									TCB_t *pxNewTCB,
 845:FreeRTOS/Src/tasks.c **** 									const MemoryRegion_t * const xRegions )
 846:FreeRTOS/Src/tasks.c **** {
 847:FreeRTOS/Src/tasks.c **** StackType_t *pxTopOfStack;
 848:FreeRTOS/Src/tasks.c **** UBaseType_t x;
 849:FreeRTOS/Src/tasks.c **** 
 850:FreeRTOS/Src/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 851:FreeRTOS/Src/tasks.c **** 		/* Should the task be created in privileged mode? */
 852:FreeRTOS/Src/tasks.c **** 		BaseType_t xRunPrivileged;
 853:FreeRTOS/Src/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 854:FreeRTOS/Src/tasks.c **** 		{
 855:FreeRTOS/Src/tasks.c **** 			xRunPrivileged = pdTRUE;
 856:FreeRTOS/Src/tasks.c **** 		}
 857:FreeRTOS/Src/tasks.c **** 		else
 858:FreeRTOS/Src/tasks.c **** 		{
 859:FreeRTOS/Src/tasks.c **** 			xRunPrivileged = pdFALSE;
 860:FreeRTOS/Src/tasks.c **** 		}
 861:FreeRTOS/Src/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 862:FreeRTOS/Src/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 863:FreeRTOS/Src/tasks.c **** 
 864:FreeRTOS/Src/tasks.c **** 	configASSERT( pcName );
 865:FreeRTOS/Src/tasks.c **** 
 866:FreeRTOS/Src/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 867:FreeRTOS/Src/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 868:FreeRTOS/Src/tasks.c **** 	{
 869:FreeRTOS/Src/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 870:FreeRTOS/Src/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 871:FreeRTOS/Src/tasks.c **** 	}
 872:FreeRTOS/Src/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 873:FreeRTOS/Src/tasks.c **** 
 874:FreeRTOS/Src/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 875:FreeRTOS/Src/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 876:FreeRTOS/Src/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 877:FreeRTOS/Src/tasks.c **** 	by the port. */
 878:FreeRTOS/Src/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 879:FreeRTOS/Src/tasks.c **** 	{
 880:FreeRTOS/Src/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 881:FreeRTOS/Src/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 882:FreeRTOS/Src/tasks.c **** 
 883:FreeRTOS/Src/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 884:FreeRTOS/Src/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 885:FreeRTOS/Src/tasks.c **** 
 886:FreeRTOS/Src/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 887:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 17


 888:FreeRTOS/Src/tasks.c **** 			/* Also record the stack's high address, which may assist
 889:FreeRTOS/Src/tasks.c **** 			debugging. */
 890:FreeRTOS/Src/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 891:FreeRTOS/Src/tasks.c **** 		}
 892:FreeRTOS/Src/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 893:FreeRTOS/Src/tasks.c **** 	}
 894:FreeRTOS/Src/tasks.c **** 	#else /* portSTACK_GROWTH */
 895:FreeRTOS/Src/tasks.c **** 	{
 896:FreeRTOS/Src/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 897:FreeRTOS/Src/tasks.c **** 
 898:FreeRTOS/Src/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 899:FreeRTOS/Src/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 900:FreeRTOS/Src/tasks.c **** 
 901:FreeRTOS/Src/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 902:FreeRTOS/Src/tasks.c **** 		performed. */
 903:FreeRTOS/Src/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 904:FreeRTOS/Src/tasks.c **** 	}
 905:FreeRTOS/Src/tasks.c **** 	#endif /* portSTACK_GROWTH */
 906:FreeRTOS/Src/tasks.c **** 
 907:FreeRTOS/Src/tasks.c **** 	/* Store the task name in the TCB. */
 908:FreeRTOS/Src/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 909:FreeRTOS/Src/tasks.c **** 	{
 910:FreeRTOS/Src/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 911:FreeRTOS/Src/tasks.c **** 
 912:FreeRTOS/Src/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 913:FreeRTOS/Src/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 914:FreeRTOS/Src/tasks.c **** 		string is not accessible (extremely unlikely). */
 915:FreeRTOS/Src/tasks.c **** 		if( pcName[ x ] == ( char ) 0x00 )
 916:FreeRTOS/Src/tasks.c **** 		{
 917:FreeRTOS/Src/tasks.c **** 			break;
 918:FreeRTOS/Src/tasks.c **** 		}
 919:FreeRTOS/Src/tasks.c **** 		else
 920:FreeRTOS/Src/tasks.c **** 		{
 921:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 922:FreeRTOS/Src/tasks.c **** 		}
 923:FreeRTOS/Src/tasks.c **** 	}
 924:FreeRTOS/Src/tasks.c **** 
 925:FreeRTOS/Src/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 926:FreeRTOS/Src/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 927:FreeRTOS/Src/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 928:FreeRTOS/Src/tasks.c **** 
 929:FreeRTOS/Src/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 930:FreeRTOS/Src/tasks.c **** 	remove the privilege bit if one is present. */
 931:FreeRTOS/Src/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 932:FreeRTOS/Src/tasks.c **** 	{
 933:FreeRTOS/Src/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 934:FreeRTOS/Src/tasks.c **** 	}
 935:FreeRTOS/Src/tasks.c **** 	else
 936:FreeRTOS/Src/tasks.c **** 	{
 937:FreeRTOS/Src/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 938:FreeRTOS/Src/tasks.c **** 	}
 939:FreeRTOS/Src/tasks.c **** 
 940:FreeRTOS/Src/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 941:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 942:FreeRTOS/Src/tasks.c **** 	{
 943:FreeRTOS/Src/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 944:FreeRTOS/Src/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 18


 945:FreeRTOS/Src/tasks.c **** 	}
 946:FreeRTOS/Src/tasks.c **** 	#endif /* configUSE_MUTEXES */
 947:FreeRTOS/Src/tasks.c **** 
 948:FreeRTOS/Src/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 949:FreeRTOS/Src/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 950:FreeRTOS/Src/tasks.c **** 
 951:FreeRTOS/Src/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 952:FreeRTOS/Src/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 953:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 954:FreeRTOS/Src/tasks.c **** 
 955:FreeRTOS/Src/tasks.c **** 	/* Event lists are always in priority order. */
 956:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 957:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 958:FreeRTOS/Src/tasks.c **** 
 959:FreeRTOS/Src/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 960:FreeRTOS/Src/tasks.c **** 	{
 961:FreeRTOS/Src/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 962:FreeRTOS/Src/tasks.c **** 	}
 963:FreeRTOS/Src/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 964:FreeRTOS/Src/tasks.c **** 
 965:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 966:FreeRTOS/Src/tasks.c **** 	{
 967:FreeRTOS/Src/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 968:FreeRTOS/Src/tasks.c **** 	}
 969:FreeRTOS/Src/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 970:FreeRTOS/Src/tasks.c **** 
 971:FreeRTOS/Src/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 972:FreeRTOS/Src/tasks.c **** 	{
 973:FreeRTOS/Src/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 974:FreeRTOS/Src/tasks.c **** 	}
 975:FreeRTOS/Src/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 976:FreeRTOS/Src/tasks.c **** 
 977:FreeRTOS/Src/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 978:FreeRTOS/Src/tasks.c **** 	{
 979:FreeRTOS/Src/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 980:FreeRTOS/Src/tasks.c **** 	}
 981:FreeRTOS/Src/tasks.c **** 	#else
 982:FreeRTOS/Src/tasks.c **** 	{
 983:FreeRTOS/Src/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 984:FreeRTOS/Src/tasks.c **** 		( void ) xRegions;
 985:FreeRTOS/Src/tasks.c **** 	}
 986:FreeRTOS/Src/tasks.c **** 	#endif
 987:FreeRTOS/Src/tasks.c **** 
 988:FreeRTOS/Src/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 989:FreeRTOS/Src/tasks.c **** 	{
 990:FreeRTOS/Src/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 991:FreeRTOS/Src/tasks.c **** 		{
 992:FreeRTOS/Src/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 993:FreeRTOS/Src/tasks.c **** 		}
 994:FreeRTOS/Src/tasks.c **** 	}
 995:FreeRTOS/Src/tasks.c **** 	#endif
 996:FreeRTOS/Src/tasks.c **** 
 997:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 998:FreeRTOS/Src/tasks.c **** 	{
 999:FreeRTOS/Src/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
1000:FreeRTOS/Src/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1001:FreeRTOS/Src/tasks.c **** 	}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 19


1002:FreeRTOS/Src/tasks.c **** 	#endif
1003:FreeRTOS/Src/tasks.c **** 
1004:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
1005:FreeRTOS/Src/tasks.c **** 	{
1006:FreeRTOS/Src/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
1007:FreeRTOS/Src/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1008:FreeRTOS/Src/tasks.c **** 	}
1009:FreeRTOS/Src/tasks.c **** 	#endif
1010:FreeRTOS/Src/tasks.c **** 
1011:FreeRTOS/Src/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1012:FreeRTOS/Src/tasks.c **** 	{
1013:FreeRTOS/Src/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1014:FreeRTOS/Src/tasks.c **** 	}
1015:FreeRTOS/Src/tasks.c **** 	#endif
1016:FreeRTOS/Src/tasks.c **** 
1017:FreeRTOS/Src/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1018:FreeRTOS/Src/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1019:FreeRTOS/Src/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1020:FreeRTOS/Src/tasks.c **** 	the top of stack variable is updated. */
1021:FreeRTOS/Src/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1022:FreeRTOS/Src/tasks.c **** 	{
1023:FreeRTOS/Src/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1024:FreeRTOS/Src/tasks.c **** 	}
1025:FreeRTOS/Src/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1026:FreeRTOS/Src/tasks.c **** 	{
1027:FreeRTOS/Src/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1028:FreeRTOS/Src/tasks.c **** 	}
1029:FreeRTOS/Src/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1030:FreeRTOS/Src/tasks.c **** 
1031:FreeRTOS/Src/tasks.c **** 	if( pxCreatedTask != NULL )
1032:FreeRTOS/Src/tasks.c **** 	{
1033:FreeRTOS/Src/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1034:FreeRTOS/Src/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1035:FreeRTOS/Src/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1036:FreeRTOS/Src/tasks.c **** 	}
1037:FreeRTOS/Src/tasks.c **** 	else
1038:FreeRTOS/Src/tasks.c **** 	{
1039:FreeRTOS/Src/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1040:FreeRTOS/Src/tasks.c **** 	}
1041:FreeRTOS/Src/tasks.c **** }
1042:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1043:FreeRTOS/Src/tasks.c **** 
1044:FreeRTOS/Src/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1045:FreeRTOS/Src/tasks.c **** {
1046:FreeRTOS/Src/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1047:FreeRTOS/Src/tasks.c **** 	updated. */
1048:FreeRTOS/Src/tasks.c **** 	taskENTER_CRITICAL();
1049:FreeRTOS/Src/tasks.c **** 	{
1050:FreeRTOS/Src/tasks.c **** 		uxCurrentNumberOfTasks++;
1051:FreeRTOS/Src/tasks.c **** 		if( pxCurrentTCB == NULL )
1052:FreeRTOS/Src/tasks.c **** 		{
1053:FreeRTOS/Src/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1054:FreeRTOS/Src/tasks.c **** 			the suspended state - make this the current task. */
1055:FreeRTOS/Src/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1056:FreeRTOS/Src/tasks.c **** 
1057:FreeRTOS/Src/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1058:FreeRTOS/Src/tasks.c **** 			{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 20


1059:FreeRTOS/Src/tasks.c **** 				/* This is the first task to be created so do the preliminary
1060:FreeRTOS/Src/tasks.c **** 				initialisation required.  We will not recover if this call
1061:FreeRTOS/Src/tasks.c **** 				fails, but we will report the failure. */
1062:FreeRTOS/Src/tasks.c **** 				prvInitialiseTaskLists();
1063:FreeRTOS/Src/tasks.c **** 			}
1064:FreeRTOS/Src/tasks.c **** 			else
1065:FreeRTOS/Src/tasks.c **** 			{
1066:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1067:FreeRTOS/Src/tasks.c **** 			}
1068:FreeRTOS/Src/tasks.c **** 		}
1069:FreeRTOS/Src/tasks.c **** 		else
1070:FreeRTOS/Src/tasks.c **** 		{
1071:FreeRTOS/Src/tasks.c **** 			/* If the scheduler is not already running, make this task the
1072:FreeRTOS/Src/tasks.c **** 			current task if it is the highest priority task to be created
1073:FreeRTOS/Src/tasks.c **** 			so far. */
1074:FreeRTOS/Src/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1075:FreeRTOS/Src/tasks.c **** 			{
1076:FreeRTOS/Src/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1077:FreeRTOS/Src/tasks.c **** 				{
1078:FreeRTOS/Src/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1079:FreeRTOS/Src/tasks.c **** 				}
1080:FreeRTOS/Src/tasks.c **** 				else
1081:FreeRTOS/Src/tasks.c **** 				{
1082:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1083:FreeRTOS/Src/tasks.c **** 				}
1084:FreeRTOS/Src/tasks.c **** 			}
1085:FreeRTOS/Src/tasks.c **** 			else
1086:FreeRTOS/Src/tasks.c **** 			{
1087:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1088:FreeRTOS/Src/tasks.c **** 			}
1089:FreeRTOS/Src/tasks.c **** 		}
1090:FreeRTOS/Src/tasks.c **** 
1091:FreeRTOS/Src/tasks.c **** 		uxTaskNumber++;
1092:FreeRTOS/Src/tasks.c **** 
1093:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1094:FreeRTOS/Src/tasks.c **** 		{
1095:FreeRTOS/Src/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1096:FreeRTOS/Src/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1097:FreeRTOS/Src/tasks.c **** 		}
1098:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1099:FreeRTOS/Src/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1100:FreeRTOS/Src/tasks.c **** 
1101:FreeRTOS/Src/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1102:FreeRTOS/Src/tasks.c **** 
1103:FreeRTOS/Src/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1104:FreeRTOS/Src/tasks.c **** 	}
1105:FreeRTOS/Src/tasks.c **** 	taskEXIT_CRITICAL();
1106:FreeRTOS/Src/tasks.c **** 
1107:FreeRTOS/Src/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1108:FreeRTOS/Src/tasks.c **** 	{
1109:FreeRTOS/Src/tasks.c **** 		/* If the created task is of a higher priority than the current task
1110:FreeRTOS/Src/tasks.c **** 		then it should run now. */
1111:FreeRTOS/Src/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1112:FreeRTOS/Src/tasks.c **** 		{
1113:FreeRTOS/Src/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1114:FreeRTOS/Src/tasks.c **** 		}
1115:FreeRTOS/Src/tasks.c **** 		else
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 21


1116:FreeRTOS/Src/tasks.c **** 		{
1117:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1118:FreeRTOS/Src/tasks.c **** 		}
1119:FreeRTOS/Src/tasks.c **** 	}
1120:FreeRTOS/Src/tasks.c **** 	else
1121:FreeRTOS/Src/tasks.c **** 	{
1122:FreeRTOS/Src/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1123:FreeRTOS/Src/tasks.c **** 	}
1124:FreeRTOS/Src/tasks.c **** }
1125:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1126:FreeRTOS/Src/tasks.c **** 
1127:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1128:FreeRTOS/Src/tasks.c **** 
1129:FreeRTOS/Src/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1130:FreeRTOS/Src/tasks.c **** 	{
1131:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
1132:FreeRTOS/Src/tasks.c **** 
1133:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
1134:FreeRTOS/Src/tasks.c **** 		{
1135:FreeRTOS/Src/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1136:FreeRTOS/Src/tasks.c **** 			being deleted. */
1137:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1138:FreeRTOS/Src/tasks.c **** 
1139:FreeRTOS/Src/tasks.c **** 			/* Remove task from the ready list. */
1140:FreeRTOS/Src/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1141:FreeRTOS/Src/tasks.c **** 			{
1142:FreeRTOS/Src/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1143:FreeRTOS/Src/tasks.c **** 			}
1144:FreeRTOS/Src/tasks.c **** 			else
1145:FreeRTOS/Src/tasks.c **** 			{
1146:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1147:FreeRTOS/Src/tasks.c **** 			}
1148:FreeRTOS/Src/tasks.c **** 
1149:FreeRTOS/Src/tasks.c **** 			/* Is the task waiting on an event also? */
1150:FreeRTOS/Src/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1151:FreeRTOS/Src/tasks.c **** 			{
1152:FreeRTOS/Src/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1153:FreeRTOS/Src/tasks.c **** 			}
1154:FreeRTOS/Src/tasks.c **** 			else
1155:FreeRTOS/Src/tasks.c **** 			{
1156:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1157:FreeRTOS/Src/tasks.c **** 			}
1158:FreeRTOS/Src/tasks.c **** 
1159:FreeRTOS/Src/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1160:FreeRTOS/Src/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1161:FreeRTOS/Src/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1162:FreeRTOS/Src/tasks.c **** 			not return. */
1163:FreeRTOS/Src/tasks.c **** 			uxTaskNumber++;
1164:FreeRTOS/Src/tasks.c **** 
1165:FreeRTOS/Src/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1166:FreeRTOS/Src/tasks.c **** 			{
1167:FreeRTOS/Src/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1168:FreeRTOS/Src/tasks.c **** 				task itself, as a context switch to another task is required.
1169:FreeRTOS/Src/tasks.c **** 				Place the task in the termination list.  The idle task will
1170:FreeRTOS/Src/tasks.c **** 				check the termination list and free up any memory allocated by
1171:FreeRTOS/Src/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1172:FreeRTOS/Src/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 22


1173:FreeRTOS/Src/tasks.c **** 
1174:FreeRTOS/Src/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1175:FreeRTOS/Src/tasks.c **** 				there is a task that has been deleted and that it should therefore
1176:FreeRTOS/Src/tasks.c **** 				check the xTasksWaitingTermination list. */
1177:FreeRTOS/Src/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1178:FreeRTOS/Src/tasks.c **** 
1179:FreeRTOS/Src/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1180:FreeRTOS/Src/tasks.c **** 				in which Windows specific clean up operations are performed,
1181:FreeRTOS/Src/tasks.c **** 				after which it is not possible to yield away from this task -
1182:FreeRTOS/Src/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1183:FreeRTOS/Src/tasks.c **** 				required. */
1184:FreeRTOS/Src/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1185:FreeRTOS/Src/tasks.c **** 			}
1186:FreeRTOS/Src/tasks.c **** 			else
1187:FreeRTOS/Src/tasks.c **** 			{
1188:FreeRTOS/Src/tasks.c **** 				--uxCurrentNumberOfTasks;
1189:FreeRTOS/Src/tasks.c **** 				prvDeleteTCB( pxTCB );
1190:FreeRTOS/Src/tasks.c **** 
1191:FreeRTOS/Src/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1192:FreeRTOS/Src/tasks.c **** 				the task that has just been deleted. */
1193:FreeRTOS/Src/tasks.c **** 				prvResetNextTaskUnblockTime();
1194:FreeRTOS/Src/tasks.c **** 			}
1195:FreeRTOS/Src/tasks.c **** 
1196:FreeRTOS/Src/tasks.c **** 			traceTASK_DELETE( pxTCB );
1197:FreeRTOS/Src/tasks.c **** 		}
1198:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
1199:FreeRTOS/Src/tasks.c **** 
1200:FreeRTOS/Src/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1201:FreeRTOS/Src/tasks.c **** 		been deleted. */
1202:FreeRTOS/Src/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1203:FreeRTOS/Src/tasks.c **** 		{
1204:FreeRTOS/Src/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1205:FreeRTOS/Src/tasks.c **** 			{
1206:FreeRTOS/Src/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1207:FreeRTOS/Src/tasks.c **** 				portYIELD_WITHIN_API();
1208:FreeRTOS/Src/tasks.c **** 			}
1209:FreeRTOS/Src/tasks.c **** 			else
1210:FreeRTOS/Src/tasks.c **** 			{
1211:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1212:FreeRTOS/Src/tasks.c **** 			}
1213:FreeRTOS/Src/tasks.c **** 		}
1214:FreeRTOS/Src/tasks.c **** 	}
1215:FreeRTOS/Src/tasks.c **** 
1216:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1217:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1218:FreeRTOS/Src/tasks.c **** 
1219:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1220:FreeRTOS/Src/tasks.c **** 
1221:FreeRTOS/Src/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1222:FreeRTOS/Src/tasks.c **** 	{
1223:FreeRTOS/Src/tasks.c **** 	TickType_t xTimeToWake;
1224:FreeRTOS/Src/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1225:FreeRTOS/Src/tasks.c **** 
1226:FreeRTOS/Src/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1227:FreeRTOS/Src/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1228:FreeRTOS/Src/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1229:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 23


1230:FreeRTOS/Src/tasks.c **** 		vTaskSuspendAll();
1231:FreeRTOS/Src/tasks.c **** 		{
1232:FreeRTOS/Src/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1233:FreeRTOS/Src/tasks.c **** 			block. */
1234:FreeRTOS/Src/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1235:FreeRTOS/Src/tasks.c **** 
1236:FreeRTOS/Src/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1237:FreeRTOS/Src/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1238:FreeRTOS/Src/tasks.c **** 
1239:FreeRTOS/Src/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1240:FreeRTOS/Src/tasks.c **** 			{
1241:FreeRTOS/Src/tasks.c **** 				/* The tick count has overflowed since this function was
1242:FreeRTOS/Src/tasks.c **** 				lasted called.  In this case the only time we should ever
1243:FreeRTOS/Src/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1244:FreeRTOS/Src/tasks.c **** 				and the wake time is greater than the tick time.  When this
1245:FreeRTOS/Src/tasks.c **** 				is the case it is as if neither time had overflowed. */
1246:FreeRTOS/Src/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1247:FreeRTOS/Src/tasks.c **** 				{
1248:FreeRTOS/Src/tasks.c **** 					xShouldDelay = pdTRUE;
1249:FreeRTOS/Src/tasks.c **** 				}
1250:FreeRTOS/Src/tasks.c **** 				else
1251:FreeRTOS/Src/tasks.c **** 				{
1252:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1253:FreeRTOS/Src/tasks.c **** 				}
1254:FreeRTOS/Src/tasks.c **** 			}
1255:FreeRTOS/Src/tasks.c **** 			else
1256:FreeRTOS/Src/tasks.c **** 			{
1257:FreeRTOS/Src/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1258:FreeRTOS/Src/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1259:FreeRTOS/Src/tasks.c **** 				tick time is less than the wake time. */
1260:FreeRTOS/Src/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1261:FreeRTOS/Src/tasks.c **** 				{
1262:FreeRTOS/Src/tasks.c **** 					xShouldDelay = pdTRUE;
1263:FreeRTOS/Src/tasks.c **** 				}
1264:FreeRTOS/Src/tasks.c **** 				else
1265:FreeRTOS/Src/tasks.c **** 				{
1266:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1267:FreeRTOS/Src/tasks.c **** 				}
1268:FreeRTOS/Src/tasks.c **** 			}
1269:FreeRTOS/Src/tasks.c **** 
1270:FreeRTOS/Src/tasks.c **** 			/* Update the wake time ready for the next call. */
1271:FreeRTOS/Src/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1272:FreeRTOS/Src/tasks.c **** 
1273:FreeRTOS/Src/tasks.c **** 			if( xShouldDelay != pdFALSE )
1274:FreeRTOS/Src/tasks.c **** 			{
1275:FreeRTOS/Src/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1276:FreeRTOS/Src/tasks.c **** 
1277:FreeRTOS/Src/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1278:FreeRTOS/Src/tasks.c **** 				the time to wake, so subtract the current tick count. */
1279:FreeRTOS/Src/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1280:FreeRTOS/Src/tasks.c **** 			}
1281:FreeRTOS/Src/tasks.c **** 			else
1282:FreeRTOS/Src/tasks.c **** 			{
1283:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1284:FreeRTOS/Src/tasks.c **** 			}
1285:FreeRTOS/Src/tasks.c **** 		}
1286:FreeRTOS/Src/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 24


1287:FreeRTOS/Src/tasks.c **** 
1288:FreeRTOS/Src/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1289:FreeRTOS/Src/tasks.c **** 		have put ourselves to sleep. */
1290:FreeRTOS/Src/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1291:FreeRTOS/Src/tasks.c **** 		{
1292:FreeRTOS/Src/tasks.c **** 			portYIELD_WITHIN_API();
1293:FreeRTOS/Src/tasks.c **** 		}
1294:FreeRTOS/Src/tasks.c **** 		else
1295:FreeRTOS/Src/tasks.c **** 		{
1296:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1297:FreeRTOS/Src/tasks.c **** 		}
1298:FreeRTOS/Src/tasks.c **** 	}
1299:FreeRTOS/Src/tasks.c **** 
1300:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1301:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1302:FreeRTOS/Src/tasks.c **** 
1303:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1304:FreeRTOS/Src/tasks.c **** 
1305:FreeRTOS/Src/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1306:FreeRTOS/Src/tasks.c **** 	{
1307:FreeRTOS/Src/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1308:FreeRTOS/Src/tasks.c **** 
1309:FreeRTOS/Src/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1310:FreeRTOS/Src/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1311:FreeRTOS/Src/tasks.c **** 		{
1312:FreeRTOS/Src/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1313:FreeRTOS/Src/tasks.c **** 			vTaskSuspendAll();
1314:FreeRTOS/Src/tasks.c **** 			{
1315:FreeRTOS/Src/tasks.c **** 				traceTASK_DELAY();
1316:FreeRTOS/Src/tasks.c **** 
1317:FreeRTOS/Src/tasks.c **** 				/* A task that is removed from the event list while the
1318:FreeRTOS/Src/tasks.c **** 				scheduler is suspended will not get placed in the ready
1319:FreeRTOS/Src/tasks.c **** 				list or removed from the blocked list until the scheduler
1320:FreeRTOS/Src/tasks.c **** 				is resumed.
1321:FreeRTOS/Src/tasks.c **** 
1322:FreeRTOS/Src/tasks.c **** 				This task cannot be in an event list as it is the currently
1323:FreeRTOS/Src/tasks.c **** 				executing task. */
1324:FreeRTOS/Src/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1325:FreeRTOS/Src/tasks.c **** 			}
1326:FreeRTOS/Src/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1327:FreeRTOS/Src/tasks.c **** 		}
1328:FreeRTOS/Src/tasks.c **** 		else
1329:FreeRTOS/Src/tasks.c **** 		{
1330:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1331:FreeRTOS/Src/tasks.c **** 		}
1332:FreeRTOS/Src/tasks.c **** 
1333:FreeRTOS/Src/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:FreeRTOS/Src/tasks.c **** 		have put ourselves to sleep. */
1335:FreeRTOS/Src/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1336:FreeRTOS/Src/tasks.c **** 		{
1337:FreeRTOS/Src/tasks.c **** 			portYIELD_WITHIN_API();
1338:FreeRTOS/Src/tasks.c **** 		}
1339:FreeRTOS/Src/tasks.c **** 		else
1340:FreeRTOS/Src/tasks.c **** 		{
1341:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1342:FreeRTOS/Src/tasks.c **** 		}
1343:FreeRTOS/Src/tasks.c **** 	}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 25


1344:FreeRTOS/Src/tasks.c **** 
1345:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1346:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1347:FreeRTOS/Src/tasks.c **** 
1348:FreeRTOS/Src/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1349:FreeRTOS/Src/tasks.c **** 
1350:FreeRTOS/Src/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1351:FreeRTOS/Src/tasks.c **** 	{
1352:FreeRTOS/Src/tasks.c **** 	eTaskState eReturn;
1353:FreeRTOS/Src/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1354:FreeRTOS/Src/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1355:FreeRTOS/Src/tasks.c **** 
1356:FreeRTOS/Src/tasks.c **** 		configASSERT( pxTCB );
1357:FreeRTOS/Src/tasks.c **** 
1358:FreeRTOS/Src/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1359:FreeRTOS/Src/tasks.c **** 		{
1360:FreeRTOS/Src/tasks.c **** 			/* The task calling this function is querying its own state. */
1361:FreeRTOS/Src/tasks.c **** 			eReturn = eRunning;
1362:FreeRTOS/Src/tasks.c **** 		}
1363:FreeRTOS/Src/tasks.c **** 		else
1364:FreeRTOS/Src/tasks.c **** 		{
1365:FreeRTOS/Src/tasks.c **** 			taskENTER_CRITICAL();
1366:FreeRTOS/Src/tasks.c **** 			{
1367:FreeRTOS/Src/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1368:FreeRTOS/Src/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1369:FreeRTOS/Src/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1370:FreeRTOS/Src/tasks.c **** 			}
1371:FreeRTOS/Src/tasks.c **** 			taskEXIT_CRITICAL();
1372:FreeRTOS/Src/tasks.c **** 
1373:FreeRTOS/Src/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1374:FreeRTOS/Src/tasks.c **** 			{
1375:FreeRTOS/Src/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1376:FreeRTOS/Src/tasks.c **** 				lists. */
1377:FreeRTOS/Src/tasks.c **** 				eReturn = eBlocked;
1378:FreeRTOS/Src/tasks.c **** 			}
1379:FreeRTOS/Src/tasks.c **** 
1380:FreeRTOS/Src/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1381:FreeRTOS/Src/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1382:FreeRTOS/Src/tasks.c **** 				{
1383:FreeRTOS/Src/tasks.c **** 					/* The task being queried is referenced from the suspended
1384:FreeRTOS/Src/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1385:FreeRTOS/Src/tasks.c **** 					indefinitely? */
1386:FreeRTOS/Src/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1387:FreeRTOS/Src/tasks.c **** 					{
1388:FreeRTOS/Src/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1389:FreeRTOS/Src/tasks.c **** 						{
1390:FreeRTOS/Src/tasks.c **** 							/* The task does not appear on the event list item of
1391:FreeRTOS/Src/tasks.c **** 							and of the RTOS objects, but could still be in the
1392:FreeRTOS/Src/tasks.c **** 							blocked state if it is waiting on its notification
1393:FreeRTOS/Src/tasks.c **** 							rather than waiting on an object. */
1394:FreeRTOS/Src/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1395:FreeRTOS/Src/tasks.c **** 							{
1396:FreeRTOS/Src/tasks.c **** 								eReturn = eBlocked;
1397:FreeRTOS/Src/tasks.c **** 							}
1398:FreeRTOS/Src/tasks.c **** 							else
1399:FreeRTOS/Src/tasks.c **** 							{
1400:FreeRTOS/Src/tasks.c **** 								eReturn = eSuspended;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 26


1401:FreeRTOS/Src/tasks.c **** 							}
1402:FreeRTOS/Src/tasks.c **** 						}
1403:FreeRTOS/Src/tasks.c **** 						#else
1404:FreeRTOS/Src/tasks.c **** 						{
1405:FreeRTOS/Src/tasks.c **** 							eReturn = eSuspended;
1406:FreeRTOS/Src/tasks.c **** 						}
1407:FreeRTOS/Src/tasks.c **** 						#endif
1408:FreeRTOS/Src/tasks.c **** 					}
1409:FreeRTOS/Src/tasks.c **** 					else
1410:FreeRTOS/Src/tasks.c **** 					{
1411:FreeRTOS/Src/tasks.c **** 						eReturn = eBlocked;
1412:FreeRTOS/Src/tasks.c **** 					}
1413:FreeRTOS/Src/tasks.c **** 				}
1414:FreeRTOS/Src/tasks.c **** 			#endif
1415:FreeRTOS/Src/tasks.c **** 
1416:FreeRTOS/Src/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1417:FreeRTOS/Src/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1418:FreeRTOS/Src/tasks.c **** 				{
1419:FreeRTOS/Src/tasks.c **** 					/* The task being queried is referenced from the deleted
1420:FreeRTOS/Src/tasks.c **** 					tasks list, or it is not referenced from any lists at
1421:FreeRTOS/Src/tasks.c **** 					all. */
1422:FreeRTOS/Src/tasks.c **** 					eReturn = eDeleted;
1423:FreeRTOS/Src/tasks.c **** 				}
1424:FreeRTOS/Src/tasks.c **** 			#endif
1425:FreeRTOS/Src/tasks.c **** 
1426:FreeRTOS/Src/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1427:FreeRTOS/Src/tasks.c **** 			{
1428:FreeRTOS/Src/tasks.c **** 				/* If the task is not in any other state, it must be in the
1429:FreeRTOS/Src/tasks.c **** 				Ready (including pending ready) state. */
1430:FreeRTOS/Src/tasks.c **** 				eReturn = eReady;
1431:FreeRTOS/Src/tasks.c **** 			}
1432:FreeRTOS/Src/tasks.c **** 		}
1433:FreeRTOS/Src/tasks.c **** 
1434:FreeRTOS/Src/tasks.c **** 		return eReturn;
1435:FreeRTOS/Src/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1436:FreeRTOS/Src/tasks.c **** 
1437:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1438:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1439:FreeRTOS/Src/tasks.c **** 
1440:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1441:FreeRTOS/Src/tasks.c **** 
1442:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1443:FreeRTOS/Src/tasks.c **** 	{
1444:FreeRTOS/Src/tasks.c **** 	TCB_t const *pxTCB;
1445:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxReturn;
1446:FreeRTOS/Src/tasks.c **** 
1447:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
1448:FreeRTOS/Src/tasks.c **** 		{
1449:FreeRTOS/Src/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1450:FreeRTOS/Src/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1451:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1452:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1453:FreeRTOS/Src/tasks.c **** 		}
1454:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
1455:FreeRTOS/Src/tasks.c **** 
1456:FreeRTOS/Src/tasks.c **** 		return uxReturn;
1457:FreeRTOS/Src/tasks.c **** 	}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 27


1458:FreeRTOS/Src/tasks.c **** 
1459:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1460:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1461:FreeRTOS/Src/tasks.c **** 
1462:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1463:FreeRTOS/Src/tasks.c **** 
1464:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1465:FreeRTOS/Src/tasks.c **** 	{
1466:FreeRTOS/Src/tasks.c **** 	TCB_t const *pxTCB;
1467:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1468:FreeRTOS/Src/tasks.c **** 
1469:FreeRTOS/Src/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1470:FreeRTOS/Src/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1471:FreeRTOS/Src/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1472:FreeRTOS/Src/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1473:FreeRTOS/Src/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1474:FreeRTOS/Src/tasks.c **** 		is defined in FreeRTOSConfig.h then
1475:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1476:FreeRTOS/Src/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1477:FreeRTOS/Src/tasks.c **** 		been assigned a priority above the configured maximum system call
1478:FreeRTOS/Src/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1479:FreeRTOS/Src/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1480:FreeRTOS/Src/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1481:FreeRTOS/Src/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1482:FreeRTOS/Src/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1483:FreeRTOS/Src/tasks.c **** 		provided on the following link:
1484:FreeRTOS/Src/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1485:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1486:FreeRTOS/Src/tasks.c **** 
1487:FreeRTOS/Src/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1488:FreeRTOS/Src/tasks.c **** 		{
1489:FreeRTOS/Src/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1490:FreeRTOS/Src/tasks.c **** 			task that is being queried. */
1491:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1492:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1493:FreeRTOS/Src/tasks.c **** 		}
1494:FreeRTOS/Src/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1495:FreeRTOS/Src/tasks.c **** 
1496:FreeRTOS/Src/tasks.c **** 		return uxReturn;
1497:FreeRTOS/Src/tasks.c **** 	}
1498:FreeRTOS/Src/tasks.c **** 
1499:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1500:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1501:FreeRTOS/Src/tasks.c **** 
1502:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1503:FreeRTOS/Src/tasks.c **** 
1504:FreeRTOS/Src/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1505:FreeRTOS/Src/tasks.c **** 	{
1506:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
1507:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1508:FreeRTOS/Src/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1509:FreeRTOS/Src/tasks.c **** 
1510:FreeRTOS/Src/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1511:FreeRTOS/Src/tasks.c **** 
1512:FreeRTOS/Src/tasks.c **** 		/* Ensure the new priority is valid. */
1513:FreeRTOS/Src/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1514:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 28


1515:FreeRTOS/Src/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1516:FreeRTOS/Src/tasks.c **** 		}
1517:FreeRTOS/Src/tasks.c **** 		else
1518:FreeRTOS/Src/tasks.c **** 		{
1519:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1520:FreeRTOS/Src/tasks.c **** 		}
1521:FreeRTOS/Src/tasks.c **** 
1522:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
1523:FreeRTOS/Src/tasks.c **** 		{
1524:FreeRTOS/Src/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1525:FreeRTOS/Src/tasks.c **** 			task that is being changed. */
1526:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1527:FreeRTOS/Src/tasks.c **** 
1528:FreeRTOS/Src/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1529:FreeRTOS/Src/tasks.c **** 
1530:FreeRTOS/Src/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1531:FreeRTOS/Src/tasks.c **** 			{
1532:FreeRTOS/Src/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1533:FreeRTOS/Src/tasks.c **** 			}
1534:FreeRTOS/Src/tasks.c **** 			#else
1535:FreeRTOS/Src/tasks.c **** 			{
1536:FreeRTOS/Src/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1537:FreeRTOS/Src/tasks.c **** 			}
1538:FreeRTOS/Src/tasks.c **** 			#endif
1539:FreeRTOS/Src/tasks.c **** 
1540:FreeRTOS/Src/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1541:FreeRTOS/Src/tasks.c **** 			{
1542:FreeRTOS/Src/tasks.c **** 				/* The priority change may have readied a task of higher
1543:FreeRTOS/Src/tasks.c **** 				priority than the calling task. */
1544:FreeRTOS/Src/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1545:FreeRTOS/Src/tasks.c **** 				{
1546:FreeRTOS/Src/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1547:FreeRTOS/Src/tasks.c **** 					{
1548:FreeRTOS/Src/tasks.c **** 						/* The priority of a task other than the currently
1549:FreeRTOS/Src/tasks.c **** 						running task is being raised.  Is the priority being
1550:FreeRTOS/Src/tasks.c **** 						raised above that of the running task? */
1551:FreeRTOS/Src/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1552:FreeRTOS/Src/tasks.c **** 						{
1553:FreeRTOS/Src/tasks.c **** 							xYieldRequired = pdTRUE;
1554:FreeRTOS/Src/tasks.c **** 						}
1555:FreeRTOS/Src/tasks.c **** 						else
1556:FreeRTOS/Src/tasks.c **** 						{
1557:FreeRTOS/Src/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1558:FreeRTOS/Src/tasks.c **** 						}
1559:FreeRTOS/Src/tasks.c **** 					}
1560:FreeRTOS/Src/tasks.c **** 					else
1561:FreeRTOS/Src/tasks.c **** 					{
1562:FreeRTOS/Src/tasks.c **** 						/* The priority of the running task is being raised,
1563:FreeRTOS/Src/tasks.c **** 						but the running task must already be the highest
1564:FreeRTOS/Src/tasks.c **** 						priority task able to run so no yield is required. */
1565:FreeRTOS/Src/tasks.c **** 					}
1566:FreeRTOS/Src/tasks.c **** 				}
1567:FreeRTOS/Src/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1568:FreeRTOS/Src/tasks.c **** 				{
1569:FreeRTOS/Src/tasks.c **** 					/* Setting the priority of the running task down means
1570:FreeRTOS/Src/tasks.c **** 					there may now be another task of higher priority that
1571:FreeRTOS/Src/tasks.c **** 					is ready to execute. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 29


1572:FreeRTOS/Src/tasks.c **** 					xYieldRequired = pdTRUE;
1573:FreeRTOS/Src/tasks.c **** 				}
1574:FreeRTOS/Src/tasks.c **** 				else
1575:FreeRTOS/Src/tasks.c **** 				{
1576:FreeRTOS/Src/tasks.c **** 					/* Setting the priority of any other task down does not
1577:FreeRTOS/Src/tasks.c **** 					require a yield as the running task must be above the
1578:FreeRTOS/Src/tasks.c **** 					new priority of the task being modified. */
1579:FreeRTOS/Src/tasks.c **** 				}
1580:FreeRTOS/Src/tasks.c **** 
1581:FreeRTOS/Src/tasks.c **** 				/* Remember the ready list the task might be referenced from
1582:FreeRTOS/Src/tasks.c **** 				before its uxPriority member is changed so the
1583:FreeRTOS/Src/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1584:FreeRTOS/Src/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1585:FreeRTOS/Src/tasks.c **** 
1586:FreeRTOS/Src/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1587:FreeRTOS/Src/tasks.c **** 				{
1588:FreeRTOS/Src/tasks.c **** 					/* Only change the priority being used if the task is not
1589:FreeRTOS/Src/tasks.c **** 					currently using an inherited priority. */
1590:FreeRTOS/Src/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1591:FreeRTOS/Src/tasks.c **** 					{
1592:FreeRTOS/Src/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1593:FreeRTOS/Src/tasks.c **** 					}
1594:FreeRTOS/Src/tasks.c **** 					else
1595:FreeRTOS/Src/tasks.c **** 					{
1596:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1597:FreeRTOS/Src/tasks.c **** 					}
1598:FreeRTOS/Src/tasks.c **** 
1599:FreeRTOS/Src/tasks.c **** 					/* The base priority gets set whatever. */
1600:FreeRTOS/Src/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1601:FreeRTOS/Src/tasks.c **** 				}
1602:FreeRTOS/Src/tasks.c **** 				#else
1603:FreeRTOS/Src/tasks.c **** 				{
1604:FreeRTOS/Src/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1605:FreeRTOS/Src/tasks.c **** 				}
1606:FreeRTOS/Src/tasks.c **** 				#endif
1607:FreeRTOS/Src/tasks.c **** 
1608:FreeRTOS/Src/tasks.c **** 				/* Only reset the event list item value if the value is not
1609:FreeRTOS/Src/tasks.c **** 				being used for anything else. */
1610:FreeRTOS/Src/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1611:FreeRTOS/Src/tasks.c **** 				{
1612:FreeRTOS/Src/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1613:FreeRTOS/Src/tasks.c **** 				}
1614:FreeRTOS/Src/tasks.c **** 				else
1615:FreeRTOS/Src/tasks.c **** 				{
1616:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1617:FreeRTOS/Src/tasks.c **** 				}
1618:FreeRTOS/Src/tasks.c **** 
1619:FreeRTOS/Src/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1620:FreeRTOS/Src/tasks.c **** 				nothing more than change its priority variable. However, if
1621:FreeRTOS/Src/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1622:FreeRTOS/Src/tasks.c **** 				in the list appropriate to its new priority. */
1623:FreeRTOS/Src/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1624:FreeRTOS/Src/tasks.c **** 				{
1625:FreeRTOS/Src/tasks.c **** 					/* The task is currently in its ready list - remove before
1626:FreeRTOS/Src/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1627:FreeRTOS/Src/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1628:FreeRTOS/Src/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 30


1629:FreeRTOS/Src/tasks.c **** 					{
1630:FreeRTOS/Src/tasks.c **** 						/* It is known that the task is in its ready list so
1631:FreeRTOS/Src/tasks.c **** 						there is no need to check again and the port level
1632:FreeRTOS/Src/tasks.c **** 						reset macro can be called directly. */
1633:FreeRTOS/Src/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1634:FreeRTOS/Src/tasks.c **** 					}
1635:FreeRTOS/Src/tasks.c **** 					else
1636:FreeRTOS/Src/tasks.c **** 					{
1637:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1638:FreeRTOS/Src/tasks.c **** 					}
1639:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1640:FreeRTOS/Src/tasks.c **** 				}
1641:FreeRTOS/Src/tasks.c **** 				else
1642:FreeRTOS/Src/tasks.c **** 				{
1643:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1644:FreeRTOS/Src/tasks.c **** 				}
1645:FreeRTOS/Src/tasks.c **** 
1646:FreeRTOS/Src/tasks.c **** 				if( xYieldRequired != pdFALSE )
1647:FreeRTOS/Src/tasks.c **** 				{
1648:FreeRTOS/Src/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1649:FreeRTOS/Src/tasks.c **** 				}
1650:FreeRTOS/Src/tasks.c **** 				else
1651:FreeRTOS/Src/tasks.c **** 				{
1652:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:FreeRTOS/Src/tasks.c **** 				}
1654:FreeRTOS/Src/tasks.c **** 
1655:FreeRTOS/Src/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1656:FreeRTOS/Src/tasks.c **** 				optimised task selection is not being used. */
1657:FreeRTOS/Src/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1658:FreeRTOS/Src/tasks.c **** 			}
1659:FreeRTOS/Src/tasks.c **** 		}
1660:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
1661:FreeRTOS/Src/tasks.c **** 	}
1662:FreeRTOS/Src/tasks.c **** 
1663:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1664:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1665:FreeRTOS/Src/tasks.c **** 
1666:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1667:FreeRTOS/Src/tasks.c **** 
1668:FreeRTOS/Src/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1669:FreeRTOS/Src/tasks.c **** 	{
1670:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
1671:FreeRTOS/Src/tasks.c **** 
1672:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
1673:FreeRTOS/Src/tasks.c **** 		{
1674:FreeRTOS/Src/tasks.c **** 			/* If null is passed in here then it is the running task that is
1675:FreeRTOS/Src/tasks.c **** 			being suspended. */
1676:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1677:FreeRTOS/Src/tasks.c **** 
1678:FreeRTOS/Src/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1679:FreeRTOS/Src/tasks.c **** 
1680:FreeRTOS/Src/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1681:FreeRTOS/Src/tasks.c **** 			suspended list. */
1682:FreeRTOS/Src/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1683:FreeRTOS/Src/tasks.c **** 			{
1684:FreeRTOS/Src/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1685:FreeRTOS/Src/tasks.c **** 			}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 31


1686:FreeRTOS/Src/tasks.c **** 			else
1687:FreeRTOS/Src/tasks.c **** 			{
1688:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1689:FreeRTOS/Src/tasks.c **** 			}
1690:FreeRTOS/Src/tasks.c **** 
1691:FreeRTOS/Src/tasks.c **** 			/* Is the task waiting on an event also? */
1692:FreeRTOS/Src/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1693:FreeRTOS/Src/tasks.c **** 			{
1694:FreeRTOS/Src/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1695:FreeRTOS/Src/tasks.c **** 			}
1696:FreeRTOS/Src/tasks.c **** 			else
1697:FreeRTOS/Src/tasks.c **** 			{
1698:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1699:FreeRTOS/Src/tasks.c **** 			}
1700:FreeRTOS/Src/tasks.c **** 
1701:FreeRTOS/Src/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1702:FreeRTOS/Src/tasks.c **** 
1703:FreeRTOS/Src/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1704:FreeRTOS/Src/tasks.c **** 			{
1705:FreeRTOS/Src/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1706:FreeRTOS/Src/tasks.c **** 				{
1707:FreeRTOS/Src/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1708:FreeRTOS/Src/tasks.c **** 					now suspended, so no notification was received. */
1709:FreeRTOS/Src/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1710:FreeRTOS/Src/tasks.c **** 				}
1711:FreeRTOS/Src/tasks.c **** 			}
1712:FreeRTOS/Src/tasks.c **** 			#endif
1713:FreeRTOS/Src/tasks.c **** 		}
1714:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
1715:FreeRTOS/Src/tasks.c **** 
1716:FreeRTOS/Src/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1717:FreeRTOS/Src/tasks.c **** 		{
1718:FreeRTOS/Src/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1719:FreeRTOS/Src/tasks.c **** 			task that is now in the Suspended state. */
1720:FreeRTOS/Src/tasks.c **** 			taskENTER_CRITICAL();
1721:FreeRTOS/Src/tasks.c **** 			{
1722:FreeRTOS/Src/tasks.c **** 				prvResetNextTaskUnblockTime();
1723:FreeRTOS/Src/tasks.c **** 			}
1724:FreeRTOS/Src/tasks.c **** 			taskEXIT_CRITICAL();
1725:FreeRTOS/Src/tasks.c **** 		}
1726:FreeRTOS/Src/tasks.c **** 		else
1727:FreeRTOS/Src/tasks.c **** 		{
1728:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1729:FreeRTOS/Src/tasks.c **** 		}
1730:FreeRTOS/Src/tasks.c **** 
1731:FreeRTOS/Src/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1732:FreeRTOS/Src/tasks.c **** 		{
1733:FreeRTOS/Src/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1734:FreeRTOS/Src/tasks.c **** 			{
1735:FreeRTOS/Src/tasks.c **** 				/* The current task has just been suspended. */
1736:FreeRTOS/Src/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1737:FreeRTOS/Src/tasks.c **** 				portYIELD_WITHIN_API();
1738:FreeRTOS/Src/tasks.c **** 			}
1739:FreeRTOS/Src/tasks.c **** 			else
1740:FreeRTOS/Src/tasks.c **** 			{
1741:FreeRTOS/Src/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1742:FreeRTOS/Src/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 32


1743:FreeRTOS/Src/tasks.c **** 				must be adjusted to point to a different task. */
1744:FreeRTOS/Src/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1745:FreeRTOS/Src/tasks.c **** 				{
1746:FreeRTOS/Src/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1747:FreeRTOS/Src/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1748:FreeRTOS/Src/tasks.c **** 					be set to point to it no matter what its relative priority
1749:FreeRTOS/Src/tasks.c **** 					is. */
1750:FreeRTOS/Src/tasks.c **** 					pxCurrentTCB = NULL;
1751:FreeRTOS/Src/tasks.c **** 				}
1752:FreeRTOS/Src/tasks.c **** 				else
1753:FreeRTOS/Src/tasks.c **** 				{
1754:FreeRTOS/Src/tasks.c **** 					vTaskSwitchContext();
1755:FreeRTOS/Src/tasks.c **** 				}
1756:FreeRTOS/Src/tasks.c **** 			}
1757:FreeRTOS/Src/tasks.c **** 		}
1758:FreeRTOS/Src/tasks.c **** 		else
1759:FreeRTOS/Src/tasks.c **** 		{
1760:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1761:FreeRTOS/Src/tasks.c **** 		}
1762:FreeRTOS/Src/tasks.c **** 	}
1763:FreeRTOS/Src/tasks.c **** 
1764:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1765:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1766:FreeRTOS/Src/tasks.c **** 
1767:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1768:FreeRTOS/Src/tasks.c **** 
1769:FreeRTOS/Src/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1770:FreeRTOS/Src/tasks.c **** 	{
  27              		.loc 1 1770 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
1771:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1772:FreeRTOS/Src/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1773:FreeRTOS/Src/tasks.c **** 
1774:FreeRTOS/Src/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1775:FreeRTOS/Src/tasks.c **** 		section. */
1776:FreeRTOS/Src/tasks.c **** 
1777:FreeRTOS/Src/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1778:FreeRTOS/Src/tasks.c **** 		configASSERT( xTask );
1779:FreeRTOS/Src/tasks.c **** 
1780:FreeRTOS/Src/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1781:FreeRTOS/Src/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  33              		.loc 1 1781 0
  34 0000 4269     		ldr	r2, [r0, #20]
  35 0002 084B     		ldr	r3, .L6
  36 0004 9A42     		cmp	r2, r3
  37 0006 06D1     		bne	.L3
1782:FreeRTOS/Src/tasks.c **** 		{
1783:FreeRTOS/Src/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1784:FreeRTOS/Src/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  38              		.loc 1 1784 0
  39 0008 836A     		ldr	r3, [r0, #40]
  40 000a 074A     		ldr	r2, .L6+4
  41 000c 9342     		cmp	r3, r2
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 33


  42 000e 04D0     		beq	.L4
1785:FreeRTOS/Src/tasks.c **** 			{
1786:FreeRTOS/Src/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1787:FreeRTOS/Src/tasks.c **** 				state, or because is is blocked with no timeout? */
1788:FreeRTOS/Src/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
  43              		.loc 1 1788 0
  44 0010 2BB1     		cbz	r3, .L5
1771:FreeRTOS/Src/tasks.c **** 	const TCB_t * const pxTCB = xTask;
  45              		.loc 1 1771 0
  46 0012 0020     		movs	r0, #0
  47              	.LVL1:
  48 0014 7047     		bx	lr
  49              	.LVL2:
  50              	.L3:
  51 0016 0020     		movs	r0, #0
  52              	.LVL3:
  53 0018 7047     		bx	lr
  54              	.LVL4:
  55              	.L4:
  56 001a 0020     		movs	r0, #0
  57              	.LVL5:
  58 001c 7047     		bx	lr
  59              	.LVL6:
  60              	.L5:
1789:FreeRTOS/Src/tasks.c **** 				{
1790:FreeRTOS/Src/tasks.c **** 					xReturn = pdTRUE;
  61              		.loc 1 1790 0
  62 001e 0120     		movs	r0, #1
  63              	.LVL7:
1791:FreeRTOS/Src/tasks.c **** 				}
1792:FreeRTOS/Src/tasks.c **** 				else
1793:FreeRTOS/Src/tasks.c **** 				{
1794:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1795:FreeRTOS/Src/tasks.c **** 				}
1796:FreeRTOS/Src/tasks.c **** 			}
1797:FreeRTOS/Src/tasks.c **** 			else
1798:FreeRTOS/Src/tasks.c **** 			{
1799:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1800:FreeRTOS/Src/tasks.c **** 			}
1801:FreeRTOS/Src/tasks.c **** 		}
1802:FreeRTOS/Src/tasks.c **** 		else
1803:FreeRTOS/Src/tasks.c **** 		{
1804:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1805:FreeRTOS/Src/tasks.c **** 		}
1806:FreeRTOS/Src/tasks.c **** 
1807:FreeRTOS/Src/tasks.c **** 		return xReturn;
1808:FreeRTOS/Src/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  64              		.loc 1 1808 0
  65 0020 7047     		bx	lr
  66              	.L7:
  67 0022 00BF     		.align	2
  68              	.L6:
  69 0024 00000000 		.word	.LANCHOR0
  70 0028 00000000 		.word	.LANCHOR1
  71              		.cfi_endproc
  72              	.LFE42:
  74              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 34


  75              		.align	2
  76              		.thumb
  77              		.thumb_func
  79              	prvResetNextTaskUnblockTime:
  80              	.LFB67:
1809:FreeRTOS/Src/tasks.c **** 
1810:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1811:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1812:FreeRTOS/Src/tasks.c **** 
1813:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1814:FreeRTOS/Src/tasks.c **** 
1815:FreeRTOS/Src/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1816:FreeRTOS/Src/tasks.c **** 	{
1817:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1818:FreeRTOS/Src/tasks.c **** 
1819:FreeRTOS/Src/tasks.c **** 		/* It does not make sense to resume the calling task. */
1820:FreeRTOS/Src/tasks.c **** 		configASSERT( xTaskToResume );
1821:FreeRTOS/Src/tasks.c **** 
1822:FreeRTOS/Src/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1823:FreeRTOS/Src/tasks.c **** 		currently executing task. */
1824:FreeRTOS/Src/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1825:FreeRTOS/Src/tasks.c **** 		{
1826:FreeRTOS/Src/tasks.c **** 			taskENTER_CRITICAL();
1827:FreeRTOS/Src/tasks.c **** 			{
1828:FreeRTOS/Src/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1829:FreeRTOS/Src/tasks.c **** 				{
1830:FreeRTOS/Src/tasks.c **** 					traceTASK_RESUME( pxTCB );
1831:FreeRTOS/Src/tasks.c **** 
1832:FreeRTOS/Src/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1833:FreeRTOS/Src/tasks.c **** 					suspended because this is inside a critical section. */
1834:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1835:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1836:FreeRTOS/Src/tasks.c **** 
1837:FreeRTOS/Src/tasks.c **** 					/* A higher priority task may have just been resumed. */
1838:FreeRTOS/Src/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1839:FreeRTOS/Src/tasks.c **** 					{
1840:FreeRTOS/Src/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1841:FreeRTOS/Src/tasks.c **** 						but will leave the lists in the correct state for the
1842:FreeRTOS/Src/tasks.c **** 						next yield. */
1843:FreeRTOS/Src/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1844:FreeRTOS/Src/tasks.c **** 					}
1845:FreeRTOS/Src/tasks.c **** 					else
1846:FreeRTOS/Src/tasks.c **** 					{
1847:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Src/tasks.c **** 					}
1849:FreeRTOS/Src/tasks.c **** 				}
1850:FreeRTOS/Src/tasks.c **** 				else
1851:FreeRTOS/Src/tasks.c **** 				{
1852:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/Src/tasks.c **** 				}
1854:FreeRTOS/Src/tasks.c **** 			}
1855:FreeRTOS/Src/tasks.c **** 			taskEXIT_CRITICAL();
1856:FreeRTOS/Src/tasks.c **** 		}
1857:FreeRTOS/Src/tasks.c **** 		else
1858:FreeRTOS/Src/tasks.c **** 		{
1859:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1860:FreeRTOS/Src/tasks.c **** 		}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 35


1861:FreeRTOS/Src/tasks.c **** 	}
1862:FreeRTOS/Src/tasks.c **** 
1863:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1864:FreeRTOS/Src/tasks.c **** 
1865:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1866:FreeRTOS/Src/tasks.c **** 
1867:FreeRTOS/Src/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1868:FreeRTOS/Src/tasks.c **** 
1869:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1870:FreeRTOS/Src/tasks.c **** 	{
1871:FreeRTOS/Src/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1872:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1873:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1874:FreeRTOS/Src/tasks.c **** 
1875:FreeRTOS/Src/tasks.c **** 		configASSERT( xTaskToResume );
1876:FreeRTOS/Src/tasks.c **** 
1877:FreeRTOS/Src/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1878:FreeRTOS/Src/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1879:FreeRTOS/Src/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1880:FreeRTOS/Src/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1881:FreeRTOS/Src/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1882:FreeRTOS/Src/tasks.c **** 		is defined in FreeRTOSConfig.h then
1883:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1884:FreeRTOS/Src/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1885:FreeRTOS/Src/tasks.c **** 		been assigned a priority above the configured maximum system call
1886:FreeRTOS/Src/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1887:FreeRTOS/Src/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1888:FreeRTOS/Src/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1889:FreeRTOS/Src/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1890:FreeRTOS/Src/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1891:FreeRTOS/Src/tasks.c **** 		provided on the following link:
1892:FreeRTOS/Src/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1893:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1894:FreeRTOS/Src/tasks.c **** 
1895:FreeRTOS/Src/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1896:FreeRTOS/Src/tasks.c **** 		{
1897:FreeRTOS/Src/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1898:FreeRTOS/Src/tasks.c **** 			{
1899:FreeRTOS/Src/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1900:FreeRTOS/Src/tasks.c **** 
1901:FreeRTOS/Src/tasks.c **** 				/* Check the ready lists can be accessed. */
1902:FreeRTOS/Src/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1903:FreeRTOS/Src/tasks.c **** 				{
1904:FreeRTOS/Src/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1905:FreeRTOS/Src/tasks.c **** 					suspended list to the ready list directly. */
1906:FreeRTOS/Src/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1907:FreeRTOS/Src/tasks.c **** 					{
1908:FreeRTOS/Src/tasks.c **** 						xYieldRequired = pdTRUE;
1909:FreeRTOS/Src/tasks.c **** 					}
1910:FreeRTOS/Src/tasks.c **** 					else
1911:FreeRTOS/Src/tasks.c **** 					{
1912:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1913:FreeRTOS/Src/tasks.c **** 					}
1914:FreeRTOS/Src/tasks.c **** 
1915:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1916:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1917:FreeRTOS/Src/tasks.c **** 				}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 36


1918:FreeRTOS/Src/tasks.c **** 				else
1919:FreeRTOS/Src/tasks.c **** 				{
1920:FreeRTOS/Src/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1921:FreeRTOS/Src/tasks.c **** 					is held in the pending ready list until the scheduler is
1922:FreeRTOS/Src/tasks.c **** 					unsuspended. */
1923:FreeRTOS/Src/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1924:FreeRTOS/Src/tasks.c **** 				}
1925:FreeRTOS/Src/tasks.c **** 			}
1926:FreeRTOS/Src/tasks.c **** 			else
1927:FreeRTOS/Src/tasks.c **** 			{
1928:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1929:FreeRTOS/Src/tasks.c **** 			}
1930:FreeRTOS/Src/tasks.c **** 		}
1931:FreeRTOS/Src/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1932:FreeRTOS/Src/tasks.c **** 
1933:FreeRTOS/Src/tasks.c **** 		return xYieldRequired;
1934:FreeRTOS/Src/tasks.c **** 	}
1935:FreeRTOS/Src/tasks.c **** 
1936:FreeRTOS/Src/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1937:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
1938:FreeRTOS/Src/tasks.c **** 
1939:FreeRTOS/Src/tasks.c **** void vTaskStartScheduler( void )
1940:FreeRTOS/Src/tasks.c **** {
1941:FreeRTOS/Src/tasks.c **** BaseType_t xReturn;
1942:FreeRTOS/Src/tasks.c **** 
1943:FreeRTOS/Src/tasks.c **** 	/* Add the idle task at the lowest priority. */
1944:FreeRTOS/Src/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1945:FreeRTOS/Src/tasks.c **** 	{
1946:FreeRTOS/Src/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1947:FreeRTOS/Src/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1948:FreeRTOS/Src/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1949:FreeRTOS/Src/tasks.c **** 
1950:FreeRTOS/Src/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1951:FreeRTOS/Src/tasks.c **** 		address of the RAM then create the idle task. */
1952:FreeRTOS/Src/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1953:FreeRTOS/Src/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1954:FreeRTOS/Src/tasks.c **** 												configIDLE_TASK_NAME,
1955:FreeRTOS/Src/tasks.c **** 												ulIdleTaskStackSize,
1956:FreeRTOS/Src/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1957:FreeRTOS/Src/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1958:FreeRTOS/Src/tasks.c **** 												pxIdleTaskStackBuffer,
1959:FreeRTOS/Src/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1960:FreeRTOS/Src/tasks.c **** 
1961:FreeRTOS/Src/tasks.c **** 		if( xIdleTaskHandle != NULL )
1962:FreeRTOS/Src/tasks.c **** 		{
1963:FreeRTOS/Src/tasks.c **** 			xReturn = pdPASS;
1964:FreeRTOS/Src/tasks.c **** 		}
1965:FreeRTOS/Src/tasks.c **** 		else
1966:FreeRTOS/Src/tasks.c **** 		{
1967:FreeRTOS/Src/tasks.c **** 			xReturn = pdFAIL;
1968:FreeRTOS/Src/tasks.c **** 		}
1969:FreeRTOS/Src/tasks.c **** 	}
1970:FreeRTOS/Src/tasks.c **** 	#else
1971:FreeRTOS/Src/tasks.c **** 	{
1972:FreeRTOS/Src/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1973:FreeRTOS/Src/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1974:FreeRTOS/Src/tasks.c **** 								configIDLE_TASK_NAME,
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 37


1975:FreeRTOS/Src/tasks.c **** 								configMINIMAL_STACK_SIZE,
1976:FreeRTOS/Src/tasks.c **** 								( void * ) NULL,
1977:FreeRTOS/Src/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
1978:FreeRTOS/Src/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1979:FreeRTOS/Src/tasks.c **** 	}
1980:FreeRTOS/Src/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1981:FreeRTOS/Src/tasks.c **** 
1982:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1983:FreeRTOS/Src/tasks.c **** 	{
1984:FreeRTOS/Src/tasks.c **** 		if( xReturn == pdPASS )
1985:FreeRTOS/Src/tasks.c **** 		{
1986:FreeRTOS/Src/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1987:FreeRTOS/Src/tasks.c **** 		}
1988:FreeRTOS/Src/tasks.c **** 		else
1989:FreeRTOS/Src/tasks.c **** 		{
1990:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1991:FreeRTOS/Src/tasks.c **** 		}
1992:FreeRTOS/Src/tasks.c **** 	}
1993:FreeRTOS/Src/tasks.c **** 	#endif /* configUSE_TIMERS */
1994:FreeRTOS/Src/tasks.c **** 
1995:FreeRTOS/Src/tasks.c **** 	if( xReturn == pdPASS )
1996:FreeRTOS/Src/tasks.c **** 	{
1997:FreeRTOS/Src/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1998:FreeRTOS/Src/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1999:FreeRTOS/Src/tasks.c **** 		the only macro called by the function. */
2000:FreeRTOS/Src/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2001:FreeRTOS/Src/tasks.c **** 		{
2002:FreeRTOS/Src/tasks.c **** 			freertos_tasks_c_additions_init();
2003:FreeRTOS/Src/tasks.c **** 		}
2004:FreeRTOS/Src/tasks.c **** 		#endif
2005:FreeRTOS/Src/tasks.c **** 
2006:FreeRTOS/Src/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2007:FreeRTOS/Src/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2008:FreeRTOS/Src/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2009:FreeRTOS/Src/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2010:FreeRTOS/Src/tasks.c **** 		starts to run. */
2011:FreeRTOS/Src/tasks.c **** 		portDISABLE_INTERRUPTS();
2012:FreeRTOS/Src/tasks.c **** 
2013:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2014:FreeRTOS/Src/tasks.c **** 		{
2015:FreeRTOS/Src/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2016:FreeRTOS/Src/tasks.c **** 			structure specific to the task that will run first. */
2017:FreeRTOS/Src/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2018:FreeRTOS/Src/tasks.c **** 		}
2019:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2020:FreeRTOS/Src/tasks.c **** 
2021:FreeRTOS/Src/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2022:FreeRTOS/Src/tasks.c **** 		xSchedulerRunning = pdTRUE;
2023:FreeRTOS/Src/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2024:FreeRTOS/Src/tasks.c **** 
2025:FreeRTOS/Src/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2026:FreeRTOS/Src/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2027:FreeRTOS/Src/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2028:FreeRTOS/Src/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2029:FreeRTOS/Src/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2030:FreeRTOS/Src/tasks.c **** 		FreeRTOSConfig.h file. */
2031:FreeRTOS/Src/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 38


2032:FreeRTOS/Src/tasks.c **** 
2033:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_IN();
2034:FreeRTOS/Src/tasks.c **** 
2035:FreeRTOS/Src/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2036:FreeRTOS/Src/tasks.c **** 		portable interface. */
2037:FreeRTOS/Src/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2038:FreeRTOS/Src/tasks.c **** 		{
2039:FreeRTOS/Src/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2040:FreeRTOS/Src/tasks.c **** 			function will not return. */
2041:FreeRTOS/Src/tasks.c **** 		}
2042:FreeRTOS/Src/tasks.c **** 		else
2043:FreeRTOS/Src/tasks.c **** 		{
2044:FreeRTOS/Src/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2045:FreeRTOS/Src/tasks.c **** 		}
2046:FreeRTOS/Src/tasks.c **** 	}
2047:FreeRTOS/Src/tasks.c **** 	else
2048:FreeRTOS/Src/tasks.c **** 	{
2049:FreeRTOS/Src/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2050:FreeRTOS/Src/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2051:FreeRTOS/Src/tasks.c **** 		or the timer task. */
2052:FreeRTOS/Src/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2053:FreeRTOS/Src/tasks.c **** 	}
2054:FreeRTOS/Src/tasks.c **** 
2055:FreeRTOS/Src/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2056:FreeRTOS/Src/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2057:FreeRTOS/Src/tasks.c **** 	( void ) xIdleTaskHandle;
2058:FreeRTOS/Src/tasks.c **** }
2059:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2060:FreeRTOS/Src/tasks.c **** 
2061:FreeRTOS/Src/tasks.c **** void vTaskEndScheduler( void )
2062:FreeRTOS/Src/tasks.c **** {
2063:FreeRTOS/Src/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2064:FreeRTOS/Src/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2065:FreeRTOS/Src/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2066:FreeRTOS/Src/tasks.c **** 	portDISABLE_INTERRUPTS();
2067:FreeRTOS/Src/tasks.c **** 	xSchedulerRunning = pdFALSE;
2068:FreeRTOS/Src/tasks.c **** 	vPortEndScheduler();
2069:FreeRTOS/Src/tasks.c **** }
2070:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2071:FreeRTOS/Src/tasks.c **** 
2072:FreeRTOS/Src/tasks.c **** void vTaskSuspendAll( void )
2073:FreeRTOS/Src/tasks.c **** {
2074:FreeRTOS/Src/tasks.c **** 	/* A critical section is not required as the variable is of type
2075:FreeRTOS/Src/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2076:FreeRTOS/Src/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2077:FreeRTOS/Src/tasks.c **** 	http://goo.gl/wu4acr */
2078:FreeRTOS/Src/tasks.c **** 	++uxSchedulerSuspended;
2079:FreeRTOS/Src/tasks.c **** }
2080:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2081:FreeRTOS/Src/tasks.c **** 
2082:FreeRTOS/Src/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2083:FreeRTOS/Src/tasks.c **** 
2084:FreeRTOS/Src/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2085:FreeRTOS/Src/tasks.c **** 	{
2086:FreeRTOS/Src/tasks.c **** 	TickType_t xReturn;
2087:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2088:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 39


2089:FreeRTOS/Src/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2090:FreeRTOS/Src/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2091:FreeRTOS/Src/tasks.c **** 		task that are in the Ready state, even though the idle task is
2092:FreeRTOS/Src/tasks.c **** 		running. */
2093:FreeRTOS/Src/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2094:FreeRTOS/Src/tasks.c **** 		{
2095:FreeRTOS/Src/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2096:FreeRTOS/Src/tasks.c **** 			{
2097:FreeRTOS/Src/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2098:FreeRTOS/Src/tasks.c **** 			}
2099:FreeRTOS/Src/tasks.c **** 		}
2100:FreeRTOS/Src/tasks.c **** 		#else
2101:FreeRTOS/Src/tasks.c **** 		{
2102:FreeRTOS/Src/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2103:FreeRTOS/Src/tasks.c **** 
2104:FreeRTOS/Src/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2105:FreeRTOS/Src/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2106:FreeRTOS/Src/tasks.c **** 			significant bit are set then there are tasks that have a priority
2107:FreeRTOS/Src/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2108:FreeRTOS/Src/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2109:FreeRTOS/Src/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2110:FreeRTOS/Src/tasks.c **** 			{
2111:FreeRTOS/Src/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2112:FreeRTOS/Src/tasks.c **** 			}
2113:FreeRTOS/Src/tasks.c **** 		}
2114:FreeRTOS/Src/tasks.c **** 		#endif
2115:FreeRTOS/Src/tasks.c **** 
2116:FreeRTOS/Src/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2117:FreeRTOS/Src/tasks.c **** 		{
2118:FreeRTOS/Src/tasks.c **** 			xReturn = 0;
2119:FreeRTOS/Src/tasks.c **** 		}
2120:FreeRTOS/Src/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2121:FreeRTOS/Src/tasks.c **** 		{
2122:FreeRTOS/Src/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2123:FreeRTOS/Src/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2124:FreeRTOS/Src/tasks.c **** 			processed. */
2125:FreeRTOS/Src/tasks.c **** 			xReturn = 0;
2126:FreeRTOS/Src/tasks.c **** 		}
2127:FreeRTOS/Src/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2128:FreeRTOS/Src/tasks.c **** 		{
2129:FreeRTOS/Src/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2130:FreeRTOS/Src/tasks.c **** 			idle priority.  This path can only be reached if
2131:FreeRTOS/Src/tasks.c **** 			configUSE_PREEMPTION is 0. */
2132:FreeRTOS/Src/tasks.c **** 			xReturn = 0;
2133:FreeRTOS/Src/tasks.c **** 		}
2134:FreeRTOS/Src/tasks.c **** 		else
2135:FreeRTOS/Src/tasks.c **** 		{
2136:FreeRTOS/Src/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2137:FreeRTOS/Src/tasks.c **** 		}
2138:FreeRTOS/Src/tasks.c **** 
2139:FreeRTOS/Src/tasks.c **** 		return xReturn;
2140:FreeRTOS/Src/tasks.c **** 	}
2141:FreeRTOS/Src/tasks.c **** 
2142:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2143:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2144:FreeRTOS/Src/tasks.c **** 
2145:FreeRTOS/Src/tasks.c **** BaseType_t xTaskResumeAll( void )
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 40


2146:FreeRTOS/Src/tasks.c **** {
2147:FreeRTOS/Src/tasks.c **** TCB_t *pxTCB = NULL;
2148:FreeRTOS/Src/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2149:FreeRTOS/Src/tasks.c **** 
2150:FreeRTOS/Src/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2151:FreeRTOS/Src/tasks.c **** 	previous call to vTaskSuspendAll(). */
2152:FreeRTOS/Src/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2153:FreeRTOS/Src/tasks.c **** 
2154:FreeRTOS/Src/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2155:FreeRTOS/Src/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2156:FreeRTOS/Src/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2157:FreeRTOS/Src/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2158:FreeRTOS/Src/tasks.c **** 	tasks from this list into their appropriate ready list. */
2159:FreeRTOS/Src/tasks.c **** 	taskENTER_CRITICAL();
2160:FreeRTOS/Src/tasks.c **** 	{
2161:FreeRTOS/Src/tasks.c **** 		--uxSchedulerSuspended;
2162:FreeRTOS/Src/tasks.c **** 
2163:FreeRTOS/Src/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2164:FreeRTOS/Src/tasks.c **** 		{
2165:FreeRTOS/Src/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2166:FreeRTOS/Src/tasks.c **** 			{
2167:FreeRTOS/Src/tasks.c **** 				/* Move any readied tasks from the pending list into the
2168:FreeRTOS/Src/tasks.c **** 				appropriate ready list. */
2169:FreeRTOS/Src/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2170:FreeRTOS/Src/tasks.c **** 				{
2171:FreeRTOS/Src/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2172:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2173:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2174:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2175:FreeRTOS/Src/tasks.c **** 
2176:FreeRTOS/Src/tasks.c **** 					/* If the moved task has a priority higher than the current
2177:FreeRTOS/Src/tasks.c **** 					task then a yield must be performed. */
2178:FreeRTOS/Src/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2179:FreeRTOS/Src/tasks.c **** 					{
2180:FreeRTOS/Src/tasks.c **** 						xYieldPending = pdTRUE;
2181:FreeRTOS/Src/tasks.c **** 					}
2182:FreeRTOS/Src/tasks.c **** 					else
2183:FreeRTOS/Src/tasks.c **** 					{
2184:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2185:FreeRTOS/Src/tasks.c **** 					}
2186:FreeRTOS/Src/tasks.c **** 				}
2187:FreeRTOS/Src/tasks.c **** 
2188:FreeRTOS/Src/tasks.c **** 				if( pxTCB != NULL )
2189:FreeRTOS/Src/tasks.c **** 				{
2190:FreeRTOS/Src/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2191:FreeRTOS/Src/tasks.c **** 					which may have prevented the next unblock time from being
2192:FreeRTOS/Src/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2193:FreeRTOS/Src/tasks.c **** 					important for low power tickless implementations, where
2194:FreeRTOS/Src/tasks.c **** 					this can prevent an unnecessary exit from low power
2195:FreeRTOS/Src/tasks.c **** 					state. */
2196:FreeRTOS/Src/tasks.c **** 					prvResetNextTaskUnblockTime();
2197:FreeRTOS/Src/tasks.c **** 				}
2198:FreeRTOS/Src/tasks.c **** 
2199:FreeRTOS/Src/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2200:FreeRTOS/Src/tasks.c **** 				they should be processed now.  This ensures the tick count does
2201:FreeRTOS/Src/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2202:FreeRTOS/Src/tasks.c **** 				time. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 41


2203:FreeRTOS/Src/tasks.c **** 				{
2204:FreeRTOS/Src/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2205:FreeRTOS/Src/tasks.c **** 
2206:FreeRTOS/Src/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2207:FreeRTOS/Src/tasks.c **** 					{
2208:FreeRTOS/Src/tasks.c **** 						do
2209:FreeRTOS/Src/tasks.c **** 						{
2210:FreeRTOS/Src/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2211:FreeRTOS/Src/tasks.c **** 							{
2212:FreeRTOS/Src/tasks.c **** 								xYieldPending = pdTRUE;
2213:FreeRTOS/Src/tasks.c **** 							}
2214:FreeRTOS/Src/tasks.c **** 							else
2215:FreeRTOS/Src/tasks.c **** 							{
2216:FreeRTOS/Src/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2217:FreeRTOS/Src/tasks.c **** 							}
2218:FreeRTOS/Src/tasks.c **** 							--uxPendedCounts;
2219:FreeRTOS/Src/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2220:FreeRTOS/Src/tasks.c **** 
2221:FreeRTOS/Src/tasks.c **** 						uxPendedTicks = 0;
2222:FreeRTOS/Src/tasks.c **** 					}
2223:FreeRTOS/Src/tasks.c **** 					else
2224:FreeRTOS/Src/tasks.c **** 					{
2225:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2226:FreeRTOS/Src/tasks.c **** 					}
2227:FreeRTOS/Src/tasks.c **** 				}
2228:FreeRTOS/Src/tasks.c **** 
2229:FreeRTOS/Src/tasks.c **** 				if( xYieldPending != pdFALSE )
2230:FreeRTOS/Src/tasks.c **** 				{
2231:FreeRTOS/Src/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2232:FreeRTOS/Src/tasks.c **** 					{
2233:FreeRTOS/Src/tasks.c **** 						xAlreadyYielded = pdTRUE;
2234:FreeRTOS/Src/tasks.c **** 					}
2235:FreeRTOS/Src/tasks.c **** 					#endif
2236:FreeRTOS/Src/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2237:FreeRTOS/Src/tasks.c **** 				}
2238:FreeRTOS/Src/tasks.c **** 				else
2239:FreeRTOS/Src/tasks.c **** 				{
2240:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2241:FreeRTOS/Src/tasks.c **** 				}
2242:FreeRTOS/Src/tasks.c **** 			}
2243:FreeRTOS/Src/tasks.c **** 		}
2244:FreeRTOS/Src/tasks.c **** 		else
2245:FreeRTOS/Src/tasks.c **** 		{
2246:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2247:FreeRTOS/Src/tasks.c **** 		}
2248:FreeRTOS/Src/tasks.c **** 	}
2249:FreeRTOS/Src/tasks.c **** 	taskEXIT_CRITICAL();
2250:FreeRTOS/Src/tasks.c **** 
2251:FreeRTOS/Src/tasks.c **** 	return xAlreadyYielded;
2252:FreeRTOS/Src/tasks.c **** }
2253:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2254:FreeRTOS/Src/tasks.c **** 
2255:FreeRTOS/Src/tasks.c **** TickType_t xTaskGetTickCount( void )
2256:FreeRTOS/Src/tasks.c **** {
2257:FreeRTOS/Src/tasks.c **** TickType_t xTicks;
2258:FreeRTOS/Src/tasks.c **** 
2259:FreeRTOS/Src/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 42


2260:FreeRTOS/Src/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2261:FreeRTOS/Src/tasks.c **** 	{
2262:FreeRTOS/Src/tasks.c **** 		xTicks = xTickCount;
2263:FreeRTOS/Src/tasks.c **** 	}
2264:FreeRTOS/Src/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2265:FreeRTOS/Src/tasks.c **** 
2266:FreeRTOS/Src/tasks.c **** 	return xTicks;
2267:FreeRTOS/Src/tasks.c **** }
2268:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2269:FreeRTOS/Src/tasks.c **** 
2270:FreeRTOS/Src/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2271:FreeRTOS/Src/tasks.c **** {
2272:FreeRTOS/Src/tasks.c **** TickType_t xReturn;
2273:FreeRTOS/Src/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2274:FreeRTOS/Src/tasks.c **** 
2275:FreeRTOS/Src/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2276:FreeRTOS/Src/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2277:FreeRTOS/Src/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2278:FreeRTOS/Src/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2279:FreeRTOS/Src/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2280:FreeRTOS/Src/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2281:FreeRTOS/Src/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2282:FreeRTOS/Src/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2283:FreeRTOS/Src/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2284:FreeRTOS/Src/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2285:FreeRTOS/Src/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2286:FreeRTOS/Src/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2287:FreeRTOS/Src/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2288:FreeRTOS/Src/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2289:FreeRTOS/Src/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2290:FreeRTOS/Src/tasks.c **** 
2291:FreeRTOS/Src/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2292:FreeRTOS/Src/tasks.c **** 	{
2293:FreeRTOS/Src/tasks.c **** 		xReturn = xTickCount;
2294:FreeRTOS/Src/tasks.c **** 	}
2295:FreeRTOS/Src/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2296:FreeRTOS/Src/tasks.c **** 
2297:FreeRTOS/Src/tasks.c **** 	return xReturn;
2298:FreeRTOS/Src/tasks.c **** }
2299:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2300:FreeRTOS/Src/tasks.c **** 
2301:FreeRTOS/Src/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2302:FreeRTOS/Src/tasks.c **** {
2303:FreeRTOS/Src/tasks.c **** 	/* A critical section is not required because the variables are of type
2304:FreeRTOS/Src/tasks.c **** 	BaseType_t. */
2305:FreeRTOS/Src/tasks.c **** 	return uxCurrentNumberOfTasks;
2306:FreeRTOS/Src/tasks.c **** }
2307:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2308:FreeRTOS/Src/tasks.c **** 
2309:FreeRTOS/Src/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2310:FreeRTOS/Src/tasks.c **** {
2311:FreeRTOS/Src/tasks.c **** TCB_t *pxTCB;
2312:FreeRTOS/Src/tasks.c **** 
2313:FreeRTOS/Src/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2314:FreeRTOS/Src/tasks.c **** 	queried. */
2315:FreeRTOS/Src/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2316:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTCB );
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 43


2317:FreeRTOS/Src/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2318:FreeRTOS/Src/tasks.c **** }
2319:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2320:FreeRTOS/Src/tasks.c **** 
2321:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2322:FreeRTOS/Src/tasks.c **** 
2323:FreeRTOS/Src/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2324:FreeRTOS/Src/tasks.c **** 	{
2325:FreeRTOS/Src/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2326:FreeRTOS/Src/tasks.c **** 	UBaseType_t x;
2327:FreeRTOS/Src/tasks.c **** 	char cNextChar;
2328:FreeRTOS/Src/tasks.c **** 	BaseType_t xBreakLoop;
2329:FreeRTOS/Src/tasks.c **** 
2330:FreeRTOS/Src/tasks.c **** 		/* This function is called with the scheduler suspended. */
2331:FreeRTOS/Src/tasks.c **** 
2332:FreeRTOS/Src/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2333:FreeRTOS/Src/tasks.c **** 		{
2334:FreeRTOS/Src/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2335:FreeRTOS/Src/tasks.c **** 
2336:FreeRTOS/Src/tasks.c **** 			do
2337:FreeRTOS/Src/tasks.c **** 			{
2338:FreeRTOS/Src/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2339:FreeRTOS/Src/tasks.c **** 
2340:FreeRTOS/Src/tasks.c **** 				/* Check each character in the name looking for a match or
2341:FreeRTOS/Src/tasks.c **** 				mismatch. */
2342:FreeRTOS/Src/tasks.c **** 				xBreakLoop = pdFALSE;
2343:FreeRTOS/Src/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2344:FreeRTOS/Src/tasks.c **** 				{
2345:FreeRTOS/Src/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2346:FreeRTOS/Src/tasks.c **** 
2347:FreeRTOS/Src/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2348:FreeRTOS/Src/tasks.c **** 					{
2349:FreeRTOS/Src/tasks.c **** 						/* Characters didn't match. */
2350:FreeRTOS/Src/tasks.c **** 						xBreakLoop = pdTRUE;
2351:FreeRTOS/Src/tasks.c **** 					}
2352:FreeRTOS/Src/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2353:FreeRTOS/Src/tasks.c **** 					{
2354:FreeRTOS/Src/tasks.c **** 						/* Both strings terminated, a match must have been
2355:FreeRTOS/Src/tasks.c **** 						found. */
2356:FreeRTOS/Src/tasks.c **** 						pxReturn = pxNextTCB;
2357:FreeRTOS/Src/tasks.c **** 						xBreakLoop = pdTRUE;
2358:FreeRTOS/Src/tasks.c **** 					}
2359:FreeRTOS/Src/tasks.c **** 					else
2360:FreeRTOS/Src/tasks.c **** 					{
2361:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2362:FreeRTOS/Src/tasks.c **** 					}
2363:FreeRTOS/Src/tasks.c **** 
2364:FreeRTOS/Src/tasks.c **** 					if( xBreakLoop != pdFALSE )
2365:FreeRTOS/Src/tasks.c **** 					{
2366:FreeRTOS/Src/tasks.c **** 						break;
2367:FreeRTOS/Src/tasks.c **** 					}
2368:FreeRTOS/Src/tasks.c **** 				}
2369:FreeRTOS/Src/tasks.c **** 
2370:FreeRTOS/Src/tasks.c **** 				if( pxReturn != NULL )
2371:FreeRTOS/Src/tasks.c **** 				{
2372:FreeRTOS/Src/tasks.c **** 					/* The handle has been found. */
2373:FreeRTOS/Src/tasks.c **** 					break;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 44


2374:FreeRTOS/Src/tasks.c **** 				}
2375:FreeRTOS/Src/tasks.c **** 
2376:FreeRTOS/Src/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2377:FreeRTOS/Src/tasks.c **** 		}
2378:FreeRTOS/Src/tasks.c **** 		else
2379:FreeRTOS/Src/tasks.c **** 		{
2380:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2381:FreeRTOS/Src/tasks.c **** 		}
2382:FreeRTOS/Src/tasks.c **** 
2383:FreeRTOS/Src/tasks.c **** 		return pxReturn;
2384:FreeRTOS/Src/tasks.c **** 	}
2385:FreeRTOS/Src/tasks.c **** 
2386:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2387:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2388:FreeRTOS/Src/tasks.c **** 
2389:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2390:FreeRTOS/Src/tasks.c **** 
2391:FreeRTOS/Src/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2392:FreeRTOS/Src/tasks.c **** 	{
2393:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2394:FreeRTOS/Src/tasks.c **** 	TCB_t* pxTCB;
2395:FreeRTOS/Src/tasks.c **** 
2396:FreeRTOS/Src/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2397:FreeRTOS/Src/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2398:FreeRTOS/Src/tasks.c **** 
2399:FreeRTOS/Src/tasks.c **** 		vTaskSuspendAll();
2400:FreeRTOS/Src/tasks.c **** 		{
2401:FreeRTOS/Src/tasks.c **** 			/* Search the ready lists. */
2402:FreeRTOS/Src/tasks.c **** 			do
2403:FreeRTOS/Src/tasks.c **** 			{
2404:FreeRTOS/Src/tasks.c **** 				uxQueue--;
2405:FreeRTOS/Src/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2406:FreeRTOS/Src/tasks.c **** 
2407:FreeRTOS/Src/tasks.c **** 				if( pxTCB != NULL )
2408:FreeRTOS/Src/tasks.c **** 				{
2409:FreeRTOS/Src/tasks.c **** 					/* Found the handle. */
2410:FreeRTOS/Src/tasks.c **** 					break;
2411:FreeRTOS/Src/tasks.c **** 				}
2412:FreeRTOS/Src/tasks.c **** 
2413:FreeRTOS/Src/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2414:FreeRTOS/Src/tasks.c **** 
2415:FreeRTOS/Src/tasks.c **** 			/* Search the delayed lists. */
2416:FreeRTOS/Src/tasks.c **** 			if( pxTCB == NULL )
2417:FreeRTOS/Src/tasks.c **** 			{
2418:FreeRTOS/Src/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2419:FreeRTOS/Src/tasks.c **** 			}
2420:FreeRTOS/Src/tasks.c **** 
2421:FreeRTOS/Src/tasks.c **** 			if( pxTCB == NULL )
2422:FreeRTOS/Src/tasks.c **** 			{
2423:FreeRTOS/Src/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2424:FreeRTOS/Src/tasks.c **** 			}
2425:FreeRTOS/Src/tasks.c **** 
2426:FreeRTOS/Src/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2427:FreeRTOS/Src/tasks.c **** 			{
2428:FreeRTOS/Src/tasks.c **** 				if( pxTCB == NULL )
2429:FreeRTOS/Src/tasks.c **** 				{
2430:FreeRTOS/Src/tasks.c **** 					/* Search the suspended list. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 45


2431:FreeRTOS/Src/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2432:FreeRTOS/Src/tasks.c **** 				}
2433:FreeRTOS/Src/tasks.c **** 			}
2434:FreeRTOS/Src/tasks.c **** 			#endif
2435:FreeRTOS/Src/tasks.c **** 
2436:FreeRTOS/Src/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2437:FreeRTOS/Src/tasks.c **** 			{
2438:FreeRTOS/Src/tasks.c **** 				if( pxTCB == NULL )
2439:FreeRTOS/Src/tasks.c **** 				{
2440:FreeRTOS/Src/tasks.c **** 					/* Search the deleted list. */
2441:FreeRTOS/Src/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2442:FreeRTOS/Src/tasks.c **** 				}
2443:FreeRTOS/Src/tasks.c **** 			}
2444:FreeRTOS/Src/tasks.c **** 			#endif
2445:FreeRTOS/Src/tasks.c **** 		}
2446:FreeRTOS/Src/tasks.c **** 		( void ) xTaskResumeAll();
2447:FreeRTOS/Src/tasks.c **** 
2448:FreeRTOS/Src/tasks.c **** 		return pxTCB;
2449:FreeRTOS/Src/tasks.c **** 	}
2450:FreeRTOS/Src/tasks.c **** 
2451:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2452:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2453:FreeRTOS/Src/tasks.c **** 
2454:FreeRTOS/Src/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2455:FreeRTOS/Src/tasks.c **** 
2456:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2457:FreeRTOS/Src/tasks.c **** 	{
2458:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2459:FreeRTOS/Src/tasks.c **** 
2460:FreeRTOS/Src/tasks.c **** 		vTaskSuspendAll();
2461:FreeRTOS/Src/tasks.c **** 		{
2462:FreeRTOS/Src/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2463:FreeRTOS/Src/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2464:FreeRTOS/Src/tasks.c **** 			{
2465:FreeRTOS/Src/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2466:FreeRTOS/Src/tasks.c **** 				task in the Ready state. */
2467:FreeRTOS/Src/tasks.c **** 				do
2468:FreeRTOS/Src/tasks.c **** 				{
2469:FreeRTOS/Src/tasks.c **** 					uxQueue--;
2470:FreeRTOS/Src/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2471:FreeRTOS/Src/tasks.c **** 
2472:FreeRTOS/Src/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2473:FreeRTOS/Src/tasks.c **** 
2474:FreeRTOS/Src/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2475:FreeRTOS/Src/tasks.c **** 				task in the Blocked state. */
2476:FreeRTOS/Src/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2477:FreeRTOS/Src/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2478:FreeRTOS/Src/tasks.c **** 
2479:FreeRTOS/Src/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2480:FreeRTOS/Src/tasks.c **** 				{
2481:FreeRTOS/Src/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2482:FreeRTOS/Src/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2483:FreeRTOS/Src/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2484:FreeRTOS/Src/tasks.c **** 				}
2485:FreeRTOS/Src/tasks.c **** 				#endif
2486:FreeRTOS/Src/tasks.c **** 
2487:FreeRTOS/Src/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 46


2488:FreeRTOS/Src/tasks.c **** 				{
2489:FreeRTOS/Src/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2490:FreeRTOS/Src/tasks.c **** 					each task in the Suspended state. */
2491:FreeRTOS/Src/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2492:FreeRTOS/Src/tasks.c **** 				}
2493:FreeRTOS/Src/tasks.c **** 				#endif
2494:FreeRTOS/Src/tasks.c **** 
2495:FreeRTOS/Src/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2496:FreeRTOS/Src/tasks.c **** 				{
2497:FreeRTOS/Src/tasks.c **** 					if( pulTotalRunTime != NULL )
2498:FreeRTOS/Src/tasks.c **** 					{
2499:FreeRTOS/Src/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2500:FreeRTOS/Src/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2501:FreeRTOS/Src/tasks.c **** 						#else
2502:FreeRTOS/Src/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2503:FreeRTOS/Src/tasks.c **** 						#endif
2504:FreeRTOS/Src/tasks.c **** 					}
2505:FreeRTOS/Src/tasks.c **** 				}
2506:FreeRTOS/Src/tasks.c **** 				#else
2507:FreeRTOS/Src/tasks.c **** 				{
2508:FreeRTOS/Src/tasks.c **** 					if( pulTotalRunTime != NULL )
2509:FreeRTOS/Src/tasks.c **** 					{
2510:FreeRTOS/Src/tasks.c **** 						*pulTotalRunTime = 0;
2511:FreeRTOS/Src/tasks.c **** 					}
2512:FreeRTOS/Src/tasks.c **** 				}
2513:FreeRTOS/Src/tasks.c **** 				#endif
2514:FreeRTOS/Src/tasks.c **** 			}
2515:FreeRTOS/Src/tasks.c **** 			else
2516:FreeRTOS/Src/tasks.c **** 			{
2517:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2518:FreeRTOS/Src/tasks.c **** 			}
2519:FreeRTOS/Src/tasks.c **** 		}
2520:FreeRTOS/Src/tasks.c **** 		( void ) xTaskResumeAll();
2521:FreeRTOS/Src/tasks.c **** 
2522:FreeRTOS/Src/tasks.c **** 		return uxTask;
2523:FreeRTOS/Src/tasks.c **** 	}
2524:FreeRTOS/Src/tasks.c **** 
2525:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2527:FreeRTOS/Src/tasks.c **** 
2528:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2529:FreeRTOS/Src/tasks.c **** 
2530:FreeRTOS/Src/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2531:FreeRTOS/Src/tasks.c **** 	{
2532:FreeRTOS/Src/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2533:FreeRTOS/Src/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2534:FreeRTOS/Src/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2535:FreeRTOS/Src/tasks.c **** 		return xIdleTaskHandle;
2536:FreeRTOS/Src/tasks.c **** 	}
2537:FreeRTOS/Src/tasks.c **** 
2538:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2539:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2540:FreeRTOS/Src/tasks.c **** 
2541:FreeRTOS/Src/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2542:FreeRTOS/Src/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2543:FreeRTOS/Src/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2544:FreeRTOS/Src/tasks.c **** 1. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 47


2545:FreeRTOS/Src/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2546:FreeRTOS/Src/tasks.c **** 
2547:FreeRTOS/Src/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2548:FreeRTOS/Src/tasks.c **** 	{
2549:FreeRTOS/Src/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2550:FreeRTOS/Src/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2551:FreeRTOS/Src/tasks.c **** 		each stepped tick. */
2552:FreeRTOS/Src/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2553:FreeRTOS/Src/tasks.c **** 		xTickCount += xTicksToJump;
2554:FreeRTOS/Src/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2555:FreeRTOS/Src/tasks.c **** 	}
2556:FreeRTOS/Src/tasks.c **** 
2557:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2558:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2559:FreeRTOS/Src/tasks.c **** 
2560:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2561:FreeRTOS/Src/tasks.c **** 
2562:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2563:FreeRTOS/Src/tasks.c **** 	{
2564:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB = xTask;
2565:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
2566:FreeRTOS/Src/tasks.c **** 
2567:FreeRTOS/Src/tasks.c **** 		configASSERT( pxTCB );
2568:FreeRTOS/Src/tasks.c **** 
2569:FreeRTOS/Src/tasks.c **** 		vTaskSuspendAll();
2570:FreeRTOS/Src/tasks.c **** 		{
2571:FreeRTOS/Src/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2572:FreeRTOS/Src/tasks.c **** 			it is actually in the Blocked state. */
2573:FreeRTOS/Src/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2574:FreeRTOS/Src/tasks.c **** 			{
2575:FreeRTOS/Src/tasks.c **** 				xReturn = pdPASS;
2576:FreeRTOS/Src/tasks.c **** 
2577:FreeRTOS/Src/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2578:FreeRTOS/Src/tasks.c **** 				interrupt won't touch the xStateListItem because the
2579:FreeRTOS/Src/tasks.c **** 				scheduler is suspended. */
2580:FreeRTOS/Src/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2581:FreeRTOS/Src/tasks.c **** 
2582:FreeRTOS/Src/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2583:FreeRTOS/Src/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2584:FreeRTOS/Src/tasks.c **** 				even though the scheduler is suspended, so a critical section
2585:FreeRTOS/Src/tasks.c **** 				is used. */
2586:FreeRTOS/Src/tasks.c **** 				taskENTER_CRITICAL();
2587:FreeRTOS/Src/tasks.c **** 				{
2588:FreeRTOS/Src/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2589:FreeRTOS/Src/tasks.c **** 					{
2590:FreeRTOS/Src/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2591:FreeRTOS/Src/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2592:FreeRTOS/Src/tasks.c **** 					}
2593:FreeRTOS/Src/tasks.c **** 					else
2594:FreeRTOS/Src/tasks.c **** 					{
2595:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2596:FreeRTOS/Src/tasks.c **** 					}
2597:FreeRTOS/Src/tasks.c **** 				}
2598:FreeRTOS/Src/tasks.c **** 				taskEXIT_CRITICAL();
2599:FreeRTOS/Src/tasks.c **** 
2600:FreeRTOS/Src/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2601:FreeRTOS/Src/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 48


2602:FreeRTOS/Src/tasks.c **** 
2603:FreeRTOS/Src/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2604:FreeRTOS/Src/tasks.c **** 				switch if preemption is turned off. */
2605:FreeRTOS/Src/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2606:FreeRTOS/Src/tasks.c **** 				{
2607:FreeRTOS/Src/tasks.c **** 					/* Preemption is on, but a context switch should only be
2608:FreeRTOS/Src/tasks.c **** 					performed if the unblocked task has a priority that is
2609:FreeRTOS/Src/tasks.c **** 					equal to or higher than the currently executing task. */
2610:FreeRTOS/Src/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2611:FreeRTOS/Src/tasks.c **** 					{
2612:FreeRTOS/Src/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2613:FreeRTOS/Src/tasks.c **** 						is unsuspended. */
2614:FreeRTOS/Src/tasks.c **** 						xYieldPending = pdTRUE;
2615:FreeRTOS/Src/tasks.c **** 					}
2616:FreeRTOS/Src/tasks.c **** 					else
2617:FreeRTOS/Src/tasks.c **** 					{
2618:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2619:FreeRTOS/Src/tasks.c **** 					}
2620:FreeRTOS/Src/tasks.c **** 				}
2621:FreeRTOS/Src/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2622:FreeRTOS/Src/tasks.c **** 			}
2623:FreeRTOS/Src/tasks.c **** 			else
2624:FreeRTOS/Src/tasks.c **** 			{
2625:FreeRTOS/Src/tasks.c **** 				xReturn = pdFAIL;
2626:FreeRTOS/Src/tasks.c **** 			}
2627:FreeRTOS/Src/tasks.c **** 		}
2628:FreeRTOS/Src/tasks.c **** 		( void ) xTaskResumeAll();
2629:FreeRTOS/Src/tasks.c **** 
2630:FreeRTOS/Src/tasks.c **** 		return xReturn;
2631:FreeRTOS/Src/tasks.c **** 	}
2632:FreeRTOS/Src/tasks.c **** 
2633:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2634:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
2635:FreeRTOS/Src/tasks.c **** 
2636:FreeRTOS/Src/tasks.c **** BaseType_t xTaskIncrementTick( void )
2637:FreeRTOS/Src/tasks.c **** {
2638:FreeRTOS/Src/tasks.c **** TCB_t * pxTCB;
2639:FreeRTOS/Src/tasks.c **** TickType_t xItemValue;
2640:FreeRTOS/Src/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2641:FreeRTOS/Src/tasks.c **** 
2642:FreeRTOS/Src/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2643:FreeRTOS/Src/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2644:FreeRTOS/Src/tasks.c **** 	tasks to be unblocked. */
2645:FreeRTOS/Src/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2646:FreeRTOS/Src/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2647:FreeRTOS/Src/tasks.c **** 	{
2648:FreeRTOS/Src/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2649:FreeRTOS/Src/tasks.c **** 		block. */
2650:FreeRTOS/Src/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2651:FreeRTOS/Src/tasks.c **** 
2652:FreeRTOS/Src/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2653:FreeRTOS/Src/tasks.c **** 		delayed lists if it wraps to 0. */
2654:FreeRTOS/Src/tasks.c **** 		xTickCount = xConstTickCount;
2655:FreeRTOS/Src/tasks.c **** 
2656:FreeRTOS/Src/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2657:FreeRTOS/Src/tasks.c **** 		{
2658:FreeRTOS/Src/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 49


2659:FreeRTOS/Src/tasks.c **** 		}
2660:FreeRTOS/Src/tasks.c **** 		else
2661:FreeRTOS/Src/tasks.c **** 		{
2662:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2663:FreeRTOS/Src/tasks.c **** 		}
2664:FreeRTOS/Src/tasks.c **** 
2665:FreeRTOS/Src/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2666:FreeRTOS/Src/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2667:FreeRTOS/Src/tasks.c **** 		has been found whose block time has not expired there is no need to
2668:FreeRTOS/Src/tasks.c **** 		look any further down the list. */
2669:FreeRTOS/Src/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2670:FreeRTOS/Src/tasks.c **** 		{
2671:FreeRTOS/Src/tasks.c **** 			for( ;; )
2672:FreeRTOS/Src/tasks.c **** 			{
2673:FreeRTOS/Src/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2674:FreeRTOS/Src/tasks.c **** 				{
2675:FreeRTOS/Src/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2676:FreeRTOS/Src/tasks.c **** 					to the maximum possible value so it is extremely
2677:FreeRTOS/Src/tasks.c **** 					unlikely that the
2678:FreeRTOS/Src/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2679:FreeRTOS/Src/tasks.c **** 					next time through. */
2680:FreeRTOS/Src/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2681:FreeRTOS/Src/tasks.c **** 					break;
2682:FreeRTOS/Src/tasks.c **** 				}
2683:FreeRTOS/Src/tasks.c **** 				else
2684:FreeRTOS/Src/tasks.c **** 				{
2685:FreeRTOS/Src/tasks.c **** 					/* The delayed list is not empty, get the value of the
2686:FreeRTOS/Src/tasks.c **** 					item at the head of the delayed list.  This is the time
2687:FreeRTOS/Src/tasks.c **** 					at which the task at the head of the delayed list must
2688:FreeRTOS/Src/tasks.c **** 					be removed from the Blocked state. */
2689:FreeRTOS/Src/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2690:FreeRTOS/Src/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2691:FreeRTOS/Src/tasks.c **** 
2692:FreeRTOS/Src/tasks.c **** 					if( xConstTickCount < xItemValue )
2693:FreeRTOS/Src/tasks.c **** 					{
2694:FreeRTOS/Src/tasks.c **** 						/* It is not time to unblock this item yet, but the
2695:FreeRTOS/Src/tasks.c **** 						item value is the time at which the task at the head
2696:FreeRTOS/Src/tasks.c **** 						of the blocked list must be removed from the Blocked
2697:FreeRTOS/Src/tasks.c **** 						state -	so record the item value in
2698:FreeRTOS/Src/tasks.c **** 						xNextTaskUnblockTime. */
2699:FreeRTOS/Src/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2700:FreeRTOS/Src/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2701:FreeRTOS/Src/tasks.c **** 					}
2702:FreeRTOS/Src/tasks.c **** 					else
2703:FreeRTOS/Src/tasks.c **** 					{
2704:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2705:FreeRTOS/Src/tasks.c **** 					}
2706:FreeRTOS/Src/tasks.c **** 
2707:FreeRTOS/Src/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2708:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2709:FreeRTOS/Src/tasks.c **** 
2710:FreeRTOS/Src/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2711:FreeRTOS/Src/tasks.c **** 					it from the event list. */
2712:FreeRTOS/Src/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2713:FreeRTOS/Src/tasks.c **** 					{
2714:FreeRTOS/Src/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2715:FreeRTOS/Src/tasks.c **** 					}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 50


2716:FreeRTOS/Src/tasks.c **** 					else
2717:FreeRTOS/Src/tasks.c **** 					{
2718:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2719:FreeRTOS/Src/tasks.c **** 					}
2720:FreeRTOS/Src/tasks.c **** 
2721:FreeRTOS/Src/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2722:FreeRTOS/Src/tasks.c **** 					list. */
2723:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2724:FreeRTOS/Src/tasks.c **** 
2725:FreeRTOS/Src/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2726:FreeRTOS/Src/tasks.c **** 					context switch if preemption is turned off. */
2727:FreeRTOS/Src/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2728:FreeRTOS/Src/tasks.c **** 					{
2729:FreeRTOS/Src/tasks.c **** 						/* Preemption is on, but a context switch should
2730:FreeRTOS/Src/tasks.c **** 						only be performed if the unblocked task has a
2731:FreeRTOS/Src/tasks.c **** 						priority that is equal to or higher than the
2732:FreeRTOS/Src/tasks.c **** 						currently executing task. */
2733:FreeRTOS/Src/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2734:FreeRTOS/Src/tasks.c **** 						{
2735:FreeRTOS/Src/tasks.c **** 							xSwitchRequired = pdTRUE;
2736:FreeRTOS/Src/tasks.c **** 						}
2737:FreeRTOS/Src/tasks.c **** 						else
2738:FreeRTOS/Src/tasks.c **** 						{
2739:FreeRTOS/Src/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2740:FreeRTOS/Src/tasks.c **** 						}
2741:FreeRTOS/Src/tasks.c **** 					}
2742:FreeRTOS/Src/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2743:FreeRTOS/Src/tasks.c **** 				}
2744:FreeRTOS/Src/tasks.c **** 			}
2745:FreeRTOS/Src/tasks.c **** 		}
2746:FreeRTOS/Src/tasks.c **** 
2747:FreeRTOS/Src/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2748:FreeRTOS/Src/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2749:FreeRTOS/Src/tasks.c **** 		writer has not explicitly turned time slicing off. */
2750:FreeRTOS/Src/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2751:FreeRTOS/Src/tasks.c **** 		{
2752:FreeRTOS/Src/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2753:FreeRTOS/Src/tasks.c **** 			{
2754:FreeRTOS/Src/tasks.c **** 				xSwitchRequired = pdTRUE;
2755:FreeRTOS/Src/tasks.c **** 			}
2756:FreeRTOS/Src/tasks.c **** 			else
2757:FreeRTOS/Src/tasks.c **** 			{
2758:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2759:FreeRTOS/Src/tasks.c **** 			}
2760:FreeRTOS/Src/tasks.c **** 		}
2761:FreeRTOS/Src/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2762:FreeRTOS/Src/tasks.c **** 
2763:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2764:FreeRTOS/Src/tasks.c **** 		{
2765:FreeRTOS/Src/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2766:FreeRTOS/Src/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2767:FreeRTOS/Src/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2768:FreeRTOS/Src/tasks.c **** 			{
2769:FreeRTOS/Src/tasks.c **** 				vApplicationTickHook();
2770:FreeRTOS/Src/tasks.c **** 			}
2771:FreeRTOS/Src/tasks.c **** 			else
2772:FreeRTOS/Src/tasks.c **** 			{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 51


2773:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2774:FreeRTOS/Src/tasks.c **** 			}
2775:FreeRTOS/Src/tasks.c **** 		}
2776:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2777:FreeRTOS/Src/tasks.c **** 	}
2778:FreeRTOS/Src/tasks.c **** 	else
2779:FreeRTOS/Src/tasks.c **** 	{
2780:FreeRTOS/Src/tasks.c **** 		++uxPendedTicks;
2781:FreeRTOS/Src/tasks.c **** 
2782:FreeRTOS/Src/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2783:FreeRTOS/Src/tasks.c **** 		scheduler is locked. */
2784:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2785:FreeRTOS/Src/tasks.c **** 		{
2786:FreeRTOS/Src/tasks.c **** 			vApplicationTickHook();
2787:FreeRTOS/Src/tasks.c **** 		}
2788:FreeRTOS/Src/tasks.c **** 		#endif
2789:FreeRTOS/Src/tasks.c **** 	}
2790:FreeRTOS/Src/tasks.c **** 
2791:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2792:FreeRTOS/Src/tasks.c **** 	{
2793:FreeRTOS/Src/tasks.c **** 		if( xYieldPending != pdFALSE )
2794:FreeRTOS/Src/tasks.c **** 		{
2795:FreeRTOS/Src/tasks.c **** 			xSwitchRequired = pdTRUE;
2796:FreeRTOS/Src/tasks.c **** 		}
2797:FreeRTOS/Src/tasks.c **** 		else
2798:FreeRTOS/Src/tasks.c **** 		{
2799:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2800:FreeRTOS/Src/tasks.c **** 		}
2801:FreeRTOS/Src/tasks.c **** 	}
2802:FreeRTOS/Src/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2803:FreeRTOS/Src/tasks.c **** 
2804:FreeRTOS/Src/tasks.c **** 	return xSwitchRequired;
2805:FreeRTOS/Src/tasks.c **** }
2806:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2807:FreeRTOS/Src/tasks.c **** 
2808:FreeRTOS/Src/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2809:FreeRTOS/Src/tasks.c **** 
2810:FreeRTOS/Src/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2811:FreeRTOS/Src/tasks.c **** 	{
2812:FreeRTOS/Src/tasks.c **** 	TCB_t *xTCB;
2813:FreeRTOS/Src/tasks.c **** 
2814:FreeRTOS/Src/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2815:FreeRTOS/Src/tasks.c **** 		getting set. */
2816:FreeRTOS/Src/tasks.c **** 		if( xTask == NULL )
2817:FreeRTOS/Src/tasks.c **** 		{
2818:FreeRTOS/Src/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2819:FreeRTOS/Src/tasks.c **** 		}
2820:FreeRTOS/Src/tasks.c **** 		else
2821:FreeRTOS/Src/tasks.c **** 		{
2822:FreeRTOS/Src/tasks.c **** 			xTCB = xTask;
2823:FreeRTOS/Src/tasks.c **** 		}
2824:FreeRTOS/Src/tasks.c **** 
2825:FreeRTOS/Src/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2826:FreeRTOS/Src/tasks.c **** 		the value can be accessed from an interrupt. */
2827:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
2828:FreeRTOS/Src/tasks.c **** 		{
2829:FreeRTOS/Src/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 52


2830:FreeRTOS/Src/tasks.c **** 		}
2831:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
2832:FreeRTOS/Src/tasks.c **** 	}
2833:FreeRTOS/Src/tasks.c **** 
2834:FreeRTOS/Src/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2835:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2836:FreeRTOS/Src/tasks.c **** 
2837:FreeRTOS/Src/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2838:FreeRTOS/Src/tasks.c **** 
2839:FreeRTOS/Src/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2840:FreeRTOS/Src/tasks.c **** 	{
2841:FreeRTOS/Src/tasks.c **** 	TCB_t *xTCB;
2842:FreeRTOS/Src/tasks.c **** 	TaskHookFunction_t xReturn;
2843:FreeRTOS/Src/tasks.c **** 
2844:FreeRTOS/Src/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2845:FreeRTOS/Src/tasks.c **** 		if( xTask == NULL )
2846:FreeRTOS/Src/tasks.c **** 		{
2847:FreeRTOS/Src/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2848:FreeRTOS/Src/tasks.c **** 		}
2849:FreeRTOS/Src/tasks.c **** 		else
2850:FreeRTOS/Src/tasks.c **** 		{
2851:FreeRTOS/Src/tasks.c **** 			xTCB = xTask;
2852:FreeRTOS/Src/tasks.c **** 		}
2853:FreeRTOS/Src/tasks.c **** 
2854:FreeRTOS/Src/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2855:FreeRTOS/Src/tasks.c **** 		the value can be accessed from an interrupt. */
2856:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
2857:FreeRTOS/Src/tasks.c **** 		{
2858:FreeRTOS/Src/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2859:FreeRTOS/Src/tasks.c **** 		}
2860:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
2861:FreeRTOS/Src/tasks.c **** 
2862:FreeRTOS/Src/tasks.c **** 		return xReturn;
2863:FreeRTOS/Src/tasks.c **** 	}
2864:FreeRTOS/Src/tasks.c **** 
2865:FreeRTOS/Src/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2866:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2867:FreeRTOS/Src/tasks.c **** 
2868:FreeRTOS/Src/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2869:FreeRTOS/Src/tasks.c **** 
2870:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2871:FreeRTOS/Src/tasks.c **** 	{
2872:FreeRTOS/Src/tasks.c **** 	TCB_t *xTCB;
2873:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
2874:FreeRTOS/Src/tasks.c **** 
2875:FreeRTOS/Src/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2876:FreeRTOS/Src/tasks.c **** 		if( xTask == NULL )
2877:FreeRTOS/Src/tasks.c **** 		{
2878:FreeRTOS/Src/tasks.c **** 			xTCB = pxCurrentTCB;
2879:FreeRTOS/Src/tasks.c **** 		}
2880:FreeRTOS/Src/tasks.c **** 		else
2881:FreeRTOS/Src/tasks.c **** 		{
2882:FreeRTOS/Src/tasks.c **** 			xTCB = xTask;
2883:FreeRTOS/Src/tasks.c **** 		}
2884:FreeRTOS/Src/tasks.c **** 
2885:FreeRTOS/Src/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2886:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 53


2887:FreeRTOS/Src/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2888:FreeRTOS/Src/tasks.c **** 		}
2889:FreeRTOS/Src/tasks.c **** 		else
2890:FreeRTOS/Src/tasks.c **** 		{
2891:FreeRTOS/Src/tasks.c **** 			xReturn = pdFAIL;
2892:FreeRTOS/Src/tasks.c **** 		}
2893:FreeRTOS/Src/tasks.c **** 
2894:FreeRTOS/Src/tasks.c **** 		return xReturn;
2895:FreeRTOS/Src/tasks.c **** 	}
2896:FreeRTOS/Src/tasks.c **** 
2897:FreeRTOS/Src/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2898:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2899:FreeRTOS/Src/tasks.c **** 
2900:FreeRTOS/Src/tasks.c **** void vTaskSwitchContext( void )
2901:FreeRTOS/Src/tasks.c **** {
2902:FreeRTOS/Src/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2903:FreeRTOS/Src/tasks.c **** 	{
2904:FreeRTOS/Src/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2905:FreeRTOS/Src/tasks.c **** 		switch. */
2906:FreeRTOS/Src/tasks.c **** 		xYieldPending = pdTRUE;
2907:FreeRTOS/Src/tasks.c **** 	}
2908:FreeRTOS/Src/tasks.c **** 	else
2909:FreeRTOS/Src/tasks.c **** 	{
2910:FreeRTOS/Src/tasks.c **** 		xYieldPending = pdFALSE;
2911:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_OUT();
2912:FreeRTOS/Src/tasks.c **** 
2913:FreeRTOS/Src/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2914:FreeRTOS/Src/tasks.c **** 		{
2915:FreeRTOS/Src/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2916:FreeRTOS/Src/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2917:FreeRTOS/Src/tasks.c **** 				#else
2918:FreeRTOS/Src/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2919:FreeRTOS/Src/tasks.c **** 				#endif
2920:FreeRTOS/Src/tasks.c **** 
2921:FreeRTOS/Src/tasks.c **** 				/* Add the amount of time the task has been running to the
2922:FreeRTOS/Src/tasks.c **** 				accumulated time so far.  The time the task started running was
2923:FreeRTOS/Src/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2924:FreeRTOS/Src/tasks.c **** 				protection here so count values are only valid until the timer
2925:FreeRTOS/Src/tasks.c **** 				overflows.  The guard against negative values is to protect
2926:FreeRTOS/Src/tasks.c **** 				against suspect run time stat counter implementations - which
2927:FreeRTOS/Src/tasks.c **** 				are provided by the application, not the kernel. */
2928:FreeRTOS/Src/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2929:FreeRTOS/Src/tasks.c **** 				{
2930:FreeRTOS/Src/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2931:FreeRTOS/Src/tasks.c **** 				}
2932:FreeRTOS/Src/tasks.c **** 				else
2933:FreeRTOS/Src/tasks.c **** 				{
2934:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2935:FreeRTOS/Src/tasks.c **** 				}
2936:FreeRTOS/Src/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2937:FreeRTOS/Src/tasks.c **** 		}
2938:FreeRTOS/Src/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2939:FreeRTOS/Src/tasks.c **** 
2940:FreeRTOS/Src/tasks.c **** 		/* Check for stack overflow, if configured. */
2941:FreeRTOS/Src/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2942:FreeRTOS/Src/tasks.c **** 
2943:FreeRTOS/Src/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 54


2944:FreeRTOS/Src/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2945:FreeRTOS/Src/tasks.c **** 		{
2946:FreeRTOS/Src/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2947:FreeRTOS/Src/tasks.c **** 		}
2948:FreeRTOS/Src/tasks.c **** 		#endif
2949:FreeRTOS/Src/tasks.c **** 
2950:FreeRTOS/Src/tasks.c **** 		/* Select a new task to run using either the generic C or port
2951:FreeRTOS/Src/tasks.c **** 		optimised asm code. */
2952:FreeRTOS/Src/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
2953:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_IN();
2954:FreeRTOS/Src/tasks.c **** 
2955:FreeRTOS/Src/tasks.c **** 		/* After the new task is switched in, update the global errno. */
2956:FreeRTOS/Src/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2957:FreeRTOS/Src/tasks.c **** 		{
2958:FreeRTOS/Src/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2959:FreeRTOS/Src/tasks.c **** 		}
2960:FreeRTOS/Src/tasks.c **** 		#endif
2961:FreeRTOS/Src/tasks.c **** 
2962:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2963:FreeRTOS/Src/tasks.c **** 		{
2964:FreeRTOS/Src/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2965:FreeRTOS/Src/tasks.c **** 			structure specific to this task. */
2966:FreeRTOS/Src/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2967:FreeRTOS/Src/tasks.c **** 		}
2968:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2969:FreeRTOS/Src/tasks.c **** 	}
2970:FreeRTOS/Src/tasks.c **** }
2971:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2972:FreeRTOS/Src/tasks.c **** 
2973:FreeRTOS/Src/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2974:FreeRTOS/Src/tasks.c **** {
2975:FreeRTOS/Src/tasks.c **** 	configASSERT( pxEventList );
2976:FreeRTOS/Src/tasks.c **** 
2977:FreeRTOS/Src/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2978:FreeRTOS/Src/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2979:FreeRTOS/Src/tasks.c **** 
2980:FreeRTOS/Src/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2981:FreeRTOS/Src/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2982:FreeRTOS/Src/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2983:FreeRTOS/Src/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2984:FreeRTOS/Src/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2985:FreeRTOS/Src/tasks.c **** 
2986:FreeRTOS/Src/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2987:FreeRTOS/Src/tasks.c **** }
2988:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
2989:FreeRTOS/Src/tasks.c **** 
2990:FreeRTOS/Src/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2991:FreeRTOS/Src/tasks.c **** {
2992:FreeRTOS/Src/tasks.c **** 	configASSERT( pxEventList );
2993:FreeRTOS/Src/tasks.c **** 
2994:FreeRTOS/Src/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2995:FreeRTOS/Src/tasks.c **** 	the event groups implementation. */
2996:FreeRTOS/Src/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2997:FreeRTOS/Src/tasks.c **** 
2998:FreeRTOS/Src/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2999:FreeRTOS/Src/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3000:FreeRTOS/Src/tasks.c **** 	task that is not in the Blocked state. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 55


3001:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3002:FreeRTOS/Src/tasks.c **** 
3003:FreeRTOS/Src/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3004:FreeRTOS/Src/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3005:FreeRTOS/Src/tasks.c **** 	event group implementation - and interrupts don't access event groups
3006:FreeRTOS/Src/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3007:FreeRTOS/Src/tasks.c **** 	the task level). */
3008:FreeRTOS/Src/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3009:FreeRTOS/Src/tasks.c **** 
3010:FreeRTOS/Src/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3011:FreeRTOS/Src/tasks.c **** }
3012:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3013:FreeRTOS/Src/tasks.c **** 
3014:FreeRTOS/Src/tasks.c **** #if( configUSE_TIMERS == 1 )
3015:FreeRTOS/Src/tasks.c **** 
3016:FreeRTOS/Src/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3017:FreeRTOS/Src/tasks.c **** 	{
3018:FreeRTOS/Src/tasks.c **** 		configASSERT( pxEventList );
3019:FreeRTOS/Src/tasks.c **** 
3020:FreeRTOS/Src/tasks.c **** 		/* This function should not be called by application code hence the
3021:FreeRTOS/Src/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3022:FreeRTOS/Src/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3023:FreeRTOS/Src/tasks.c **** 		it should be called with the scheduler suspended. */
3024:FreeRTOS/Src/tasks.c **** 
3025:FreeRTOS/Src/tasks.c **** 
3026:FreeRTOS/Src/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3027:FreeRTOS/Src/tasks.c **** 		In this case it is assume that this is the only task that is going to
3028:FreeRTOS/Src/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3029:FreeRTOS/Src/tasks.c **** 		can be used in place of vListInsert. */
3030:FreeRTOS/Src/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3031:FreeRTOS/Src/tasks.c **** 
3032:FreeRTOS/Src/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3033:FreeRTOS/Src/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3034:FreeRTOS/Src/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3035:FreeRTOS/Src/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3036:FreeRTOS/Src/tasks.c **** 		{
3037:FreeRTOS/Src/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3038:FreeRTOS/Src/tasks.c **** 		}
3039:FreeRTOS/Src/tasks.c **** 
3040:FreeRTOS/Src/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3041:FreeRTOS/Src/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3042:FreeRTOS/Src/tasks.c **** 	}
3043:FreeRTOS/Src/tasks.c **** 
3044:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TIMERS */
3045:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3046:FreeRTOS/Src/tasks.c **** 
3047:FreeRTOS/Src/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3048:FreeRTOS/Src/tasks.c **** {
3049:FreeRTOS/Src/tasks.c **** TCB_t *pxUnblockedTCB;
3050:FreeRTOS/Src/tasks.c **** BaseType_t xReturn;
3051:FreeRTOS/Src/tasks.c **** 
3052:FreeRTOS/Src/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3053:FreeRTOS/Src/tasks.c **** 	called from a critical section within an ISR. */
3054:FreeRTOS/Src/tasks.c **** 
3055:FreeRTOS/Src/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3056:FreeRTOS/Src/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3057:FreeRTOS/Src/tasks.c **** 	the delayed list, and add it to the ready list.
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 56


3058:FreeRTOS/Src/tasks.c **** 
3059:FreeRTOS/Src/tasks.c **** 	If an event is for a queue that is locked then this function will never
3060:FreeRTOS/Src/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3061:FreeRTOS/Src/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3062:FreeRTOS/Src/tasks.c **** 
3063:FreeRTOS/Src/tasks.c **** 	This function assumes that a check has already been made to ensure that
3064:FreeRTOS/Src/tasks.c **** 	pxEventList is not empty. */
3065:FreeRTOS/Src/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3066:FreeRTOS/Src/tasks.c **** 	configASSERT( pxUnblockedTCB );
3067:FreeRTOS/Src/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3068:FreeRTOS/Src/tasks.c **** 
3069:FreeRTOS/Src/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3070:FreeRTOS/Src/tasks.c **** 	{
3071:FreeRTOS/Src/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3072:FreeRTOS/Src/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3073:FreeRTOS/Src/tasks.c **** 	}
3074:FreeRTOS/Src/tasks.c **** 	else
3075:FreeRTOS/Src/tasks.c **** 	{
3076:FreeRTOS/Src/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3077:FreeRTOS/Src/tasks.c **** 		pending until the scheduler is resumed. */
3078:FreeRTOS/Src/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3079:FreeRTOS/Src/tasks.c **** 	}
3080:FreeRTOS/Src/tasks.c **** 
3081:FreeRTOS/Src/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3082:FreeRTOS/Src/tasks.c **** 	{
3083:FreeRTOS/Src/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3084:FreeRTOS/Src/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3085:FreeRTOS/Src/tasks.c **** 		it should force a context switch now. */
3086:FreeRTOS/Src/tasks.c **** 		xReturn = pdTRUE;
3087:FreeRTOS/Src/tasks.c **** 
3088:FreeRTOS/Src/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3089:FreeRTOS/Src/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3090:FreeRTOS/Src/tasks.c **** 		xYieldPending = pdTRUE;
3091:FreeRTOS/Src/tasks.c **** 	}
3092:FreeRTOS/Src/tasks.c **** 	else
3093:FreeRTOS/Src/tasks.c **** 	{
3094:FreeRTOS/Src/tasks.c **** 		xReturn = pdFALSE;
3095:FreeRTOS/Src/tasks.c **** 	}
3096:FreeRTOS/Src/tasks.c **** 
3097:FreeRTOS/Src/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3098:FreeRTOS/Src/tasks.c **** 	{
3099:FreeRTOS/Src/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3100:FreeRTOS/Src/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3101:FreeRTOS/Src/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3102:FreeRTOS/Src/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3103:FreeRTOS/Src/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3104:FreeRTOS/Src/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3105:FreeRTOS/Src/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3106:FreeRTOS/Src/tasks.c **** 		ensure it is updated at the earliest possible time. */
3107:FreeRTOS/Src/tasks.c **** 		prvResetNextTaskUnblockTime();
3108:FreeRTOS/Src/tasks.c **** 	}
3109:FreeRTOS/Src/tasks.c **** 	#endif
3110:FreeRTOS/Src/tasks.c **** 
3111:FreeRTOS/Src/tasks.c **** 	return xReturn;
3112:FreeRTOS/Src/tasks.c **** }
3113:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3114:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 57


3115:FreeRTOS/Src/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3116:FreeRTOS/Src/tasks.c **** {
3117:FreeRTOS/Src/tasks.c **** TCB_t *pxUnblockedTCB;
3118:FreeRTOS/Src/tasks.c **** 
3119:FreeRTOS/Src/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3120:FreeRTOS/Src/tasks.c **** 	the event flags implementation. */
3121:FreeRTOS/Src/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3122:FreeRTOS/Src/tasks.c **** 
3123:FreeRTOS/Src/tasks.c **** 	/* Store the new item value in the event list. */
3124:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3125:FreeRTOS/Src/tasks.c **** 
3126:FreeRTOS/Src/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3127:FreeRTOS/Src/tasks.c **** 	event flags. */
3128:FreeRTOS/Src/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3129:FreeRTOS/Src/tasks.c **** 	configASSERT( pxUnblockedTCB );
3130:FreeRTOS/Src/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3131:FreeRTOS/Src/tasks.c **** 
3132:FreeRTOS/Src/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3133:FreeRTOS/Src/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3134:FreeRTOS/Src/tasks.c **** 	lists. */
3135:FreeRTOS/Src/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3136:FreeRTOS/Src/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3137:FreeRTOS/Src/tasks.c **** 
3138:FreeRTOS/Src/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3139:FreeRTOS/Src/tasks.c **** 	{
3140:FreeRTOS/Src/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3141:FreeRTOS/Src/tasks.c **** 		a context switch is required.  This function is called with the
3142:FreeRTOS/Src/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3143:FreeRTOS/Src/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3144:FreeRTOS/Src/tasks.c **** 		xYieldPending = pdTRUE;
3145:FreeRTOS/Src/tasks.c **** 	}
3146:FreeRTOS/Src/tasks.c **** }
3147:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3148:FreeRTOS/Src/tasks.c **** 
3149:FreeRTOS/Src/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3150:FreeRTOS/Src/tasks.c **** {
3151:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTimeOut );
3152:FreeRTOS/Src/tasks.c **** 	taskENTER_CRITICAL();
3153:FreeRTOS/Src/tasks.c **** 	{
3154:FreeRTOS/Src/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3155:FreeRTOS/Src/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3156:FreeRTOS/Src/tasks.c **** 	}
3157:FreeRTOS/Src/tasks.c **** 	taskEXIT_CRITICAL();
3158:FreeRTOS/Src/tasks.c **** }
3159:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3160:FreeRTOS/Src/tasks.c **** 
3161:FreeRTOS/Src/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3162:FreeRTOS/Src/tasks.c **** {
3163:FreeRTOS/Src/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3164:FreeRTOS/Src/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3165:FreeRTOS/Src/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3166:FreeRTOS/Src/tasks.c **** }
3167:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3168:FreeRTOS/Src/tasks.c **** 
3169:FreeRTOS/Src/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3170:FreeRTOS/Src/tasks.c **** {
3171:FreeRTOS/Src/tasks.c **** BaseType_t xReturn;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 58


3172:FreeRTOS/Src/tasks.c **** 
3173:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTimeOut );
3174:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTicksToWait );
3175:FreeRTOS/Src/tasks.c **** 
3176:FreeRTOS/Src/tasks.c **** 	taskENTER_CRITICAL();
3177:FreeRTOS/Src/tasks.c **** 	{
3178:FreeRTOS/Src/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3179:FreeRTOS/Src/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3180:FreeRTOS/Src/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3181:FreeRTOS/Src/tasks.c **** 
3182:FreeRTOS/Src/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3183:FreeRTOS/Src/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3184:FreeRTOS/Src/tasks.c **** 			{
3185:FreeRTOS/Src/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3186:FreeRTOS/Src/tasks.c **** 				but has the same result. */
3187:FreeRTOS/Src/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3188:FreeRTOS/Src/tasks.c **** 				xReturn = pdTRUE;
3189:FreeRTOS/Src/tasks.c **** 			}
3190:FreeRTOS/Src/tasks.c **** 			else
3191:FreeRTOS/Src/tasks.c **** 		#endif
3192:FreeRTOS/Src/tasks.c **** 
3193:FreeRTOS/Src/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3194:FreeRTOS/Src/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3195:FreeRTOS/Src/tasks.c **** 			{
3196:FreeRTOS/Src/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3197:FreeRTOS/Src/tasks.c **** 				specified is the maximum block time then the task should block
3198:FreeRTOS/Src/tasks.c **** 				indefinitely, and therefore never time out. */
3199:FreeRTOS/Src/tasks.c **** 				xReturn = pdFALSE;
3200:FreeRTOS/Src/tasks.c **** 			}
3201:FreeRTOS/Src/tasks.c **** 			else
3202:FreeRTOS/Src/tasks.c **** 		#endif
3203:FreeRTOS/Src/tasks.c **** 
3204:FreeRTOS/Src/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3205:FreeRTOS/Src/tasks.c **** 		{
3206:FreeRTOS/Src/tasks.c **** 			/* The tick count is greater than the time at which
3207:FreeRTOS/Src/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3208:FreeRTOS/Src/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3209:FreeRTOS/Src/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3210:FreeRTOS/Src/tasks.c **** 			was called. */
3211:FreeRTOS/Src/tasks.c **** 			xReturn = pdTRUE;
3212:FreeRTOS/Src/tasks.c **** 		}
3213:FreeRTOS/Src/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3214:FreeRTOS/Src/tasks.c **** 		{
3215:FreeRTOS/Src/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3216:FreeRTOS/Src/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3217:FreeRTOS/Src/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3218:FreeRTOS/Src/tasks.c **** 			xReturn = pdFALSE;
3219:FreeRTOS/Src/tasks.c **** 		}
3220:FreeRTOS/Src/tasks.c **** 		else
3221:FreeRTOS/Src/tasks.c **** 		{
3222:FreeRTOS/Src/tasks.c **** 			*pxTicksToWait = 0;
3223:FreeRTOS/Src/tasks.c **** 			xReturn = pdTRUE;
3224:FreeRTOS/Src/tasks.c **** 		}
3225:FreeRTOS/Src/tasks.c **** 	}
3226:FreeRTOS/Src/tasks.c **** 	taskEXIT_CRITICAL();
3227:FreeRTOS/Src/tasks.c **** 
3228:FreeRTOS/Src/tasks.c **** 	return xReturn;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 59


3229:FreeRTOS/Src/tasks.c **** }
3230:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3231:FreeRTOS/Src/tasks.c **** 
3232:FreeRTOS/Src/tasks.c **** void vTaskMissedYield( void )
3233:FreeRTOS/Src/tasks.c **** {
3234:FreeRTOS/Src/tasks.c **** 	xYieldPending = pdTRUE;
3235:FreeRTOS/Src/tasks.c **** }
3236:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3237:FreeRTOS/Src/tasks.c **** 
3238:FreeRTOS/Src/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3239:FreeRTOS/Src/tasks.c **** 
3240:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3241:FreeRTOS/Src/tasks.c **** 	{
3242:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxReturn;
3243:FreeRTOS/Src/tasks.c **** 	TCB_t const *pxTCB;
3244:FreeRTOS/Src/tasks.c **** 
3245:FreeRTOS/Src/tasks.c **** 		if( xTask != NULL )
3246:FreeRTOS/Src/tasks.c **** 		{
3247:FreeRTOS/Src/tasks.c **** 			pxTCB = xTask;
3248:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3249:FreeRTOS/Src/tasks.c **** 		}
3250:FreeRTOS/Src/tasks.c **** 		else
3251:FreeRTOS/Src/tasks.c **** 		{
3252:FreeRTOS/Src/tasks.c **** 			uxReturn = 0U;
3253:FreeRTOS/Src/tasks.c **** 		}
3254:FreeRTOS/Src/tasks.c **** 
3255:FreeRTOS/Src/tasks.c **** 		return uxReturn;
3256:FreeRTOS/Src/tasks.c **** 	}
3257:FreeRTOS/Src/tasks.c **** 
3258:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3259:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3260:FreeRTOS/Src/tasks.c **** 
3261:FreeRTOS/Src/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3262:FreeRTOS/Src/tasks.c **** 
3263:FreeRTOS/Src/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3264:FreeRTOS/Src/tasks.c **** 	{
3265:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
3266:FreeRTOS/Src/tasks.c **** 
3267:FreeRTOS/Src/tasks.c **** 		if( xTask != NULL )
3268:FreeRTOS/Src/tasks.c **** 		{
3269:FreeRTOS/Src/tasks.c **** 			pxTCB = xTask;
3270:FreeRTOS/Src/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3271:FreeRTOS/Src/tasks.c **** 		}
3272:FreeRTOS/Src/tasks.c **** 	}
3273:FreeRTOS/Src/tasks.c **** 
3274:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3275:FreeRTOS/Src/tasks.c **** 
3276:FreeRTOS/Src/tasks.c **** /*
3277:FreeRTOS/Src/tasks.c ****  * -----------------------------------------------------------
3278:FreeRTOS/Src/tasks.c ****  * The Idle task.
3279:FreeRTOS/Src/tasks.c ****  * ----------------------------------------------------------
3280:FreeRTOS/Src/tasks.c ****  *
3281:FreeRTOS/Src/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3282:FreeRTOS/Src/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3283:FreeRTOS/Src/tasks.c ****  *
3284:FreeRTOS/Src/tasks.c ****  * void prvIdleTask( void *pvParameters );
3285:FreeRTOS/Src/tasks.c ****  *
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 60


3286:FreeRTOS/Src/tasks.c ****  */
3287:FreeRTOS/Src/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3288:FreeRTOS/Src/tasks.c **** {
3289:FreeRTOS/Src/tasks.c **** 	/* Stop warnings. */
3290:FreeRTOS/Src/tasks.c **** 	( void ) pvParameters;
3291:FreeRTOS/Src/tasks.c **** 
3292:FreeRTOS/Src/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3293:FreeRTOS/Src/tasks.c **** 	SCHEDULER IS STARTED. **/
3294:FreeRTOS/Src/tasks.c **** 
3295:FreeRTOS/Src/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3296:FreeRTOS/Src/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3297:FreeRTOS/Src/tasks.c **** 	any. */
3298:FreeRTOS/Src/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3299:FreeRTOS/Src/tasks.c **** 
3300:FreeRTOS/Src/tasks.c **** 	for( ;; )
3301:FreeRTOS/Src/tasks.c **** 	{
3302:FreeRTOS/Src/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3303:FreeRTOS/Src/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3304:FreeRTOS/Src/tasks.c **** 		prvCheckTasksWaitingTermination();
3305:FreeRTOS/Src/tasks.c **** 
3306:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3307:FreeRTOS/Src/tasks.c **** 		{
3308:FreeRTOS/Src/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3309:FreeRTOS/Src/tasks.c **** 			see if any other task has become available.  If we are using
3310:FreeRTOS/Src/tasks.c **** 			preemption we don't need to do this as any task becoming available
3311:FreeRTOS/Src/tasks.c **** 			will automatically get the processor anyway. */
3312:FreeRTOS/Src/tasks.c **** 			taskYIELD();
3313:FreeRTOS/Src/tasks.c **** 		}
3314:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3315:FreeRTOS/Src/tasks.c **** 
3316:FreeRTOS/Src/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3317:FreeRTOS/Src/tasks.c **** 		{
3318:FreeRTOS/Src/tasks.c **** 			/* When using preemption tasks of equal priority will be
3319:FreeRTOS/Src/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3320:FreeRTOS/Src/tasks.c **** 			to run then the idle task should yield before the end of the
3321:FreeRTOS/Src/tasks.c **** 			timeslice.
3322:FreeRTOS/Src/tasks.c **** 
3323:FreeRTOS/Src/tasks.c **** 			A critical region is not required here as we are just reading from
3324:FreeRTOS/Src/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3325:FreeRTOS/Src/tasks.c **** 			the ready list at the idle priority contains more than one task
3326:FreeRTOS/Src/tasks.c **** 			then a task other than the idle task is ready to execute. */
3327:FreeRTOS/Src/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3328:FreeRTOS/Src/tasks.c **** 			{
3329:FreeRTOS/Src/tasks.c **** 				taskYIELD();
3330:FreeRTOS/Src/tasks.c **** 			}
3331:FreeRTOS/Src/tasks.c **** 			else
3332:FreeRTOS/Src/tasks.c **** 			{
3333:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3334:FreeRTOS/Src/tasks.c **** 			}
3335:FreeRTOS/Src/tasks.c **** 		}
3336:FreeRTOS/Src/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3337:FreeRTOS/Src/tasks.c **** 
3338:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3339:FreeRTOS/Src/tasks.c **** 		{
3340:FreeRTOS/Src/tasks.c **** 			extern void vApplicationIdleHook( void );
3341:FreeRTOS/Src/tasks.c **** 
3342:FreeRTOS/Src/tasks.c **** 			/* Call the user defined function from within the idle task.  This
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 61


3343:FreeRTOS/Src/tasks.c **** 			allows the application designer to add background functionality
3344:FreeRTOS/Src/tasks.c **** 			without the overhead of a separate task.
3345:FreeRTOS/Src/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3346:FreeRTOS/Src/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3347:FreeRTOS/Src/tasks.c **** 			vApplicationIdleHook();
3348:FreeRTOS/Src/tasks.c **** 		}
3349:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3350:FreeRTOS/Src/tasks.c **** 
3351:FreeRTOS/Src/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3352:FreeRTOS/Src/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3353:FreeRTOS/Src/tasks.c **** 		user defined low power mode	implementations require
3354:FreeRTOS/Src/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3355:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3356:FreeRTOS/Src/tasks.c **** 		{
3357:FreeRTOS/Src/tasks.c **** 		TickType_t xExpectedIdleTime;
3358:FreeRTOS/Src/tasks.c **** 
3359:FreeRTOS/Src/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3360:FreeRTOS/Src/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3361:FreeRTOS/Src/tasks.c **** 			test of the expected idle time is performed without the
3362:FreeRTOS/Src/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3363:FreeRTOS/Src/tasks.c **** 			valid. */
3364:FreeRTOS/Src/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3365:FreeRTOS/Src/tasks.c **** 
3366:FreeRTOS/Src/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3367:FreeRTOS/Src/tasks.c **** 			{
3368:FreeRTOS/Src/tasks.c **** 				vTaskSuspendAll();
3369:FreeRTOS/Src/tasks.c **** 				{
3370:FreeRTOS/Src/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3371:FreeRTOS/Src/tasks.c **** 					time can be sampled again, and this time its value can
3372:FreeRTOS/Src/tasks.c **** 					be used. */
3373:FreeRTOS/Src/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3374:FreeRTOS/Src/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3375:FreeRTOS/Src/tasks.c **** 
3376:FreeRTOS/Src/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3377:FreeRTOS/Src/tasks.c **** 					if the application does not want
3378:FreeRTOS/Src/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3379:FreeRTOS/Src/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3380:FreeRTOS/Src/tasks.c **** 
3381:FreeRTOS/Src/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3382:FreeRTOS/Src/tasks.c **** 					{
3383:FreeRTOS/Src/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3384:FreeRTOS/Src/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3385:FreeRTOS/Src/tasks.c **** 						traceLOW_POWER_IDLE_END();
3386:FreeRTOS/Src/tasks.c **** 					}
3387:FreeRTOS/Src/tasks.c **** 					else
3388:FreeRTOS/Src/tasks.c **** 					{
3389:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3390:FreeRTOS/Src/tasks.c **** 					}
3391:FreeRTOS/Src/tasks.c **** 				}
3392:FreeRTOS/Src/tasks.c **** 				( void ) xTaskResumeAll();
3393:FreeRTOS/Src/tasks.c **** 			}
3394:FreeRTOS/Src/tasks.c **** 			else
3395:FreeRTOS/Src/tasks.c **** 			{
3396:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3397:FreeRTOS/Src/tasks.c **** 			}
3398:FreeRTOS/Src/tasks.c **** 		}
3399:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 62


3400:FreeRTOS/Src/tasks.c **** 	}
3401:FreeRTOS/Src/tasks.c **** }
3402:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3403:FreeRTOS/Src/tasks.c **** 
3404:FreeRTOS/Src/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3405:FreeRTOS/Src/tasks.c **** 
3406:FreeRTOS/Src/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3407:FreeRTOS/Src/tasks.c **** 	{
3408:FreeRTOS/Src/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3409:FreeRTOS/Src/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3410:FreeRTOS/Src/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3411:FreeRTOS/Src/tasks.c **** 
3412:FreeRTOS/Src/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3413:FreeRTOS/Src/tasks.c **** 		{
3414:FreeRTOS/Src/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3415:FreeRTOS/Src/tasks.c **** 			eReturn = eAbortSleep;
3416:FreeRTOS/Src/tasks.c **** 		}
3417:FreeRTOS/Src/tasks.c **** 		else if( xYieldPending != pdFALSE )
3418:FreeRTOS/Src/tasks.c **** 		{
3419:FreeRTOS/Src/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3420:FreeRTOS/Src/tasks.c **** 			eReturn = eAbortSleep;
3421:FreeRTOS/Src/tasks.c **** 		}
3422:FreeRTOS/Src/tasks.c **** 		else
3423:FreeRTOS/Src/tasks.c **** 		{
3424:FreeRTOS/Src/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3425:FreeRTOS/Src/tasks.c **** 			have an infinite block time rather than actually being suspended)
3426:FreeRTOS/Src/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3427:FreeRTOS/Src/tasks.c **** 			interrupts. */
3428:FreeRTOS/Src/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3429:FreeRTOS/Src/tasks.c **** 			{
3430:FreeRTOS/Src/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3431:FreeRTOS/Src/tasks.c **** 			}
3432:FreeRTOS/Src/tasks.c **** 			else
3433:FreeRTOS/Src/tasks.c **** 			{
3434:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3435:FreeRTOS/Src/tasks.c **** 			}
3436:FreeRTOS/Src/tasks.c **** 		}
3437:FreeRTOS/Src/tasks.c **** 
3438:FreeRTOS/Src/tasks.c **** 		return eReturn;
3439:FreeRTOS/Src/tasks.c **** 	}
3440:FreeRTOS/Src/tasks.c **** 
3441:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3442:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3443:FreeRTOS/Src/tasks.c **** 
3444:FreeRTOS/Src/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3445:FreeRTOS/Src/tasks.c **** 
3446:FreeRTOS/Src/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3447:FreeRTOS/Src/tasks.c **** 	{
3448:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
3449:FreeRTOS/Src/tasks.c **** 
3450:FreeRTOS/Src/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3451:FreeRTOS/Src/tasks.c **** 		{
3452:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3453:FreeRTOS/Src/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3454:FreeRTOS/Src/tasks.c **** 		}
3455:FreeRTOS/Src/tasks.c **** 	}
3456:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 63


3457:FreeRTOS/Src/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3458:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3459:FreeRTOS/Src/tasks.c **** 
3460:FreeRTOS/Src/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3461:FreeRTOS/Src/tasks.c **** 
3462:FreeRTOS/Src/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3463:FreeRTOS/Src/tasks.c **** 	{
3464:FreeRTOS/Src/tasks.c **** 	void *pvReturn = NULL;
3465:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
3466:FreeRTOS/Src/tasks.c **** 
3467:FreeRTOS/Src/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3468:FreeRTOS/Src/tasks.c **** 		{
3469:FreeRTOS/Src/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3470:FreeRTOS/Src/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3471:FreeRTOS/Src/tasks.c **** 		}
3472:FreeRTOS/Src/tasks.c **** 		else
3473:FreeRTOS/Src/tasks.c **** 		{
3474:FreeRTOS/Src/tasks.c **** 			pvReturn = NULL;
3475:FreeRTOS/Src/tasks.c **** 		}
3476:FreeRTOS/Src/tasks.c **** 
3477:FreeRTOS/Src/tasks.c **** 		return pvReturn;
3478:FreeRTOS/Src/tasks.c **** 	}
3479:FreeRTOS/Src/tasks.c **** 
3480:FreeRTOS/Src/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3481:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3482:FreeRTOS/Src/tasks.c **** 
3483:FreeRTOS/Src/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3484:FreeRTOS/Src/tasks.c **** 
3485:FreeRTOS/Src/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3486:FreeRTOS/Src/tasks.c **** 	{
3487:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
3488:FreeRTOS/Src/tasks.c **** 
3489:FreeRTOS/Src/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3490:FreeRTOS/Src/tasks.c **** 		the calling task. */
3491:FreeRTOS/Src/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3492:FreeRTOS/Src/tasks.c **** 
3493:FreeRTOS/Src/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3494:FreeRTOS/Src/tasks.c **** 	}
3495:FreeRTOS/Src/tasks.c **** 
3496:FreeRTOS/Src/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3497:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3498:FreeRTOS/Src/tasks.c **** 
3499:FreeRTOS/Src/tasks.c **** static void prvInitialiseTaskLists( void )
3500:FreeRTOS/Src/tasks.c **** {
3501:FreeRTOS/Src/tasks.c **** UBaseType_t uxPriority;
3502:FreeRTOS/Src/tasks.c **** 
3503:FreeRTOS/Src/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3504:FreeRTOS/Src/tasks.c **** 	{
3505:FreeRTOS/Src/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3506:FreeRTOS/Src/tasks.c **** 	}
3507:FreeRTOS/Src/tasks.c **** 
3508:FreeRTOS/Src/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3509:FreeRTOS/Src/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3510:FreeRTOS/Src/tasks.c **** 	vListInitialise( &xPendingReadyList );
3511:FreeRTOS/Src/tasks.c **** 
3512:FreeRTOS/Src/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3513:FreeRTOS/Src/tasks.c **** 	{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 64


3514:FreeRTOS/Src/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3515:FreeRTOS/Src/tasks.c **** 	}
3516:FreeRTOS/Src/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3517:FreeRTOS/Src/tasks.c **** 
3518:FreeRTOS/Src/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3519:FreeRTOS/Src/tasks.c **** 	{
3520:FreeRTOS/Src/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3521:FreeRTOS/Src/tasks.c **** 	}
3522:FreeRTOS/Src/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3523:FreeRTOS/Src/tasks.c **** 
3524:FreeRTOS/Src/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3525:FreeRTOS/Src/tasks.c **** 	using list2. */
3526:FreeRTOS/Src/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3527:FreeRTOS/Src/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3528:FreeRTOS/Src/tasks.c **** }
3529:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3530:FreeRTOS/Src/tasks.c **** 
3531:FreeRTOS/Src/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3532:FreeRTOS/Src/tasks.c **** {
3533:FreeRTOS/Src/tasks.c **** 
3534:FreeRTOS/Src/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3535:FreeRTOS/Src/tasks.c **** 
3536:FreeRTOS/Src/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3537:FreeRTOS/Src/tasks.c **** 	{
3538:FreeRTOS/Src/tasks.c **** 		TCB_t *pxTCB;
3539:FreeRTOS/Src/tasks.c **** 
3540:FreeRTOS/Src/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3541:FreeRTOS/Src/tasks.c **** 		being called too often in the idle task. */
3542:FreeRTOS/Src/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3543:FreeRTOS/Src/tasks.c **** 		{
3544:FreeRTOS/Src/tasks.c **** 			taskENTER_CRITICAL();
3545:FreeRTOS/Src/tasks.c **** 			{
3546:FreeRTOS/Src/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3547:FreeRTOS/Src/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3548:FreeRTOS/Src/tasks.c **** 				--uxCurrentNumberOfTasks;
3549:FreeRTOS/Src/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3550:FreeRTOS/Src/tasks.c **** 			}
3551:FreeRTOS/Src/tasks.c **** 			taskEXIT_CRITICAL();
3552:FreeRTOS/Src/tasks.c **** 
3553:FreeRTOS/Src/tasks.c **** 			prvDeleteTCB( pxTCB );
3554:FreeRTOS/Src/tasks.c **** 		}
3555:FreeRTOS/Src/tasks.c **** 	}
3556:FreeRTOS/Src/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3557:FreeRTOS/Src/tasks.c **** }
3558:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3559:FreeRTOS/Src/tasks.c **** 
3560:FreeRTOS/Src/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3561:FreeRTOS/Src/tasks.c **** 
3562:FreeRTOS/Src/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3563:FreeRTOS/Src/tasks.c **** 	{
3564:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
3565:FreeRTOS/Src/tasks.c **** 
3566:FreeRTOS/Src/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3567:FreeRTOS/Src/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3568:FreeRTOS/Src/tasks.c **** 
3569:FreeRTOS/Src/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3570:FreeRTOS/Src/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 65


3571:FreeRTOS/Src/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3572:FreeRTOS/Src/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3573:FreeRTOS/Src/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3574:FreeRTOS/Src/tasks.c **** 
3575:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3576:FreeRTOS/Src/tasks.c **** 		{
3577:FreeRTOS/Src/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3578:FreeRTOS/Src/tasks.c **** 		}
3579:FreeRTOS/Src/tasks.c **** 		#else
3580:FreeRTOS/Src/tasks.c **** 		{
3581:FreeRTOS/Src/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3582:FreeRTOS/Src/tasks.c **** 		}
3583:FreeRTOS/Src/tasks.c **** 		#endif
3584:FreeRTOS/Src/tasks.c **** 
3585:FreeRTOS/Src/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3586:FreeRTOS/Src/tasks.c **** 		{
3587:FreeRTOS/Src/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3588:FreeRTOS/Src/tasks.c **** 		}
3589:FreeRTOS/Src/tasks.c **** 		#else
3590:FreeRTOS/Src/tasks.c **** 		{
3591:FreeRTOS/Src/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3592:FreeRTOS/Src/tasks.c **** 		}
3593:FreeRTOS/Src/tasks.c **** 		#endif
3594:FreeRTOS/Src/tasks.c **** 
3595:FreeRTOS/Src/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3596:FreeRTOS/Src/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3597:FreeRTOS/Src/tasks.c **** 		state is just set to whatever is passed in. */
3598:FreeRTOS/Src/tasks.c **** 		if( eState != eInvalid )
3599:FreeRTOS/Src/tasks.c **** 		{
3600:FreeRTOS/Src/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3601:FreeRTOS/Src/tasks.c **** 			{
3602:FreeRTOS/Src/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3603:FreeRTOS/Src/tasks.c **** 			}
3604:FreeRTOS/Src/tasks.c **** 			else
3605:FreeRTOS/Src/tasks.c **** 			{
3606:FreeRTOS/Src/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3607:FreeRTOS/Src/tasks.c **** 
3608:FreeRTOS/Src/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3609:FreeRTOS/Src/tasks.c **** 				{
3610:FreeRTOS/Src/tasks.c **** 					/* If the task is in the suspended list then there is a
3611:FreeRTOS/Src/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3612:FreeRTOS/Src/tasks.c **** 					it should be reported as being in the Blocked state. */
3613:FreeRTOS/Src/tasks.c **** 					if( eState == eSuspended )
3614:FreeRTOS/Src/tasks.c **** 					{
3615:FreeRTOS/Src/tasks.c **** 						vTaskSuspendAll();
3616:FreeRTOS/Src/tasks.c **** 						{
3617:FreeRTOS/Src/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3618:FreeRTOS/Src/tasks.c **** 							{
3619:FreeRTOS/Src/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3620:FreeRTOS/Src/tasks.c **** 							}
3621:FreeRTOS/Src/tasks.c **** 						}
3622:FreeRTOS/Src/tasks.c **** 						( void ) xTaskResumeAll();
3623:FreeRTOS/Src/tasks.c **** 					}
3624:FreeRTOS/Src/tasks.c **** 				}
3625:FreeRTOS/Src/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3626:FreeRTOS/Src/tasks.c **** 			}
3627:FreeRTOS/Src/tasks.c **** 		}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 66


3628:FreeRTOS/Src/tasks.c **** 		else
3629:FreeRTOS/Src/tasks.c **** 		{
3630:FreeRTOS/Src/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3631:FreeRTOS/Src/tasks.c **** 		}
3632:FreeRTOS/Src/tasks.c **** 
3633:FreeRTOS/Src/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3634:FreeRTOS/Src/tasks.c **** 		parameter is provided to allow it to be skipped. */
3635:FreeRTOS/Src/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3636:FreeRTOS/Src/tasks.c **** 		{
3637:FreeRTOS/Src/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3638:FreeRTOS/Src/tasks.c **** 			{
3639:FreeRTOS/Src/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3640:FreeRTOS/Src/tasks.c **** 			}
3641:FreeRTOS/Src/tasks.c **** 			#else
3642:FreeRTOS/Src/tasks.c **** 			{
3643:FreeRTOS/Src/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3644:FreeRTOS/Src/tasks.c **** 			}
3645:FreeRTOS/Src/tasks.c **** 			#endif
3646:FreeRTOS/Src/tasks.c **** 		}
3647:FreeRTOS/Src/tasks.c **** 		else
3648:FreeRTOS/Src/tasks.c **** 		{
3649:FreeRTOS/Src/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3650:FreeRTOS/Src/tasks.c **** 		}
3651:FreeRTOS/Src/tasks.c **** 	}
3652:FreeRTOS/Src/tasks.c **** 
3653:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3654:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3655:FreeRTOS/Src/tasks.c **** 
3656:FreeRTOS/Src/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3657:FreeRTOS/Src/tasks.c **** 
3658:FreeRTOS/Src/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3659:FreeRTOS/Src/tasks.c **** 	{
3660:FreeRTOS/Src/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3661:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTask = 0;
3662:FreeRTOS/Src/tasks.c **** 
3663:FreeRTOS/Src/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3664:FreeRTOS/Src/tasks.c **** 		{
3665:FreeRTOS/Src/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3666:FreeRTOS/Src/tasks.c **** 
3667:FreeRTOS/Src/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3668:FreeRTOS/Src/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3669:FreeRTOS/Src/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3670:FreeRTOS/Src/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3671:FreeRTOS/Src/tasks.c **** 			do
3672:FreeRTOS/Src/tasks.c **** 			{
3673:FreeRTOS/Src/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3674:FreeRTOS/Src/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3675:FreeRTOS/Src/tasks.c **** 				uxTask++;
3676:FreeRTOS/Src/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3677:FreeRTOS/Src/tasks.c **** 		}
3678:FreeRTOS/Src/tasks.c **** 		else
3679:FreeRTOS/Src/tasks.c **** 		{
3680:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3681:FreeRTOS/Src/tasks.c **** 		}
3682:FreeRTOS/Src/tasks.c **** 
3683:FreeRTOS/Src/tasks.c **** 		return uxTask;
3684:FreeRTOS/Src/tasks.c **** 	}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 67


3685:FreeRTOS/Src/tasks.c **** 
3686:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3687:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3688:FreeRTOS/Src/tasks.c **** 
3689:FreeRTOS/Src/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3690:FreeRTOS/Src/tasks.c **** 
3691:FreeRTOS/Src/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3692:FreeRTOS/Src/tasks.c **** 	{
3693:FreeRTOS/Src/tasks.c **** 	uint32_t ulCount = 0U;
3694:FreeRTOS/Src/tasks.c **** 
3695:FreeRTOS/Src/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3696:FreeRTOS/Src/tasks.c **** 		{
3697:FreeRTOS/Src/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3698:FreeRTOS/Src/tasks.c **** 			ulCount++;
3699:FreeRTOS/Src/tasks.c **** 		}
3700:FreeRTOS/Src/tasks.c **** 
3701:FreeRTOS/Src/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3702:FreeRTOS/Src/tasks.c **** 
3703:FreeRTOS/Src/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3704:FreeRTOS/Src/tasks.c **** 	}
3705:FreeRTOS/Src/tasks.c **** 
3706:FreeRTOS/Src/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3707:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3708:FreeRTOS/Src/tasks.c **** 
3709:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3710:FreeRTOS/Src/tasks.c **** 
3711:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3712:FreeRTOS/Src/tasks.c **** 	{
3713:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
3714:FreeRTOS/Src/tasks.c **** 	uint8_t *pucEndOfStack;
3715:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxReturn;
3716:FreeRTOS/Src/tasks.c **** 
3717:FreeRTOS/Src/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3718:FreeRTOS/Src/tasks.c **** 
3719:FreeRTOS/Src/tasks.c **** 		#if portSTACK_GROWTH < 0
3720:FreeRTOS/Src/tasks.c **** 		{
3721:FreeRTOS/Src/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3722:FreeRTOS/Src/tasks.c **** 		}
3723:FreeRTOS/Src/tasks.c **** 		#else
3724:FreeRTOS/Src/tasks.c **** 		{
3725:FreeRTOS/Src/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3726:FreeRTOS/Src/tasks.c **** 		}
3727:FreeRTOS/Src/tasks.c **** 		#endif
3728:FreeRTOS/Src/tasks.c **** 
3729:FreeRTOS/Src/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3730:FreeRTOS/Src/tasks.c **** 
3731:FreeRTOS/Src/tasks.c **** 		return uxReturn;
3732:FreeRTOS/Src/tasks.c **** 	}
3733:FreeRTOS/Src/tasks.c **** 
3734:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3735:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3736:FreeRTOS/Src/tasks.c **** 
3737:FreeRTOS/Src/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3738:FreeRTOS/Src/tasks.c **** 
3739:FreeRTOS/Src/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3740:FreeRTOS/Src/tasks.c **** 	{
3741:FreeRTOS/Src/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 68


3742:FreeRTOS/Src/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3743:FreeRTOS/Src/tasks.c **** 		want to allocate and clean RAM statically. */
3744:FreeRTOS/Src/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3745:FreeRTOS/Src/tasks.c **** 
3746:FreeRTOS/Src/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3747:FreeRTOS/Src/tasks.c **** 		to the task to free any memory allocated at the application level. */
3748:FreeRTOS/Src/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3749:FreeRTOS/Src/tasks.c **** 		{
3750:FreeRTOS/Src/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3751:FreeRTOS/Src/tasks.c **** 		}
3752:FreeRTOS/Src/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3753:FreeRTOS/Src/tasks.c **** 
3754:FreeRTOS/Src/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3755:FreeRTOS/Src/tasks.c **** 		{
3756:FreeRTOS/Src/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3757:FreeRTOS/Src/tasks.c **** 			the stack and TCB. */
3758:FreeRTOS/Src/tasks.c **** 			vPortFree( pxTCB->pxStack );
3759:FreeRTOS/Src/tasks.c **** 			vPortFree( pxTCB );
3760:FreeRTOS/Src/tasks.c **** 		}
3761:FreeRTOS/Src/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3762:FreeRTOS/Src/tasks.c **** 		{
3763:FreeRTOS/Src/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3764:FreeRTOS/Src/tasks.c **** 			check what was statically allocated before trying to free the
3765:FreeRTOS/Src/tasks.c **** 			memory. */
3766:FreeRTOS/Src/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3767:FreeRTOS/Src/tasks.c **** 			{
3768:FreeRTOS/Src/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3769:FreeRTOS/Src/tasks.c **** 				must be freed. */
3770:FreeRTOS/Src/tasks.c **** 				vPortFree( pxTCB->pxStack );
3771:FreeRTOS/Src/tasks.c **** 				vPortFree( pxTCB );
3772:FreeRTOS/Src/tasks.c **** 			}
3773:FreeRTOS/Src/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3774:FreeRTOS/Src/tasks.c **** 			{
3775:FreeRTOS/Src/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3776:FreeRTOS/Src/tasks.c **** 				only memory that must be freed. */
3777:FreeRTOS/Src/tasks.c **** 				vPortFree( pxTCB );
3778:FreeRTOS/Src/tasks.c **** 			}
3779:FreeRTOS/Src/tasks.c **** 			else
3780:FreeRTOS/Src/tasks.c **** 			{
3781:FreeRTOS/Src/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3782:FreeRTOS/Src/tasks.c **** 				nothing needs to be freed. */
3783:FreeRTOS/Src/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3784:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3785:FreeRTOS/Src/tasks.c **** 			}
3786:FreeRTOS/Src/tasks.c **** 		}
3787:FreeRTOS/Src/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3788:FreeRTOS/Src/tasks.c **** 	}
3789:FreeRTOS/Src/tasks.c **** 
3790:FreeRTOS/Src/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3791:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3792:FreeRTOS/Src/tasks.c **** 
3793:FreeRTOS/Src/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3794:FreeRTOS/Src/tasks.c **** {
  81              		.loc 1 3794 0
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 0
  84              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 69


  85              		@ link register save eliminated.
3795:FreeRTOS/Src/tasks.c **** TCB_t *pxTCB;
3796:FreeRTOS/Src/tasks.c **** 
3797:FreeRTOS/Src/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  86              		.loc 1 3797 0
  87 0000 084B     		ldr	r3, .L11
  88 0002 1B68     		ldr	r3, [r3]
  89 0004 1B68     		ldr	r3, [r3]
  90 0006 23B9     		cbnz	r3, .L9
3798:FreeRTOS/Src/tasks.c **** 	{
3799:FreeRTOS/Src/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3800:FreeRTOS/Src/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3801:FreeRTOS/Src/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3802:FreeRTOS/Src/tasks.c **** 		there is an item in the delayed list. */
3803:FreeRTOS/Src/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
  91              		.loc 1 3803 0
  92 0008 4FF0FF32 		mov	r2, #-1
  93 000c 064B     		ldr	r3, .L11+4
  94 000e 1A60     		str	r2, [r3]
  95 0010 7047     		bx	lr
  96              	.L9:
3804:FreeRTOS/Src/tasks.c **** 	}
3805:FreeRTOS/Src/tasks.c **** 	else
3806:FreeRTOS/Src/tasks.c **** 	{
3807:FreeRTOS/Src/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3808:FreeRTOS/Src/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3809:FreeRTOS/Src/tasks.c **** 		which the task at the head of the delayed list should be removed
3810:FreeRTOS/Src/tasks.c **** 		from the Blocked state. */
3811:FreeRTOS/Src/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
  97              		.loc 1 3811 0
  98 0012 044B     		ldr	r3, .L11
  99 0014 1B68     		ldr	r3, [r3]
 100 0016 DB68     		ldr	r3, [r3, #12]
 101 0018 DB68     		ldr	r3, [r3, #12]
 102              	.LVL8:
3812:FreeRTOS/Src/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 103              		.loc 1 3812 0
 104 001a 5A68     		ldr	r2, [r3, #4]
 105 001c 024B     		ldr	r3, .L11+4
 106              	.LVL9:
 107 001e 1A60     		str	r2, [r3]
 108 0020 7047     		bx	lr
 109              	.L12:
 110 0022 00BF     		.align	2
 111              	.L11:
 112 0024 00000000 		.word	.LANCHOR2
 113 0028 00000000 		.word	.LANCHOR3
 114              		.cfi_endproc
 115              	.LFE67:
 117              		.section	.text.prvDeleteTCB,"ax",%progbits
 118              		.align	2
 119              		.thumb
 120              		.thumb_func
 122              	prvDeleteTCB:
 123              	.LFB66:
3740:FreeRTOS/Src/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
 124              		.loc 1 3740 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 70


 125              		.cfi_startproc
 126              		@ args = 0, pretend = 0, frame = 0
 127              		@ frame_needed = 0, uses_anonymous_args = 0
 128              	.LVL10:
 129 0000 10B5     		push	{r4, lr}
 130              	.LCFI0:
 131              		.cfi_def_cfa_offset 8
 132              		.cfi_offset 4, -8
 133              		.cfi_offset 14, -4
 134 0002 0446     		mov	r4, r0
3758:FreeRTOS/Src/tasks.c **** 			vPortFree( pxTCB );
 135              		.loc 1 3758 0
 136 0004 006B     		ldr	r0, [r0, #48]
 137              	.LVL11:
 138 0006 FFF7FEFF 		bl	vPortFree
 139              	.LVL12:
3759:FreeRTOS/Src/tasks.c **** 		}
 140              		.loc 1 3759 0
 141 000a 2046     		mov	r0, r4
 142 000c FFF7FEFF 		bl	vPortFree
 143              	.LVL13:
 144 0010 10BD     		pop	{r4, pc}
 145              		.cfi_endproc
 146              	.LFE66:
 148 0012 00BF     		.section	.text.prvInitialiseNewTask,"ax",%progbits
 149              		.align	2
 150              		.thumb
 151              		.thumb_func
 153              	prvInitialiseNewTask:
 154              	.LFB33:
 846:FreeRTOS/Src/tasks.c **** StackType_t *pxTopOfStack;
 155              		.loc 1 846 0
 156              		.cfi_startproc
 157              		@ args = 16, pretend = 0, frame = 0
 158              		@ frame_needed = 0, uses_anonymous_args = 0
 159              	.LVL14:
 160 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 161              	.LCFI1:
 162              		.cfi_def_cfa_offset 32
 163              		.cfi_offset 3, -32
 164              		.cfi_offset 4, -28
 165              		.cfi_offset 5, -24
 166              		.cfi_offset 6, -20
 167              		.cfi_offset 7, -16
 168              		.cfi_offset 8, -12
 169              		.cfi_offset 9, -8
 170              		.cfi_offset 14, -4
 171 0004 8046     		mov	r8, r0
 172 0006 9946     		mov	r9, r3
 173 0008 089D     		ldr	r5, [sp, #32]
 174 000a 099F     		ldr	r7, [sp, #36]
 175 000c 0A9C     		ldr	r4, [sp, #40]
 880:FreeRTOS/Src/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 176              		.loc 1 880 0
 177 000e 236B     		ldr	r3, [r4, #48]
 178              	.LVL15:
 179 0010 02F18042 		add	r2, r2, #1073741824
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 71


 180              	.LVL16:
 181 0014 013A     		subs	r2, r2, #1
 182              	.LVL17:
 183 0016 03EB8206 		add	r6, r3, r2, lsl #2
 184              	.LVL18:
 881:FreeRTOS/Src/tasks.c **** 
 185              		.loc 1 881 0
 186 001a 26F00706 		bic	r6, r6, #7
 187              	.LVL19:
 908:FreeRTOS/Src/tasks.c **** 	{
 188              		.loc 1 908 0
 189 001e 0023     		movs	r3, #0
 190 0020 06E0     		b	.L16
 191              	.LVL20:
 192              	.L18:
 910:FreeRTOS/Src/tasks.c **** 
 193              		.loc 1 910 0
 194 0022 C85C     		ldrb	r0, [r1, r3]	@ zero_extendqisi2
 195 0024 E218     		adds	r2, r4, r3
 196 0026 82F83400 		strb	r0, [r2, #52]
 915:FreeRTOS/Src/tasks.c **** 		{
 197              		.loc 1 915 0
 198 002a CA5C     		ldrb	r2, [r1, r3]	@ zero_extendqisi2
 199 002c 12B1     		cbz	r2, .L17
 908:FreeRTOS/Src/tasks.c **** 	{
 200              		.loc 1 908 0 discriminator 2
 201 002e 0133     		adds	r3, r3, #1
 202              	.LVL21:
 203              	.L16:
 908:FreeRTOS/Src/tasks.c **** 	{
 204              		.loc 1 908 0 is_stmt 0 discriminator 1
 205 0030 0F2B     		cmp	r3, #15
 206 0032 F6D9     		bls	.L18
 207              	.L17:
 927:FreeRTOS/Src/tasks.c **** 
 208              		.loc 1 927 0 is_stmt 1
 209 0034 0023     		movs	r3, #0
 210              	.LVL22:
 211 0036 84F84330 		strb	r3, [r4, #67]
 931:FreeRTOS/Src/tasks.c **** 	{
 212              		.loc 1 931 0
 213 003a 042D     		cmp	r5, #4
 214 003c 00D9     		bls	.L19
 933:FreeRTOS/Src/tasks.c **** 	}
 215              		.loc 1 933 0
 216 003e 0425     		movs	r5, #4
 217              	.L19:
 218              	.LVL23:
 940:FreeRTOS/Src/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 219              		.loc 1 940 0
 220 0040 E562     		str	r5, [r4, #44]
 948:FreeRTOS/Src/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 221              		.loc 1 948 0
 222 0042 201D     		adds	r0, r4, #4
 223 0044 FFF7FEFF 		bl	vListInitialiseItem
 224              	.LVL24:
 949:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 72


 225              		.loc 1 949 0
 226 0048 04F11800 		add	r0, r4, #24
 227 004c FFF7FEFF 		bl	vListInitialiseItem
 228              	.LVL25:
 953:FreeRTOS/Src/tasks.c **** 
 229              		.loc 1 953 0
 230 0050 2461     		str	r4, [r4, #16]
 956:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 231              		.loc 1 956 0
 232 0052 C5F10505 		rsb	r5, r5, #5
 233              	.LVL26:
 234 0056 A561     		str	r5, [r4, #24]
 957:FreeRTOS/Src/tasks.c **** 
 235              		.loc 1 957 0
 236 0058 6462     		str	r4, [r4, #36]
 999:FreeRTOS/Src/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 237              		.loc 1 999 0
 238 005a 0023     		movs	r3, #0
 239 005c 6364     		str	r3, [r4, #68]
1000:FreeRTOS/Src/tasks.c **** 	}
 240              		.loc 1 1000 0
 241 005e 84F84830 		strb	r3, [r4, #72]
1027:FreeRTOS/Src/tasks.c **** 	}
 242              		.loc 1 1027 0
 243 0062 4A46     		mov	r2, r9
 244 0064 4146     		mov	r1, r8
 245 0066 3046     		mov	r0, r6
 246 0068 FFF7FEFF 		bl	pxPortInitialiseStack
 247              	.LVL27:
 248 006c 2060     		str	r0, [r4]
1031:FreeRTOS/Src/tasks.c **** 	{
 249              		.loc 1 1031 0
 250 006e 07B1     		cbz	r7, .L15
1035:FreeRTOS/Src/tasks.c **** 	}
 251              		.loc 1 1035 0
 252 0070 3C60     		str	r4, [r7]
 253              	.L15:
 254 0072 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 255              		.cfi_endproc
 256              	.LFE33:
 258 0076 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 259              		.align	2
 260              		.thumb
 261              		.thumb_func
 263              	prvInitialiseTaskLists:
 264              	.LFB64:
3500:FreeRTOS/Src/tasks.c **** UBaseType_t uxPriority;
 265              		.loc 1 3500 0
 266              		.cfi_startproc
 267              		@ args = 0, pretend = 0, frame = 0
 268              		@ frame_needed = 0, uses_anonymous_args = 0
 269 0000 38B5     		push	{r3, r4, r5, lr}
 270              	.LCFI2:
 271              		.cfi_def_cfa_offset 16
 272              		.cfi_offset 3, -16
 273              		.cfi_offset 4, -12
 274              		.cfi_offset 5, -8
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 73


 275              		.cfi_offset 14, -4
 276              	.LVL28:
3503:FreeRTOS/Src/tasks.c **** 	{
 277              		.loc 1 3503 0
 278 0002 0024     		movs	r4, #0
 279 0004 07E0     		b	.L24
 280              	.LVL29:
 281              	.L25:
3505:FreeRTOS/Src/tasks.c **** 	}
 282              		.loc 1 3505 0 discriminator 3
 283 0006 04EB8402 		add	r2, r4, r4, lsl #2
 284 000a 9300     		lsls	r3, r2, #2
 285 000c 0E48     		ldr	r0, .L27
 286 000e 1844     		add	r0, r0, r3
 287 0010 FFF7FEFF 		bl	vListInitialise
 288              	.LVL30:
3503:FreeRTOS/Src/tasks.c **** 	{
 289              		.loc 1 3503 0 discriminator 3
 290 0014 0134     		adds	r4, r4, #1
 291              	.LVL31:
 292              	.L24:
3503:FreeRTOS/Src/tasks.c **** 	{
 293              		.loc 1 3503 0 is_stmt 0 discriminator 1
 294 0016 042C     		cmp	r4, #4
 295 0018 F5D9     		bls	.L25
3508:FreeRTOS/Src/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 296              		.loc 1 3508 0 is_stmt 1
 297 001a 0C4D     		ldr	r5, .L27+4
 298 001c 2846     		mov	r0, r5
 299 001e FFF7FEFF 		bl	vListInitialise
 300              	.LVL32:
3509:FreeRTOS/Src/tasks.c **** 	vListInitialise( &xPendingReadyList );
 301              		.loc 1 3509 0
 302 0022 0B4C     		ldr	r4, .L27+8
 303              	.LVL33:
 304 0024 2046     		mov	r0, r4
 305 0026 FFF7FEFF 		bl	vListInitialise
 306              	.LVL34:
3510:FreeRTOS/Src/tasks.c **** 
 307              		.loc 1 3510 0
 308 002a 0A48     		ldr	r0, .L27+12
 309 002c FFF7FEFF 		bl	vListInitialise
 310              	.LVL35:
3514:FreeRTOS/Src/tasks.c **** 	}
 311              		.loc 1 3514 0
 312 0030 0948     		ldr	r0, .L27+16
 313 0032 FFF7FEFF 		bl	vListInitialise
 314              	.LVL36:
3520:FreeRTOS/Src/tasks.c **** 	}
 315              		.loc 1 3520 0
 316 0036 0948     		ldr	r0, .L27+20
 317 0038 FFF7FEFF 		bl	vListInitialise
 318              	.LVL37:
3526:FreeRTOS/Src/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 319              		.loc 1 3526 0
 320 003c 084B     		ldr	r3, .L27+24
 321 003e 1D60     		str	r5, [r3]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 74


3527:FreeRTOS/Src/tasks.c **** }
 322              		.loc 1 3527 0
 323 0040 084B     		ldr	r3, .L27+28
 324 0042 1C60     		str	r4, [r3]
 325 0044 38BD     		pop	{r3, r4, r5, pc}
 326              	.L28:
 327 0046 00BF     		.align	2
 328              	.L27:
 329 0048 00000000 		.word	.LANCHOR4
 330 004c 00000000 		.word	.LANCHOR5
 331 0050 00000000 		.word	.LANCHOR6
 332 0054 00000000 		.word	.LANCHOR1
 333 0058 00000000 		.word	.LANCHOR7
 334 005c 00000000 		.word	.LANCHOR0
 335 0060 00000000 		.word	.LANCHOR2
 336 0064 00000000 		.word	.LANCHOR8
 337              		.cfi_endproc
 338              	.LFE64:
 340              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 341              		.align	2
 342              		.thumb
 343              		.thumb_func
 345              	prvAddNewTaskToReadyList:
 346              	.LFB34:
1045:FreeRTOS/Src/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
 347              		.loc 1 1045 0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 0
 350              		@ frame_needed = 0, uses_anonymous_args = 0
 351              	.LVL38:
 352 0000 10B5     		push	{r4, lr}
 353              	.LCFI3:
 354              		.cfi_def_cfa_offset 8
 355              		.cfi_offset 4, -8
 356              		.cfi_offset 14, -4
 357 0002 0446     		mov	r4, r0
1048:FreeRTOS/Src/tasks.c **** 	{
 358              		.loc 1 1048 0
 359 0004 FFF7FEFF 		bl	vPortEnterCritical
 360              	.LVL39:
1050:FreeRTOS/Src/tasks.c **** 		if( pxCurrentTCB == NULL )
 361              		.loc 1 1050 0
 362 0008 204A     		ldr	r2, .L34
 363 000a 1368     		ldr	r3, [r2]
 364 000c 0133     		adds	r3, r3, #1
 365 000e 1360     		str	r3, [r2]
1051:FreeRTOS/Src/tasks.c **** 		{
 366              		.loc 1 1051 0
 367 0010 1F4B     		ldr	r3, .L34+4
 368 0012 1B68     		ldr	r3, [r3]
 369 0014 3BB9     		cbnz	r3, .L30
1055:FreeRTOS/Src/tasks.c **** 
 370              		.loc 1 1055 0
 371 0016 1E4B     		ldr	r3, .L34+4
 372 0018 1C60     		str	r4, [r3]
1057:FreeRTOS/Src/tasks.c **** 			{
 373              		.loc 1 1057 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 75


 374 001a 1368     		ldr	r3, [r2]
 375 001c 012B     		cmp	r3, #1
 376 001e 0DD1     		bne	.L31
1062:FreeRTOS/Src/tasks.c **** 			}
 377              		.loc 1 1062 0
 378 0020 FFF7FEFF 		bl	prvInitialiseTaskLists
 379              	.LVL40:
 380 0024 0AE0     		b	.L31
 381              	.L30:
1074:FreeRTOS/Src/tasks.c **** 			{
 382              		.loc 1 1074 0
 383 0026 1B4B     		ldr	r3, .L34+8
 384 0028 1B68     		ldr	r3, [r3]
 385 002a 3BB9     		cbnz	r3, .L31
1076:FreeRTOS/Src/tasks.c **** 				{
 386              		.loc 1 1076 0
 387 002c 184B     		ldr	r3, .L34+4
 388 002e 1B68     		ldr	r3, [r3]
 389 0030 DA6A     		ldr	r2, [r3, #44]
 390 0032 E36A     		ldr	r3, [r4, #44]
 391 0034 9A42     		cmp	r2, r3
 392 0036 01D8     		bhi	.L31
1078:FreeRTOS/Src/tasks.c **** 				}
 393              		.loc 1 1078 0
 394 0038 154B     		ldr	r3, .L34+4
 395 003a 1C60     		str	r4, [r3]
 396              	.L31:
1091:FreeRTOS/Src/tasks.c **** 
 397              		.loc 1 1091 0
 398 003c 164A     		ldr	r2, .L34+12
 399 003e 1368     		ldr	r3, [r2]
 400 0040 0133     		adds	r3, r3, #1
 401 0042 1360     		str	r3, [r2]
1101:FreeRTOS/Src/tasks.c **** 
 402              		.loc 1 1101 0
 403 0044 E36A     		ldr	r3, [r4, #44]
 404 0046 0122     		movs	r2, #1
 405 0048 02FA03F1 		lsl	r1, r2, r3
 406 004c 1348     		ldr	r0, .L34+16
 407 004e 0268     		ldr	r2, [r0]
 408 0050 0A43     		orrs	r2, r2, r1
 409 0052 0260     		str	r2, [r0]
 410 0054 03EB8303 		add	r3, r3, r3, lsl #2
 411 0058 9A00     		lsls	r2, r3, #2
 412 005a 211D     		adds	r1, r4, #4
 413 005c 1048     		ldr	r0, .L34+20
 414 005e 1044     		add	r0, r0, r2
 415 0060 FFF7FEFF 		bl	vListInsertEnd
 416              	.LVL41:
1105:FreeRTOS/Src/tasks.c **** 
 417              		.loc 1 1105 0
 418 0064 FFF7FEFF 		bl	vPortExitCritical
 419              	.LVL42:
1107:FreeRTOS/Src/tasks.c **** 	{
 420              		.loc 1 1107 0
 421 0068 0A4B     		ldr	r3, .L34+8
 422 006a 1B68     		ldr	r3, [r3]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 76


 423 006c 6BB1     		cbz	r3, .L29
1111:FreeRTOS/Src/tasks.c **** 		{
 424              		.loc 1 1111 0
 425 006e 084B     		ldr	r3, .L34+4
 426 0070 1B68     		ldr	r3, [r3]
 427 0072 DA6A     		ldr	r2, [r3, #44]
 428 0074 E36A     		ldr	r3, [r4, #44]
 429 0076 9A42     		cmp	r2, r3
 430 0078 07D2     		bcs	.L29
1113:FreeRTOS/Src/tasks.c **** 		}
 431              		.loc 1 1113 0
 432 007a 4FF08052 		mov	r2, #268435456
 433 007e 094B     		ldr	r3, .L34+24
 434 0080 1A60     		str	r2, [r3]
 435              		.syntax unified
 436              	@ 1113 "FreeRTOS/Src/tasks.c" 1
 437 0082 BFF34F8F 		dsb
 438              	@ 0 "" 2
 439              	@ 1113 "FreeRTOS/Src/tasks.c" 1
 440 0086 BFF36F8F 		isb
 441              	@ 0 "" 2
 442              		.thumb
 443              		.syntax unified
 444              	.L29:
 445 008a 10BD     		pop	{r4, pc}
 446              	.LVL43:
 447              	.L35:
 448              		.align	2
 449              	.L34:
 450 008c 00000000 		.word	.LANCHOR9
 451 0090 00000000 		.word	.LANCHOR10
 452 0094 00000000 		.word	.LANCHOR11
 453 0098 00000000 		.word	.LANCHOR12
 454 009c 00000000 		.word	.LANCHOR13
 455 00a0 00000000 		.word	.LANCHOR4
 456 00a4 04ED00E0 		.word	-536810236
 457              		.cfi_endproc
 458              	.LFE34:
 460              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 461              		.align	2
 462              		.thumb
 463              		.thumb_func
 465              	prvCheckTasksWaitingTermination:
 466              	.LFB65:
3532:FreeRTOS/Src/tasks.c **** 
 467              		.loc 1 3532 0
 468              		.cfi_startproc
 469              		@ args = 0, pretend = 0, frame = 0
 470              		@ frame_needed = 0, uses_anonymous_args = 0
 471 0000 10B5     		push	{r4, lr}
 472              	.LCFI4:
 473              		.cfi_def_cfa_offset 8
 474              		.cfi_offset 4, -8
 475              		.cfi_offset 14, -4
 476              	.LBB26:
3542:FreeRTOS/Src/tasks.c **** 		{
 477              		.loc 1 3542 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 77


 478 0002 14E0     		b	.L37
 479              	.L38:
3544:FreeRTOS/Src/tasks.c **** 			{
 480              		.loc 1 3544 0
 481 0004 FFF7FEFF 		bl	vPortEnterCritical
 482              	.LVL44:
3546:FreeRTOS/Src/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 483              		.loc 1 3546 0
 484 0008 0B4B     		ldr	r3, .L40
 485 000a DB68     		ldr	r3, [r3, #12]
 486 000c DC68     		ldr	r4, [r3, #12]
 487              	.LVL45:
3547:FreeRTOS/Src/tasks.c **** 				--uxCurrentNumberOfTasks;
 488              		.loc 1 3547 0
 489 000e 201D     		adds	r0, r4, #4
 490 0010 FFF7FEFF 		bl	uxListRemove
 491              	.LVL46:
3548:FreeRTOS/Src/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 492              		.loc 1 3548 0
 493 0014 094A     		ldr	r2, .L40+4
 494 0016 1368     		ldr	r3, [r2]
 495 0018 013B     		subs	r3, r3, #1
 496 001a 1360     		str	r3, [r2]
3549:FreeRTOS/Src/tasks.c **** 			}
 497              		.loc 1 3549 0
 498 001c 084A     		ldr	r2, .L40+8
 499 001e 1368     		ldr	r3, [r2]
 500 0020 013B     		subs	r3, r3, #1
 501 0022 1360     		str	r3, [r2]
3551:FreeRTOS/Src/tasks.c **** 
 502              		.loc 1 3551 0
 503 0024 FFF7FEFF 		bl	vPortExitCritical
 504              	.LVL47:
3553:FreeRTOS/Src/tasks.c **** 		}
 505              		.loc 1 3553 0
 506 0028 2046     		mov	r0, r4
 507 002a FFF7FEFF 		bl	prvDeleteTCB
 508              	.LVL48:
 509              	.L37:
3542:FreeRTOS/Src/tasks.c **** 		{
 510              		.loc 1 3542 0
 511 002e 044B     		ldr	r3, .L40+8
 512 0030 1B68     		ldr	r3, [r3]
 513 0032 002B     		cmp	r3, #0
 514 0034 E6D1     		bne	.L38
 515              	.LBE26:
3557:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 516              		.loc 1 3557 0
 517 0036 10BD     		pop	{r4, pc}
 518              	.L41:
 519              		.align	2
 520              	.L40:
 521 0038 00000000 		.word	.LANCHOR7
 522 003c 00000000 		.word	.LANCHOR9
 523 0040 00000000 		.word	.LANCHOR14
 524              		.cfi_endproc
 525              	.LFE65:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 78


 527              		.section	.text.prvIdleTask,"ax",%progbits
 528              		.align	2
 529              		.thumb
 530              		.thumb_func
 532              	prvIdleTask:
 533              	.LFB63:
3288:FreeRTOS/Src/tasks.c **** 	/* Stop warnings. */
 534              		.loc 1 3288 0
 535              		.cfi_startproc
 536              		@ Volatile: function does not return.
 537              		@ args = 0, pretend = 0, frame = 0
 538              		@ frame_needed = 0, uses_anonymous_args = 0
 539              	.LVL49:
 540 0000 08B5     		push	{r3, lr}
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 8
 543              		.cfi_offset 3, -8
 544              		.cfi_offset 14, -4
 545              	.LVL50:
 546              	.L43:
3304:FreeRTOS/Src/tasks.c **** 
 547              		.loc 1 3304 0
 548 0002 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
 549              	.LVL51:
3327:FreeRTOS/Src/tasks.c **** 			{
 550              		.loc 1 3327 0
 551 0006 064B     		ldr	r3, .L46
 552 0008 1B68     		ldr	r3, [r3]
 553 000a 012B     		cmp	r3, #1
 554 000c F9D9     		bls	.L43
3329:FreeRTOS/Src/tasks.c **** 			}
 555              		.loc 1 3329 0
 556 000e 4FF08052 		mov	r2, #268435456
 557 0012 044B     		ldr	r3, .L46+4
 558 0014 1A60     		str	r2, [r3]
 559              		.syntax unified
 560              	@ 3329 "FreeRTOS/Src/tasks.c" 1
 561 0016 BFF34F8F 		dsb
 562              	@ 0 "" 2
 563              	@ 3329 "FreeRTOS/Src/tasks.c" 1
 564 001a BFF36F8F 		isb
 565              	@ 0 "" 2
 566              		.thumb
 567              		.syntax unified
 568 001e F0E7     		b	.L43
 569              	.L47:
 570              		.align	2
 571              	.L46:
 572 0020 00000000 		.word	.LANCHOR4
 573 0024 04ED00E0 		.word	-536810236
 574              		.cfi_endproc
 575              	.LFE63:
 577              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 578              		.align	2
 579              		.thumb
 580              		.thumb_func
 582              	prvAddCurrentTaskToDelayedList:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 79


 583              	.LFB75:
3813:FreeRTOS/Src/tasks.c **** 	}
3814:FreeRTOS/Src/tasks.c **** }
3815:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3816:FreeRTOS/Src/tasks.c **** 
3817:FreeRTOS/Src/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3818:FreeRTOS/Src/tasks.c **** 
3819:FreeRTOS/Src/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3820:FreeRTOS/Src/tasks.c **** 	{
3821:FreeRTOS/Src/tasks.c **** 	TaskHandle_t xReturn;
3822:FreeRTOS/Src/tasks.c **** 
3823:FreeRTOS/Src/tasks.c **** 		/* A critical section is not required as this is not called from
3824:FreeRTOS/Src/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3825:FreeRTOS/Src/tasks.c **** 		individual execution thread. */
3826:FreeRTOS/Src/tasks.c **** 		xReturn = pxCurrentTCB;
3827:FreeRTOS/Src/tasks.c **** 
3828:FreeRTOS/Src/tasks.c **** 		return xReturn;
3829:FreeRTOS/Src/tasks.c **** 	}
3830:FreeRTOS/Src/tasks.c **** 
3831:FreeRTOS/Src/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3832:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3833:FreeRTOS/Src/tasks.c **** 
3834:FreeRTOS/Src/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3835:FreeRTOS/Src/tasks.c **** 
3836:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3837:FreeRTOS/Src/tasks.c **** 	{
3838:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
3839:FreeRTOS/Src/tasks.c **** 
3840:FreeRTOS/Src/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3841:FreeRTOS/Src/tasks.c **** 		{
3842:FreeRTOS/Src/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3843:FreeRTOS/Src/tasks.c **** 		}
3844:FreeRTOS/Src/tasks.c **** 		else
3845:FreeRTOS/Src/tasks.c **** 		{
3846:FreeRTOS/Src/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3847:FreeRTOS/Src/tasks.c **** 			{
3848:FreeRTOS/Src/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3849:FreeRTOS/Src/tasks.c **** 			}
3850:FreeRTOS/Src/tasks.c **** 			else
3851:FreeRTOS/Src/tasks.c **** 			{
3852:FreeRTOS/Src/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3853:FreeRTOS/Src/tasks.c **** 			}
3854:FreeRTOS/Src/tasks.c **** 		}
3855:FreeRTOS/Src/tasks.c **** 
3856:FreeRTOS/Src/tasks.c **** 		return xReturn;
3857:FreeRTOS/Src/tasks.c **** 	}
3858:FreeRTOS/Src/tasks.c **** 
3859:FreeRTOS/Src/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3860:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3861:FreeRTOS/Src/tasks.c **** 
3862:FreeRTOS/Src/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3863:FreeRTOS/Src/tasks.c **** 
3864:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3865:FreeRTOS/Src/tasks.c **** 	{
3866:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
3867:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3868:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 80


3869:FreeRTOS/Src/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3870:FreeRTOS/Src/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3871:FreeRTOS/Src/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3872:FreeRTOS/Src/tasks.c **** 		if( pxMutexHolder != NULL )
3873:FreeRTOS/Src/tasks.c **** 		{
3874:FreeRTOS/Src/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3875:FreeRTOS/Src/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3876:FreeRTOS/Src/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3877:FreeRTOS/Src/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3878:FreeRTOS/Src/tasks.c **** 			{
3879:FreeRTOS/Src/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3880:FreeRTOS/Src/tasks.c **** 				priority.  Only reset the event list item value if the value is
3881:FreeRTOS/Src/tasks.c **** 				not being used for anything else. */
3882:FreeRTOS/Src/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3883:FreeRTOS/Src/tasks.c **** 				{
3884:FreeRTOS/Src/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3885:FreeRTOS/Src/tasks.c **** 				}
3886:FreeRTOS/Src/tasks.c **** 				else
3887:FreeRTOS/Src/tasks.c **** 				{
3888:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3889:FreeRTOS/Src/tasks.c **** 				}
3890:FreeRTOS/Src/tasks.c **** 
3891:FreeRTOS/Src/tasks.c **** 				/* If the task being modified is in the ready state it will need
3892:FreeRTOS/Src/tasks.c **** 				to be moved into a new list. */
3893:FreeRTOS/Src/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3894:FreeRTOS/Src/tasks.c **** 				{
3895:FreeRTOS/Src/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3896:FreeRTOS/Src/tasks.c **** 					{
3897:FreeRTOS/Src/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3898:FreeRTOS/Src/tasks.c **** 					}
3899:FreeRTOS/Src/tasks.c **** 					else
3900:FreeRTOS/Src/tasks.c **** 					{
3901:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3902:FreeRTOS/Src/tasks.c **** 					}
3903:FreeRTOS/Src/tasks.c **** 
3904:FreeRTOS/Src/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3905:FreeRTOS/Src/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3906:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3907:FreeRTOS/Src/tasks.c **** 				}
3908:FreeRTOS/Src/tasks.c **** 				else
3909:FreeRTOS/Src/tasks.c **** 				{
3910:FreeRTOS/Src/tasks.c **** 					/* Just inherit the priority. */
3911:FreeRTOS/Src/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3912:FreeRTOS/Src/tasks.c **** 				}
3913:FreeRTOS/Src/tasks.c **** 
3914:FreeRTOS/Src/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3915:FreeRTOS/Src/tasks.c **** 
3916:FreeRTOS/Src/tasks.c **** 				/* Inheritance occurred. */
3917:FreeRTOS/Src/tasks.c **** 				xReturn = pdTRUE;
3918:FreeRTOS/Src/tasks.c **** 			}
3919:FreeRTOS/Src/tasks.c **** 			else
3920:FreeRTOS/Src/tasks.c **** 			{
3921:FreeRTOS/Src/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3922:FreeRTOS/Src/tasks.c **** 				{
3923:FreeRTOS/Src/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3924:FreeRTOS/Src/tasks.c **** 					priority of the task attempting to take the mutex, but the
3925:FreeRTOS/Src/tasks.c **** 					current priority of the mutex holder is not lower than the
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 81


3926:FreeRTOS/Src/tasks.c **** 					priority of the task attempting to take the mutex.
3927:FreeRTOS/Src/tasks.c **** 					Therefore the mutex holder must have already inherited a
3928:FreeRTOS/Src/tasks.c **** 					priority, but inheritance would have occurred if that had
3929:FreeRTOS/Src/tasks.c **** 					not been the case. */
3930:FreeRTOS/Src/tasks.c **** 					xReturn = pdTRUE;
3931:FreeRTOS/Src/tasks.c **** 				}
3932:FreeRTOS/Src/tasks.c **** 				else
3933:FreeRTOS/Src/tasks.c **** 				{
3934:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3935:FreeRTOS/Src/tasks.c **** 				}
3936:FreeRTOS/Src/tasks.c **** 			}
3937:FreeRTOS/Src/tasks.c **** 		}
3938:FreeRTOS/Src/tasks.c **** 		else
3939:FreeRTOS/Src/tasks.c **** 		{
3940:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3941:FreeRTOS/Src/tasks.c **** 		}
3942:FreeRTOS/Src/tasks.c **** 
3943:FreeRTOS/Src/tasks.c **** 		return xReturn;
3944:FreeRTOS/Src/tasks.c **** 	}
3945:FreeRTOS/Src/tasks.c **** 
3946:FreeRTOS/Src/tasks.c **** #endif /* configUSE_MUTEXES */
3947:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
3948:FreeRTOS/Src/tasks.c **** 
3949:FreeRTOS/Src/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3950:FreeRTOS/Src/tasks.c **** 
3951:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3952:FreeRTOS/Src/tasks.c **** 	{
3953:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
3954:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3955:FreeRTOS/Src/tasks.c **** 
3956:FreeRTOS/Src/tasks.c **** 		if( pxMutexHolder != NULL )
3957:FreeRTOS/Src/tasks.c **** 		{
3958:FreeRTOS/Src/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3959:FreeRTOS/Src/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3960:FreeRTOS/Src/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3961:FreeRTOS/Src/tasks.c **** 			be the running state task. */
3962:FreeRTOS/Src/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3963:FreeRTOS/Src/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3964:FreeRTOS/Src/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3965:FreeRTOS/Src/tasks.c **** 
3966:FreeRTOS/Src/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3967:FreeRTOS/Src/tasks.c **** 			task? */
3968:FreeRTOS/Src/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3969:FreeRTOS/Src/tasks.c **** 			{
3970:FreeRTOS/Src/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3971:FreeRTOS/Src/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3972:FreeRTOS/Src/tasks.c **** 				{
3973:FreeRTOS/Src/tasks.c **** 					/* A task can only have an inherited priority if it holds
3974:FreeRTOS/Src/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3975:FreeRTOS/Src/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3976:FreeRTOS/Src/tasks.c **** 					holding task then it must be the running state task.  Remove
3977:FreeRTOS/Src/tasks.c **** 					the holding task from the ready list. */
3978:FreeRTOS/Src/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3979:FreeRTOS/Src/tasks.c **** 					{
3980:FreeRTOS/Src/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3981:FreeRTOS/Src/tasks.c **** 					}
3982:FreeRTOS/Src/tasks.c **** 					else
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 82


3983:FreeRTOS/Src/tasks.c **** 					{
3984:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3985:FreeRTOS/Src/tasks.c **** 					}
3986:FreeRTOS/Src/tasks.c **** 
3987:FreeRTOS/Src/tasks.c **** 					/* Disinherit the priority before adding the task into the
3988:FreeRTOS/Src/tasks.c **** 					new	ready list. */
3989:FreeRTOS/Src/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3990:FreeRTOS/Src/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3991:FreeRTOS/Src/tasks.c **** 
3992:FreeRTOS/Src/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3993:FreeRTOS/Src/tasks.c **** 					any other purpose if this task is running, and it must be
3994:FreeRTOS/Src/tasks.c **** 					running to give back the mutex. */
3995:FreeRTOS/Src/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3996:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3997:FreeRTOS/Src/tasks.c **** 
3998:FreeRTOS/Src/tasks.c **** 					/* Return true to indicate that a context switch is required.
3999:FreeRTOS/Src/tasks.c **** 					This is only actually required in the corner case whereby
4000:FreeRTOS/Src/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4001:FreeRTOS/Src/tasks.c **** 					in an order different to that in which they were taken.
4002:FreeRTOS/Src/tasks.c **** 					If a context switch did not occur when the first mutex was
4003:FreeRTOS/Src/tasks.c **** 					returned, even if a task was waiting on it, then a context
4004:FreeRTOS/Src/tasks.c **** 					switch should occur when the last mutex is returned whether
4005:FreeRTOS/Src/tasks.c **** 					a task is waiting on it or not. */
4006:FreeRTOS/Src/tasks.c **** 					xReturn = pdTRUE;
4007:FreeRTOS/Src/tasks.c **** 				}
4008:FreeRTOS/Src/tasks.c **** 				else
4009:FreeRTOS/Src/tasks.c **** 				{
4010:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4011:FreeRTOS/Src/tasks.c **** 				}
4012:FreeRTOS/Src/tasks.c **** 			}
4013:FreeRTOS/Src/tasks.c **** 			else
4014:FreeRTOS/Src/tasks.c **** 			{
4015:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4016:FreeRTOS/Src/tasks.c **** 			}
4017:FreeRTOS/Src/tasks.c **** 		}
4018:FreeRTOS/Src/tasks.c **** 		else
4019:FreeRTOS/Src/tasks.c **** 		{
4020:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4021:FreeRTOS/Src/tasks.c **** 		}
4022:FreeRTOS/Src/tasks.c **** 
4023:FreeRTOS/Src/tasks.c **** 		return xReturn;
4024:FreeRTOS/Src/tasks.c **** 	}
4025:FreeRTOS/Src/tasks.c **** 
4026:FreeRTOS/Src/tasks.c **** #endif /* configUSE_MUTEXES */
4027:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4028:FreeRTOS/Src/tasks.c **** 
4029:FreeRTOS/Src/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4030:FreeRTOS/Src/tasks.c **** 
4031:FreeRTOS/Src/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4032:FreeRTOS/Src/tasks.c **** 	{
4033:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4034:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4035:FreeRTOS/Src/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4036:FreeRTOS/Src/tasks.c **** 
4037:FreeRTOS/Src/tasks.c **** 		if( pxMutexHolder != NULL )
4038:FreeRTOS/Src/tasks.c **** 		{
4039:FreeRTOS/Src/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 83


4040:FreeRTOS/Src/tasks.c **** 			one mutex. */
4041:FreeRTOS/Src/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4042:FreeRTOS/Src/tasks.c **** 
4043:FreeRTOS/Src/tasks.c **** 			/* Determine the priority to which the priority of the task that
4044:FreeRTOS/Src/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4045:FreeRTOS/Src/tasks.c **** 			holding task's base priority and the priority of the highest
4046:FreeRTOS/Src/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4047:FreeRTOS/Src/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4048:FreeRTOS/Src/tasks.c **** 			{
4049:FreeRTOS/Src/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4050:FreeRTOS/Src/tasks.c **** 			}
4051:FreeRTOS/Src/tasks.c **** 			else
4052:FreeRTOS/Src/tasks.c **** 			{
4053:FreeRTOS/Src/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4054:FreeRTOS/Src/tasks.c **** 			}
4055:FreeRTOS/Src/tasks.c **** 
4056:FreeRTOS/Src/tasks.c **** 			/* Does the priority need to change? */
4057:FreeRTOS/Src/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4058:FreeRTOS/Src/tasks.c **** 			{
4059:FreeRTOS/Src/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4060:FreeRTOS/Src/tasks.c **** 				simplification in the priority inheritance implementation.  If
4061:FreeRTOS/Src/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4062:FreeRTOS/Src/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4063:FreeRTOS/Src/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4064:FreeRTOS/Src/tasks.c **** 				{
4065:FreeRTOS/Src/tasks.c **** 					/* If a task has timed out because it already holds the
4066:FreeRTOS/Src/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4067:FreeRTOS/Src/tasks.c **** 					its own priority. */
4068:FreeRTOS/Src/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4069:FreeRTOS/Src/tasks.c **** 
4070:FreeRTOS/Src/tasks.c **** 					/* Disinherit the priority, remembering the previous
4071:FreeRTOS/Src/tasks.c **** 					priority to facilitate determining the subject task's
4072:FreeRTOS/Src/tasks.c **** 					state. */
4073:FreeRTOS/Src/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4074:FreeRTOS/Src/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4075:FreeRTOS/Src/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4076:FreeRTOS/Src/tasks.c **** 
4077:FreeRTOS/Src/tasks.c **** 					/* Only reset the event list item value if the value is not
4078:FreeRTOS/Src/tasks.c **** 					being used for anything else. */
4079:FreeRTOS/Src/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4080:FreeRTOS/Src/tasks.c **** 					{
4081:FreeRTOS/Src/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4082:FreeRTOS/Src/tasks.c **** 					}
4083:FreeRTOS/Src/tasks.c **** 					else
4084:FreeRTOS/Src/tasks.c **** 					{
4085:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4086:FreeRTOS/Src/tasks.c **** 					}
4087:FreeRTOS/Src/tasks.c **** 
4088:FreeRTOS/Src/tasks.c **** 					/* If the running task is not the task that holds the mutex
4089:FreeRTOS/Src/tasks.c **** 					then the task that holds the mutex could be in either the
4090:FreeRTOS/Src/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4091:FreeRTOS/Src/tasks.c **** 					from its current state list if it is in the Ready state as
4092:FreeRTOS/Src/tasks.c **** 					the task's priority is going to change and there is one
4093:FreeRTOS/Src/tasks.c **** 					Ready list per priority. */
4094:FreeRTOS/Src/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4095:FreeRTOS/Src/tasks.c **** 					{
4096:FreeRTOS/Src/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 84


4097:FreeRTOS/Src/tasks.c **** 						{
4098:FreeRTOS/Src/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4099:FreeRTOS/Src/tasks.c **** 						}
4100:FreeRTOS/Src/tasks.c **** 						else
4101:FreeRTOS/Src/tasks.c **** 						{
4102:FreeRTOS/Src/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4103:FreeRTOS/Src/tasks.c **** 						}
4104:FreeRTOS/Src/tasks.c **** 
4105:FreeRTOS/Src/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4106:FreeRTOS/Src/tasks.c **** 					}
4107:FreeRTOS/Src/tasks.c **** 					else
4108:FreeRTOS/Src/tasks.c **** 					{
4109:FreeRTOS/Src/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4110:FreeRTOS/Src/tasks.c **** 					}
4111:FreeRTOS/Src/tasks.c **** 				}
4112:FreeRTOS/Src/tasks.c **** 				else
4113:FreeRTOS/Src/tasks.c **** 				{
4114:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4115:FreeRTOS/Src/tasks.c **** 				}
4116:FreeRTOS/Src/tasks.c **** 			}
4117:FreeRTOS/Src/tasks.c **** 			else
4118:FreeRTOS/Src/tasks.c **** 			{
4119:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4120:FreeRTOS/Src/tasks.c **** 			}
4121:FreeRTOS/Src/tasks.c **** 		}
4122:FreeRTOS/Src/tasks.c **** 		else
4123:FreeRTOS/Src/tasks.c **** 		{
4124:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4125:FreeRTOS/Src/tasks.c **** 		}
4126:FreeRTOS/Src/tasks.c **** 	}
4127:FreeRTOS/Src/tasks.c **** 
4128:FreeRTOS/Src/tasks.c **** #endif /* configUSE_MUTEXES */
4129:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4130:FreeRTOS/Src/tasks.c **** 
4131:FreeRTOS/Src/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4132:FreeRTOS/Src/tasks.c **** 
4133:FreeRTOS/Src/tasks.c **** 	void vTaskEnterCritical( void )
4134:FreeRTOS/Src/tasks.c **** 	{
4135:FreeRTOS/Src/tasks.c **** 		portDISABLE_INTERRUPTS();
4136:FreeRTOS/Src/tasks.c **** 
4137:FreeRTOS/Src/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4138:FreeRTOS/Src/tasks.c **** 		{
4139:FreeRTOS/Src/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4140:FreeRTOS/Src/tasks.c **** 
4141:FreeRTOS/Src/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4142:FreeRTOS/Src/tasks.c **** 			function so	assert() if it is being called from an interrupt
4143:FreeRTOS/Src/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4144:FreeRTOS/Src/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4145:FreeRTOS/Src/tasks.c **** 			protect against recursive calls if the assert function also uses a
4146:FreeRTOS/Src/tasks.c **** 			critical section. */
4147:FreeRTOS/Src/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4148:FreeRTOS/Src/tasks.c **** 			{
4149:FreeRTOS/Src/tasks.c **** 				portASSERT_IF_IN_ISR();
4150:FreeRTOS/Src/tasks.c **** 			}
4151:FreeRTOS/Src/tasks.c **** 		}
4152:FreeRTOS/Src/tasks.c **** 		else
4153:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 85


4154:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4155:FreeRTOS/Src/tasks.c **** 		}
4156:FreeRTOS/Src/tasks.c **** 	}
4157:FreeRTOS/Src/tasks.c **** 
4158:FreeRTOS/Src/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4159:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4160:FreeRTOS/Src/tasks.c **** 
4161:FreeRTOS/Src/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4162:FreeRTOS/Src/tasks.c **** 
4163:FreeRTOS/Src/tasks.c **** 	void vTaskExitCritical( void )
4164:FreeRTOS/Src/tasks.c **** 	{
4165:FreeRTOS/Src/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4166:FreeRTOS/Src/tasks.c **** 		{
4167:FreeRTOS/Src/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4168:FreeRTOS/Src/tasks.c **** 			{
4169:FreeRTOS/Src/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4170:FreeRTOS/Src/tasks.c **** 
4171:FreeRTOS/Src/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4172:FreeRTOS/Src/tasks.c **** 				{
4173:FreeRTOS/Src/tasks.c **** 					portENABLE_INTERRUPTS();
4174:FreeRTOS/Src/tasks.c **** 				}
4175:FreeRTOS/Src/tasks.c **** 				else
4176:FreeRTOS/Src/tasks.c **** 				{
4177:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4178:FreeRTOS/Src/tasks.c **** 				}
4179:FreeRTOS/Src/tasks.c **** 			}
4180:FreeRTOS/Src/tasks.c **** 			else
4181:FreeRTOS/Src/tasks.c **** 			{
4182:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4183:FreeRTOS/Src/tasks.c **** 			}
4184:FreeRTOS/Src/tasks.c **** 		}
4185:FreeRTOS/Src/tasks.c **** 		else
4186:FreeRTOS/Src/tasks.c **** 		{
4187:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4188:FreeRTOS/Src/tasks.c **** 		}
4189:FreeRTOS/Src/tasks.c **** 	}
4190:FreeRTOS/Src/tasks.c **** 
4191:FreeRTOS/Src/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4192:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4193:FreeRTOS/Src/tasks.c **** 
4194:FreeRTOS/Src/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4195:FreeRTOS/Src/tasks.c **** 
4196:FreeRTOS/Src/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4197:FreeRTOS/Src/tasks.c **** 	{
4198:FreeRTOS/Src/tasks.c **** 	size_t x;
4199:FreeRTOS/Src/tasks.c **** 
4200:FreeRTOS/Src/tasks.c **** 		/* Start by copying the entire string. */
4201:FreeRTOS/Src/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4202:FreeRTOS/Src/tasks.c **** 
4203:FreeRTOS/Src/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4204:FreeRTOS/Src/tasks.c **** 		printed out. */
4205:FreeRTOS/Src/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4206:FreeRTOS/Src/tasks.c **** 		{
4207:FreeRTOS/Src/tasks.c **** 			pcBuffer[ x ] = ' ';
4208:FreeRTOS/Src/tasks.c **** 		}
4209:FreeRTOS/Src/tasks.c **** 
4210:FreeRTOS/Src/tasks.c **** 		/* Terminate. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 86


4211:FreeRTOS/Src/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4212:FreeRTOS/Src/tasks.c **** 
4213:FreeRTOS/Src/tasks.c **** 		/* Return the new end of string. */
4214:FreeRTOS/Src/tasks.c **** 		return &( pcBuffer[ x ] );
4215:FreeRTOS/Src/tasks.c **** 	}
4216:FreeRTOS/Src/tasks.c **** 
4217:FreeRTOS/Src/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4218:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4219:FreeRTOS/Src/tasks.c **** 
4220:FreeRTOS/Src/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4221:FreeRTOS/Src/tasks.c **** 
4222:FreeRTOS/Src/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4223:FreeRTOS/Src/tasks.c **** 	{
4224:FreeRTOS/Src/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4225:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxArraySize, x;
4226:FreeRTOS/Src/tasks.c **** 	char cStatus;
4227:FreeRTOS/Src/tasks.c **** 
4228:FreeRTOS/Src/tasks.c **** 		/*
4229:FreeRTOS/Src/tasks.c **** 		 * PLEASE NOTE:
4230:FreeRTOS/Src/tasks.c **** 		 *
4231:FreeRTOS/Src/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4232:FreeRTOS/Src/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4233:FreeRTOS/Src/tasks.c **** 		 * scheduler.
4234:FreeRTOS/Src/tasks.c **** 		 *
4235:FreeRTOS/Src/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4236:FreeRTOS/Src/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4237:FreeRTOS/Src/tasks.c **** 		 * displays task names, states and stack usage.
4238:FreeRTOS/Src/tasks.c **** 		 *
4239:FreeRTOS/Src/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4240:FreeRTOS/Src/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4241:FreeRTOS/Src/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4242:FreeRTOS/Src/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4243:FreeRTOS/Src/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4244:FreeRTOS/Src/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4245:FreeRTOS/Src/tasks.c **** 		 * snprintf() implementation!).
4246:FreeRTOS/Src/tasks.c **** 		 *
4247:FreeRTOS/Src/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4248:FreeRTOS/Src/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4249:FreeRTOS/Src/tasks.c **** 		 * through a call to vTaskList().
4250:FreeRTOS/Src/tasks.c **** 		 */
4251:FreeRTOS/Src/tasks.c **** 
4252:FreeRTOS/Src/tasks.c **** 
4253:FreeRTOS/Src/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4254:FreeRTOS/Src/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4255:FreeRTOS/Src/tasks.c **** 
4256:FreeRTOS/Src/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4257:FreeRTOS/Src/tasks.c **** 		function is executing. */
4258:FreeRTOS/Src/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4259:FreeRTOS/Src/tasks.c **** 
4260:FreeRTOS/Src/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4261:FreeRTOS/Src/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4262:FreeRTOS/Src/tasks.c **** 		equate to NULL. */
4263:FreeRTOS/Src/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4264:FreeRTOS/Src/tasks.c **** 
4265:FreeRTOS/Src/tasks.c **** 		if( pxTaskStatusArray != NULL )
4266:FreeRTOS/Src/tasks.c **** 		{
4267:FreeRTOS/Src/tasks.c **** 			/* Generate the (binary) data. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 87


4268:FreeRTOS/Src/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4269:FreeRTOS/Src/tasks.c **** 
4270:FreeRTOS/Src/tasks.c **** 			/* Create a human readable table from the binary data. */
4271:FreeRTOS/Src/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4272:FreeRTOS/Src/tasks.c **** 			{
4273:FreeRTOS/Src/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4274:FreeRTOS/Src/tasks.c **** 				{
4275:FreeRTOS/Src/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4276:FreeRTOS/Src/tasks.c **** 										break;
4277:FreeRTOS/Src/tasks.c **** 
4278:FreeRTOS/Src/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4279:FreeRTOS/Src/tasks.c **** 										break;
4280:FreeRTOS/Src/tasks.c **** 
4281:FreeRTOS/Src/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4282:FreeRTOS/Src/tasks.c **** 										break;
4283:FreeRTOS/Src/tasks.c **** 
4284:FreeRTOS/Src/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4285:FreeRTOS/Src/tasks.c **** 										break;
4286:FreeRTOS/Src/tasks.c **** 
4287:FreeRTOS/Src/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4288:FreeRTOS/Src/tasks.c **** 										break;
4289:FreeRTOS/Src/tasks.c **** 
4290:FreeRTOS/Src/tasks.c **** 					case eInvalid:		/* Fall through. */
4291:FreeRTOS/Src/tasks.c **** 					default:			/* Should not get here, but it is included
4292:FreeRTOS/Src/tasks.c **** 										to prevent static checking errors. */
4293:FreeRTOS/Src/tasks.c **** 										cStatus = ( char ) 0x00;
4294:FreeRTOS/Src/tasks.c **** 										break;
4295:FreeRTOS/Src/tasks.c **** 				}
4296:FreeRTOS/Src/tasks.c **** 
4297:FreeRTOS/Src/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4298:FreeRTOS/Src/tasks.c **** 				can be printed in tabular form more easily. */
4299:FreeRTOS/Src/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4300:FreeRTOS/Src/tasks.c **** 
4301:FreeRTOS/Src/tasks.c **** 				/* Write the rest of the string. */
4302:FreeRTOS/Src/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4303:FreeRTOS/Src/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4304:FreeRTOS/Src/tasks.c **** 			}
4305:FreeRTOS/Src/tasks.c **** 
4306:FreeRTOS/Src/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4307:FreeRTOS/Src/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4308:FreeRTOS/Src/tasks.c **** 			vPortFree( pxTaskStatusArray );
4309:FreeRTOS/Src/tasks.c **** 		}
4310:FreeRTOS/Src/tasks.c **** 		else
4311:FreeRTOS/Src/tasks.c **** 		{
4312:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4313:FreeRTOS/Src/tasks.c **** 		}
4314:FreeRTOS/Src/tasks.c **** 	}
4315:FreeRTOS/Src/tasks.c **** 
4316:FreeRTOS/Src/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4317:FreeRTOS/Src/tasks.c **** /*----------------------------------------------------------*/
4318:FreeRTOS/Src/tasks.c **** 
4319:FreeRTOS/Src/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4320:FreeRTOS/Src/tasks.c **** 
4321:FreeRTOS/Src/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4322:FreeRTOS/Src/tasks.c **** 	{
4323:FreeRTOS/Src/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4324:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxArraySize, x;
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 88


4325:FreeRTOS/Src/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4326:FreeRTOS/Src/tasks.c **** 
4327:FreeRTOS/Src/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4328:FreeRTOS/Src/tasks.c **** 		{
4329:FreeRTOS/Src/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4330:FreeRTOS/Src/tasks.c **** 		}
4331:FreeRTOS/Src/tasks.c **** 		#endif
4332:FreeRTOS/Src/tasks.c **** 
4333:FreeRTOS/Src/tasks.c **** 		/*
4334:FreeRTOS/Src/tasks.c **** 		 * PLEASE NOTE:
4335:FreeRTOS/Src/tasks.c **** 		 *
4336:FreeRTOS/Src/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4337:FreeRTOS/Src/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4338:FreeRTOS/Src/tasks.c **** 		 * scheduler.
4339:FreeRTOS/Src/tasks.c **** 		 *
4340:FreeRTOS/Src/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4341:FreeRTOS/Src/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4342:FreeRTOS/Src/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4343:FreeRTOS/Src/tasks.c **** 		 * in both absolute and percentage terms.
4344:FreeRTOS/Src/tasks.c **** 		 *
4345:FreeRTOS/Src/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4346:FreeRTOS/Src/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4347:FreeRTOS/Src/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4348:FreeRTOS/Src/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4349:FreeRTOS/Src/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4350:FreeRTOS/Src/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4351:FreeRTOS/Src/tasks.c **** 		 * a full snprintf() implementation!).
4352:FreeRTOS/Src/tasks.c **** 		 *
4353:FreeRTOS/Src/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4354:FreeRTOS/Src/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4355:FreeRTOS/Src/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4356:FreeRTOS/Src/tasks.c **** 		 */
4357:FreeRTOS/Src/tasks.c **** 
4358:FreeRTOS/Src/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4359:FreeRTOS/Src/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4360:FreeRTOS/Src/tasks.c **** 
4361:FreeRTOS/Src/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4362:FreeRTOS/Src/tasks.c **** 		function is executing. */
4363:FreeRTOS/Src/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4364:FreeRTOS/Src/tasks.c **** 
4365:FreeRTOS/Src/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4366:FreeRTOS/Src/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4367:FreeRTOS/Src/tasks.c **** 		equate to NULL. */
4368:FreeRTOS/Src/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4369:FreeRTOS/Src/tasks.c **** 
4370:FreeRTOS/Src/tasks.c **** 		if( pxTaskStatusArray != NULL )
4371:FreeRTOS/Src/tasks.c **** 		{
4372:FreeRTOS/Src/tasks.c **** 			/* Generate the (binary) data. */
4373:FreeRTOS/Src/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4374:FreeRTOS/Src/tasks.c **** 
4375:FreeRTOS/Src/tasks.c **** 			/* For percentage calculations. */
4376:FreeRTOS/Src/tasks.c **** 			ulTotalTime /= 100UL;
4377:FreeRTOS/Src/tasks.c **** 
4378:FreeRTOS/Src/tasks.c **** 			/* Avoid divide by zero errors. */
4379:FreeRTOS/Src/tasks.c **** 			if( ulTotalTime > 0UL )
4380:FreeRTOS/Src/tasks.c **** 			{
4381:FreeRTOS/Src/tasks.c **** 				/* Create a human readable table from the binary data. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 89


4382:FreeRTOS/Src/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4383:FreeRTOS/Src/tasks.c **** 				{
4384:FreeRTOS/Src/tasks.c **** 					/* What percentage of the total run time has the task used?
4385:FreeRTOS/Src/tasks.c **** 					This will always be rounded down to the nearest integer.
4386:FreeRTOS/Src/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4387:FreeRTOS/Src/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4388:FreeRTOS/Src/tasks.c **** 
4389:FreeRTOS/Src/tasks.c **** 					/* Write the task name to the string, padding with
4390:FreeRTOS/Src/tasks.c **** 					spaces so it can be printed in tabular form more
4391:FreeRTOS/Src/tasks.c **** 					easily. */
4392:FreeRTOS/Src/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4393:FreeRTOS/Src/tasks.c **** 
4394:FreeRTOS/Src/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4395:FreeRTOS/Src/tasks.c **** 					{
4396:FreeRTOS/Src/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4397:FreeRTOS/Src/tasks.c **** 						{
4398:FreeRTOS/Src/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4399:FreeRTOS/Src/tasks.c **** 						}
4400:FreeRTOS/Src/tasks.c **** 						#else
4401:FreeRTOS/Src/tasks.c **** 						{
4402:FreeRTOS/Src/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4403:FreeRTOS/Src/tasks.c **** 							printf() library can be used. */
4404:FreeRTOS/Src/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4405:FreeRTOS/Src/tasks.c **** 						}
4406:FreeRTOS/Src/tasks.c **** 						#endif
4407:FreeRTOS/Src/tasks.c **** 					}
4408:FreeRTOS/Src/tasks.c **** 					else
4409:FreeRTOS/Src/tasks.c **** 					{
4410:FreeRTOS/Src/tasks.c **** 						/* If the percentage is zero here then the task has
4411:FreeRTOS/Src/tasks.c **** 						consumed less than 1% of the total run time. */
4412:FreeRTOS/Src/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4413:FreeRTOS/Src/tasks.c **** 						{
4414:FreeRTOS/Src/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4415:FreeRTOS/Src/tasks.c **** 						}
4416:FreeRTOS/Src/tasks.c **** 						#else
4417:FreeRTOS/Src/tasks.c **** 						{
4418:FreeRTOS/Src/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4419:FreeRTOS/Src/tasks.c **** 							printf() library can be used. */
4420:FreeRTOS/Src/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4421:FreeRTOS/Src/tasks.c **** 						}
4422:FreeRTOS/Src/tasks.c **** 						#endif
4423:FreeRTOS/Src/tasks.c **** 					}
4424:FreeRTOS/Src/tasks.c **** 
4425:FreeRTOS/Src/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4426:FreeRTOS/Src/tasks.c **** 				}
4427:FreeRTOS/Src/tasks.c **** 			}
4428:FreeRTOS/Src/tasks.c **** 			else
4429:FreeRTOS/Src/tasks.c **** 			{
4430:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4431:FreeRTOS/Src/tasks.c **** 			}
4432:FreeRTOS/Src/tasks.c **** 
4433:FreeRTOS/Src/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4434:FreeRTOS/Src/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4435:FreeRTOS/Src/tasks.c **** 			vPortFree( pxTaskStatusArray );
4436:FreeRTOS/Src/tasks.c **** 		}
4437:FreeRTOS/Src/tasks.c **** 		else
4438:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 90


4439:FreeRTOS/Src/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4440:FreeRTOS/Src/tasks.c **** 		}
4441:FreeRTOS/Src/tasks.c **** 	}
4442:FreeRTOS/Src/tasks.c **** 
4443:FreeRTOS/Src/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4444:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4445:FreeRTOS/Src/tasks.c **** 
4446:FreeRTOS/Src/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4447:FreeRTOS/Src/tasks.c **** {
4448:FreeRTOS/Src/tasks.c **** TickType_t uxReturn;
4449:FreeRTOS/Src/tasks.c **** 
4450:FreeRTOS/Src/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4451:FreeRTOS/Src/tasks.c **** 
4452:FreeRTOS/Src/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4453:FreeRTOS/Src/tasks.c **** 	queues and semaphores. */
4454:FreeRTOS/Src/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4455:FreeRTOS/Src/tasks.c **** 
4456:FreeRTOS/Src/tasks.c **** 	return uxReturn;
4457:FreeRTOS/Src/tasks.c **** }
4458:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4459:FreeRTOS/Src/tasks.c **** 
4460:FreeRTOS/Src/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4461:FreeRTOS/Src/tasks.c **** 
4462:FreeRTOS/Src/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4463:FreeRTOS/Src/tasks.c **** 	{
4464:FreeRTOS/Src/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4465:FreeRTOS/Src/tasks.c **** 		then pxCurrentTCB will be NULL. */
4466:FreeRTOS/Src/tasks.c **** 		if( pxCurrentTCB != NULL )
4467:FreeRTOS/Src/tasks.c **** 		{
4468:FreeRTOS/Src/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4469:FreeRTOS/Src/tasks.c **** 		}
4470:FreeRTOS/Src/tasks.c **** 
4471:FreeRTOS/Src/tasks.c **** 		return pxCurrentTCB;
4472:FreeRTOS/Src/tasks.c **** 	}
4473:FreeRTOS/Src/tasks.c **** 
4474:FreeRTOS/Src/tasks.c **** #endif /* configUSE_MUTEXES */
4475:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4476:FreeRTOS/Src/tasks.c **** 
4477:FreeRTOS/Src/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4478:FreeRTOS/Src/tasks.c **** 
4479:FreeRTOS/Src/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4480:FreeRTOS/Src/tasks.c **** 	{
4481:FreeRTOS/Src/tasks.c **** 	uint32_t ulReturn;
4482:FreeRTOS/Src/tasks.c **** 
4483:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
4484:FreeRTOS/Src/tasks.c **** 		{
4485:FreeRTOS/Src/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4486:FreeRTOS/Src/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4487:FreeRTOS/Src/tasks.c **** 			{
4488:FreeRTOS/Src/tasks.c **** 				/* Mark this task as waiting for a notification. */
4489:FreeRTOS/Src/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4490:FreeRTOS/Src/tasks.c **** 
4491:FreeRTOS/Src/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4492:FreeRTOS/Src/tasks.c **** 				{
4493:FreeRTOS/Src/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4494:FreeRTOS/Src/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4495:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 91


4496:FreeRTOS/Src/tasks.c **** 					/* All ports are written to allow a yield in a critical
4497:FreeRTOS/Src/tasks.c **** 					section (some will yield immediately, others wait until the
4498:FreeRTOS/Src/tasks.c **** 					critical section exits) - but it is not something that
4499:FreeRTOS/Src/tasks.c **** 					application code should ever do. */
4500:FreeRTOS/Src/tasks.c **** 					portYIELD_WITHIN_API();
4501:FreeRTOS/Src/tasks.c **** 				}
4502:FreeRTOS/Src/tasks.c **** 				else
4503:FreeRTOS/Src/tasks.c **** 				{
4504:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4505:FreeRTOS/Src/tasks.c **** 				}
4506:FreeRTOS/Src/tasks.c **** 			}
4507:FreeRTOS/Src/tasks.c **** 			else
4508:FreeRTOS/Src/tasks.c **** 			{
4509:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4510:FreeRTOS/Src/tasks.c **** 			}
4511:FreeRTOS/Src/tasks.c **** 		}
4512:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
4513:FreeRTOS/Src/tasks.c **** 
4514:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
4515:FreeRTOS/Src/tasks.c **** 		{
4516:FreeRTOS/Src/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4517:FreeRTOS/Src/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4518:FreeRTOS/Src/tasks.c **** 
4519:FreeRTOS/Src/tasks.c **** 			if( ulReturn != 0UL )
4520:FreeRTOS/Src/tasks.c **** 			{
4521:FreeRTOS/Src/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4522:FreeRTOS/Src/tasks.c **** 				{
4523:FreeRTOS/Src/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4524:FreeRTOS/Src/tasks.c **** 				}
4525:FreeRTOS/Src/tasks.c **** 				else
4526:FreeRTOS/Src/tasks.c **** 				{
4527:FreeRTOS/Src/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4528:FreeRTOS/Src/tasks.c **** 				}
4529:FreeRTOS/Src/tasks.c **** 			}
4530:FreeRTOS/Src/tasks.c **** 			else
4531:FreeRTOS/Src/tasks.c **** 			{
4532:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4533:FreeRTOS/Src/tasks.c **** 			}
4534:FreeRTOS/Src/tasks.c **** 
4535:FreeRTOS/Src/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4536:FreeRTOS/Src/tasks.c **** 		}
4537:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
4538:FreeRTOS/Src/tasks.c **** 
4539:FreeRTOS/Src/tasks.c **** 		return ulReturn;
4540:FreeRTOS/Src/tasks.c **** 	}
4541:FreeRTOS/Src/tasks.c **** 
4542:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4543:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4544:FreeRTOS/Src/tasks.c **** 
4545:FreeRTOS/Src/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4546:FreeRTOS/Src/tasks.c **** 
4547:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4548:FreeRTOS/Src/tasks.c **** 	{
4549:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
4550:FreeRTOS/Src/tasks.c **** 
4551:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
4552:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 92


4553:FreeRTOS/Src/tasks.c **** 			/* Only block if a notification is not already pending. */
4554:FreeRTOS/Src/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4555:FreeRTOS/Src/tasks.c **** 			{
4556:FreeRTOS/Src/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4557:FreeRTOS/Src/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4558:FreeRTOS/Src/tasks.c **** 				clear the value to zero. */
4559:FreeRTOS/Src/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4560:FreeRTOS/Src/tasks.c **** 
4561:FreeRTOS/Src/tasks.c **** 				/* Mark this task as waiting for a notification. */
4562:FreeRTOS/Src/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4563:FreeRTOS/Src/tasks.c **** 
4564:FreeRTOS/Src/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4565:FreeRTOS/Src/tasks.c **** 				{
4566:FreeRTOS/Src/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4567:FreeRTOS/Src/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4568:FreeRTOS/Src/tasks.c **** 
4569:FreeRTOS/Src/tasks.c **** 					/* All ports are written to allow a yield in a critical
4570:FreeRTOS/Src/tasks.c **** 					section (some will yield immediately, others wait until the
4571:FreeRTOS/Src/tasks.c **** 					critical section exits) - but it is not something that
4572:FreeRTOS/Src/tasks.c **** 					application code should ever do. */
4573:FreeRTOS/Src/tasks.c **** 					portYIELD_WITHIN_API();
4574:FreeRTOS/Src/tasks.c **** 				}
4575:FreeRTOS/Src/tasks.c **** 				else
4576:FreeRTOS/Src/tasks.c **** 				{
4577:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4578:FreeRTOS/Src/tasks.c **** 				}
4579:FreeRTOS/Src/tasks.c **** 			}
4580:FreeRTOS/Src/tasks.c **** 			else
4581:FreeRTOS/Src/tasks.c **** 			{
4582:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4583:FreeRTOS/Src/tasks.c **** 			}
4584:FreeRTOS/Src/tasks.c **** 		}
4585:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
4586:FreeRTOS/Src/tasks.c **** 
4587:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
4588:FreeRTOS/Src/tasks.c **** 		{
4589:FreeRTOS/Src/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4590:FreeRTOS/Src/tasks.c **** 
4591:FreeRTOS/Src/tasks.c **** 			if( pulNotificationValue != NULL )
4592:FreeRTOS/Src/tasks.c **** 			{
4593:FreeRTOS/Src/tasks.c **** 				/* Output the current notification value, which may or may not
4594:FreeRTOS/Src/tasks.c **** 				have changed. */
4595:FreeRTOS/Src/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4596:FreeRTOS/Src/tasks.c **** 			}
4597:FreeRTOS/Src/tasks.c **** 
4598:FreeRTOS/Src/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4599:FreeRTOS/Src/tasks.c **** 			blocked state (because a notification was already pending) or the
4600:FreeRTOS/Src/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4601:FreeRTOS/Src/tasks.c **** 			unblocked because of a timeout. */
4602:FreeRTOS/Src/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4603:FreeRTOS/Src/tasks.c **** 			{
4604:FreeRTOS/Src/tasks.c **** 				/* A notification was not received. */
4605:FreeRTOS/Src/tasks.c **** 				xReturn = pdFALSE;
4606:FreeRTOS/Src/tasks.c **** 			}
4607:FreeRTOS/Src/tasks.c **** 			else
4608:FreeRTOS/Src/tasks.c **** 			{
4609:FreeRTOS/Src/tasks.c **** 				/* A notification was already pending or a notification was
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 93


4610:FreeRTOS/Src/tasks.c **** 				received while the task was waiting. */
4611:FreeRTOS/Src/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4612:FreeRTOS/Src/tasks.c **** 				xReturn = pdTRUE;
4613:FreeRTOS/Src/tasks.c **** 			}
4614:FreeRTOS/Src/tasks.c **** 
4615:FreeRTOS/Src/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4616:FreeRTOS/Src/tasks.c **** 		}
4617:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
4618:FreeRTOS/Src/tasks.c **** 
4619:FreeRTOS/Src/tasks.c **** 		return xReturn;
4620:FreeRTOS/Src/tasks.c **** 	}
4621:FreeRTOS/Src/tasks.c **** 
4622:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4623:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4624:FreeRTOS/Src/tasks.c **** 
4625:FreeRTOS/Src/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4626:FreeRTOS/Src/tasks.c **** 
4627:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4628:FreeRTOS/Src/tasks.c **** 	{
4629:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
4630:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = pdPASS;
4631:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
4632:FreeRTOS/Src/tasks.c **** 
4633:FreeRTOS/Src/tasks.c **** 		configASSERT( xTaskToNotify );
4634:FreeRTOS/Src/tasks.c **** 		pxTCB = xTaskToNotify;
4635:FreeRTOS/Src/tasks.c **** 
4636:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
4637:FreeRTOS/Src/tasks.c **** 		{
4638:FreeRTOS/Src/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4639:FreeRTOS/Src/tasks.c **** 			{
4640:FreeRTOS/Src/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4641:FreeRTOS/Src/tasks.c **** 			}
4642:FreeRTOS/Src/tasks.c **** 
4643:FreeRTOS/Src/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4644:FreeRTOS/Src/tasks.c **** 
4645:FreeRTOS/Src/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4646:FreeRTOS/Src/tasks.c **** 
4647:FreeRTOS/Src/tasks.c **** 			switch( eAction )
4648:FreeRTOS/Src/tasks.c **** 			{
4649:FreeRTOS/Src/tasks.c **** 				case eSetBits	:
4650:FreeRTOS/Src/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4651:FreeRTOS/Src/tasks.c **** 					break;
4652:FreeRTOS/Src/tasks.c **** 
4653:FreeRTOS/Src/tasks.c **** 				case eIncrement	:
4654:FreeRTOS/Src/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4655:FreeRTOS/Src/tasks.c **** 					break;
4656:FreeRTOS/Src/tasks.c **** 
4657:FreeRTOS/Src/tasks.c **** 				case eSetValueWithOverwrite	:
4658:FreeRTOS/Src/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4659:FreeRTOS/Src/tasks.c **** 					break;
4660:FreeRTOS/Src/tasks.c **** 
4661:FreeRTOS/Src/tasks.c **** 				case eSetValueWithoutOverwrite :
4662:FreeRTOS/Src/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4663:FreeRTOS/Src/tasks.c **** 					{
4664:FreeRTOS/Src/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4665:FreeRTOS/Src/tasks.c **** 					}
4666:FreeRTOS/Src/tasks.c **** 					else
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 94


4667:FreeRTOS/Src/tasks.c **** 					{
4668:FreeRTOS/Src/tasks.c **** 						/* The value could not be written to the task. */
4669:FreeRTOS/Src/tasks.c **** 						xReturn = pdFAIL;
4670:FreeRTOS/Src/tasks.c **** 					}
4671:FreeRTOS/Src/tasks.c **** 					break;
4672:FreeRTOS/Src/tasks.c **** 
4673:FreeRTOS/Src/tasks.c **** 				case eNoAction:
4674:FreeRTOS/Src/tasks.c **** 					/* The task is being notified without its notify value being
4675:FreeRTOS/Src/tasks.c **** 					updated. */
4676:FreeRTOS/Src/tasks.c **** 					break;
4677:FreeRTOS/Src/tasks.c **** 
4678:FreeRTOS/Src/tasks.c **** 				default:
4679:FreeRTOS/Src/tasks.c **** 					/* Should not get here if all enums are handled.
4680:FreeRTOS/Src/tasks.c **** 					Artificially force an assert by testing a value the
4681:FreeRTOS/Src/tasks.c **** 					compiler can't assume is const. */
4682:FreeRTOS/Src/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4683:FreeRTOS/Src/tasks.c **** 
4684:FreeRTOS/Src/tasks.c **** 					break;
4685:FreeRTOS/Src/tasks.c **** 			}
4686:FreeRTOS/Src/tasks.c **** 
4687:FreeRTOS/Src/tasks.c **** 			traceTASK_NOTIFY();
4688:FreeRTOS/Src/tasks.c **** 
4689:FreeRTOS/Src/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4690:FreeRTOS/Src/tasks.c **** 			notification then unblock it now. */
4691:FreeRTOS/Src/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4692:FreeRTOS/Src/tasks.c **** 			{
4693:FreeRTOS/Src/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4694:FreeRTOS/Src/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4695:FreeRTOS/Src/tasks.c **** 
4696:FreeRTOS/Src/tasks.c **** 				/* The task should not have been on an event list. */
4697:FreeRTOS/Src/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4698:FreeRTOS/Src/tasks.c **** 
4699:FreeRTOS/Src/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4700:FreeRTOS/Src/tasks.c **** 				{
4701:FreeRTOS/Src/tasks.c **** 					/* If a task is blocked waiting for a notification then
4702:FreeRTOS/Src/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4703:FreeRTOS/Src/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4704:FreeRTOS/Src/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4705:FreeRTOS/Src/tasks.c **** 					because it will automatically get reset to a new value when
4706:FreeRTOS/Src/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4707:FreeRTOS/Src/tasks.c **** 					tickless idling is used it might be more important to enter
4708:FreeRTOS/Src/tasks.c **** 					sleep mode at the earliest possible time - so reset
4709:FreeRTOS/Src/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4710:FreeRTOS/Src/tasks.c **** 					earliest possible time. */
4711:FreeRTOS/Src/tasks.c **** 					prvResetNextTaskUnblockTime();
4712:FreeRTOS/Src/tasks.c **** 				}
4713:FreeRTOS/Src/tasks.c **** 				#endif
4714:FreeRTOS/Src/tasks.c **** 
4715:FreeRTOS/Src/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4716:FreeRTOS/Src/tasks.c **** 				{
4717:FreeRTOS/Src/tasks.c **** 					/* The notified task has a priority above the currently
4718:FreeRTOS/Src/tasks.c **** 					executing task so a yield is required. */
4719:FreeRTOS/Src/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4720:FreeRTOS/Src/tasks.c **** 				}
4721:FreeRTOS/Src/tasks.c **** 				else
4722:FreeRTOS/Src/tasks.c **** 				{
4723:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 95


4724:FreeRTOS/Src/tasks.c **** 				}
4725:FreeRTOS/Src/tasks.c **** 			}
4726:FreeRTOS/Src/tasks.c **** 			else
4727:FreeRTOS/Src/tasks.c **** 			{
4728:FreeRTOS/Src/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4729:FreeRTOS/Src/tasks.c **** 			}
4730:FreeRTOS/Src/tasks.c **** 		}
4731:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
4732:FreeRTOS/Src/tasks.c **** 
4733:FreeRTOS/Src/tasks.c **** 		return xReturn;
4734:FreeRTOS/Src/tasks.c **** 	}
4735:FreeRTOS/Src/tasks.c **** 
4736:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4737:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4738:FreeRTOS/Src/tasks.c **** 
4739:FreeRTOS/Src/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4740:FreeRTOS/Src/tasks.c **** 
4741:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4742:FreeRTOS/Src/tasks.c **** 	{
4743:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
4744:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
4745:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn = pdPASS;
4746:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4747:FreeRTOS/Src/tasks.c **** 
4748:FreeRTOS/Src/tasks.c **** 		configASSERT( xTaskToNotify );
4749:FreeRTOS/Src/tasks.c **** 
4750:FreeRTOS/Src/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4751:FreeRTOS/Src/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4752:FreeRTOS/Src/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4753:FreeRTOS/Src/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4754:FreeRTOS/Src/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4755:FreeRTOS/Src/tasks.c **** 		is defined in FreeRTOSConfig.h then
4756:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4757:FreeRTOS/Src/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4758:FreeRTOS/Src/tasks.c **** 		been assigned a priority above the configured maximum system call
4759:FreeRTOS/Src/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4760:FreeRTOS/Src/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4761:FreeRTOS/Src/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4762:FreeRTOS/Src/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4763:FreeRTOS/Src/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4764:FreeRTOS/Src/tasks.c **** 		provided on the following link:
4765:FreeRTOS/Src/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4766:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4767:FreeRTOS/Src/tasks.c **** 
4768:FreeRTOS/Src/tasks.c **** 		pxTCB = xTaskToNotify;
4769:FreeRTOS/Src/tasks.c **** 
4770:FreeRTOS/Src/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4771:FreeRTOS/Src/tasks.c **** 		{
4772:FreeRTOS/Src/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4773:FreeRTOS/Src/tasks.c **** 			{
4774:FreeRTOS/Src/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4775:FreeRTOS/Src/tasks.c **** 			}
4776:FreeRTOS/Src/tasks.c **** 
4777:FreeRTOS/Src/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4778:FreeRTOS/Src/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4779:FreeRTOS/Src/tasks.c **** 
4780:FreeRTOS/Src/tasks.c **** 			switch( eAction )
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 96


4781:FreeRTOS/Src/tasks.c **** 			{
4782:FreeRTOS/Src/tasks.c **** 				case eSetBits	:
4783:FreeRTOS/Src/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4784:FreeRTOS/Src/tasks.c **** 					break;
4785:FreeRTOS/Src/tasks.c **** 
4786:FreeRTOS/Src/tasks.c **** 				case eIncrement	:
4787:FreeRTOS/Src/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4788:FreeRTOS/Src/tasks.c **** 					break;
4789:FreeRTOS/Src/tasks.c **** 
4790:FreeRTOS/Src/tasks.c **** 				case eSetValueWithOverwrite	:
4791:FreeRTOS/Src/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4792:FreeRTOS/Src/tasks.c **** 					break;
4793:FreeRTOS/Src/tasks.c **** 
4794:FreeRTOS/Src/tasks.c **** 				case eSetValueWithoutOverwrite :
4795:FreeRTOS/Src/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4796:FreeRTOS/Src/tasks.c **** 					{
4797:FreeRTOS/Src/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4798:FreeRTOS/Src/tasks.c **** 					}
4799:FreeRTOS/Src/tasks.c **** 					else
4800:FreeRTOS/Src/tasks.c **** 					{
4801:FreeRTOS/Src/tasks.c **** 						/* The value could not be written to the task. */
4802:FreeRTOS/Src/tasks.c **** 						xReturn = pdFAIL;
4803:FreeRTOS/Src/tasks.c **** 					}
4804:FreeRTOS/Src/tasks.c **** 					break;
4805:FreeRTOS/Src/tasks.c **** 
4806:FreeRTOS/Src/tasks.c **** 				case eNoAction :
4807:FreeRTOS/Src/tasks.c **** 					/* The task is being notified without its notify value being
4808:FreeRTOS/Src/tasks.c **** 					updated. */
4809:FreeRTOS/Src/tasks.c **** 					break;
4810:FreeRTOS/Src/tasks.c **** 
4811:FreeRTOS/Src/tasks.c **** 				default:
4812:FreeRTOS/Src/tasks.c **** 					/* Should not get here if all enums are handled.
4813:FreeRTOS/Src/tasks.c **** 					Artificially force an assert by testing a value the
4814:FreeRTOS/Src/tasks.c **** 					compiler can't assume is const. */
4815:FreeRTOS/Src/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4816:FreeRTOS/Src/tasks.c **** 					break;
4817:FreeRTOS/Src/tasks.c **** 			}
4818:FreeRTOS/Src/tasks.c **** 
4819:FreeRTOS/Src/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4820:FreeRTOS/Src/tasks.c **** 
4821:FreeRTOS/Src/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4822:FreeRTOS/Src/tasks.c **** 			notification then unblock it now. */
4823:FreeRTOS/Src/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4824:FreeRTOS/Src/tasks.c **** 			{
4825:FreeRTOS/Src/tasks.c **** 				/* The task should not have been on an event list. */
4826:FreeRTOS/Src/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4827:FreeRTOS/Src/tasks.c **** 
4828:FreeRTOS/Src/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4829:FreeRTOS/Src/tasks.c **** 				{
4830:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4831:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4832:FreeRTOS/Src/tasks.c **** 				}
4833:FreeRTOS/Src/tasks.c **** 				else
4834:FreeRTOS/Src/tasks.c **** 				{
4835:FreeRTOS/Src/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4836:FreeRTOS/Src/tasks.c **** 					this task pending until the scheduler is resumed. */
4837:FreeRTOS/Src/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 97


4838:FreeRTOS/Src/tasks.c **** 				}
4839:FreeRTOS/Src/tasks.c **** 
4840:FreeRTOS/Src/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4841:FreeRTOS/Src/tasks.c **** 				{
4842:FreeRTOS/Src/tasks.c **** 					/* The notified task has a priority above the currently
4843:FreeRTOS/Src/tasks.c **** 					executing task so a yield is required. */
4844:FreeRTOS/Src/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4845:FreeRTOS/Src/tasks.c **** 					{
4846:FreeRTOS/Src/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4847:FreeRTOS/Src/tasks.c **** 					}
4848:FreeRTOS/Src/tasks.c **** 
4849:FreeRTOS/Src/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4850:FreeRTOS/Src/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
4851:FreeRTOS/Src/tasks.c **** 					safe FreeRTOS function. */
4852:FreeRTOS/Src/tasks.c **** 					xYieldPending = pdTRUE;
4853:FreeRTOS/Src/tasks.c **** 				}
4854:FreeRTOS/Src/tasks.c **** 				else
4855:FreeRTOS/Src/tasks.c **** 				{
4856:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4857:FreeRTOS/Src/tasks.c **** 				}
4858:FreeRTOS/Src/tasks.c **** 			}
4859:FreeRTOS/Src/tasks.c **** 		}
4860:FreeRTOS/Src/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4861:FreeRTOS/Src/tasks.c **** 
4862:FreeRTOS/Src/tasks.c **** 		return xReturn;
4863:FreeRTOS/Src/tasks.c **** 	}
4864:FreeRTOS/Src/tasks.c **** 
4865:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4866:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4867:FreeRTOS/Src/tasks.c **** 
4868:FreeRTOS/Src/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4869:FreeRTOS/Src/tasks.c **** 
4870:FreeRTOS/Src/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4871:FreeRTOS/Src/tasks.c **** 	{
4872:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
4873:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
4874:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4875:FreeRTOS/Src/tasks.c **** 
4876:FreeRTOS/Src/tasks.c **** 		configASSERT( xTaskToNotify );
4877:FreeRTOS/Src/tasks.c **** 
4878:FreeRTOS/Src/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4879:FreeRTOS/Src/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4880:FreeRTOS/Src/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4881:FreeRTOS/Src/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4882:FreeRTOS/Src/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4883:FreeRTOS/Src/tasks.c **** 		is defined in FreeRTOSConfig.h then
4884:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4885:FreeRTOS/Src/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4886:FreeRTOS/Src/tasks.c **** 		been assigned a priority above the configured maximum system call
4887:FreeRTOS/Src/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4888:FreeRTOS/Src/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4889:FreeRTOS/Src/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4890:FreeRTOS/Src/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4891:FreeRTOS/Src/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4892:FreeRTOS/Src/tasks.c **** 		provided on the following link:
4893:FreeRTOS/Src/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4894:FreeRTOS/Src/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 98


4895:FreeRTOS/Src/tasks.c **** 
4896:FreeRTOS/Src/tasks.c **** 		pxTCB = xTaskToNotify;
4897:FreeRTOS/Src/tasks.c **** 
4898:FreeRTOS/Src/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4899:FreeRTOS/Src/tasks.c **** 		{
4900:FreeRTOS/Src/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4901:FreeRTOS/Src/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4902:FreeRTOS/Src/tasks.c **** 
4903:FreeRTOS/Src/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4904:FreeRTOS/Src/tasks.c **** 			semaphore. */
4905:FreeRTOS/Src/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4906:FreeRTOS/Src/tasks.c **** 
4907:FreeRTOS/Src/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4908:FreeRTOS/Src/tasks.c **** 
4909:FreeRTOS/Src/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4910:FreeRTOS/Src/tasks.c **** 			notification then unblock it now. */
4911:FreeRTOS/Src/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4912:FreeRTOS/Src/tasks.c **** 			{
4913:FreeRTOS/Src/tasks.c **** 				/* The task should not have been on an event list. */
4914:FreeRTOS/Src/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4915:FreeRTOS/Src/tasks.c **** 
4916:FreeRTOS/Src/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4917:FreeRTOS/Src/tasks.c **** 				{
4918:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4919:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4920:FreeRTOS/Src/tasks.c **** 				}
4921:FreeRTOS/Src/tasks.c **** 				else
4922:FreeRTOS/Src/tasks.c **** 				{
4923:FreeRTOS/Src/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4924:FreeRTOS/Src/tasks.c **** 					this task pending until the scheduler is resumed. */
4925:FreeRTOS/Src/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4926:FreeRTOS/Src/tasks.c **** 				}
4927:FreeRTOS/Src/tasks.c **** 
4928:FreeRTOS/Src/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4929:FreeRTOS/Src/tasks.c **** 				{
4930:FreeRTOS/Src/tasks.c **** 					/* The notified task has a priority above the currently
4931:FreeRTOS/Src/tasks.c **** 					executing task so a yield is required. */
4932:FreeRTOS/Src/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4933:FreeRTOS/Src/tasks.c **** 					{
4934:FreeRTOS/Src/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4935:FreeRTOS/Src/tasks.c **** 					}
4936:FreeRTOS/Src/tasks.c **** 
4937:FreeRTOS/Src/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4938:FreeRTOS/Src/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
4939:FreeRTOS/Src/tasks.c **** 					safe FreeRTOS function. */
4940:FreeRTOS/Src/tasks.c **** 					xYieldPending = pdTRUE;
4941:FreeRTOS/Src/tasks.c **** 				}
4942:FreeRTOS/Src/tasks.c **** 				else
4943:FreeRTOS/Src/tasks.c **** 				{
4944:FreeRTOS/Src/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4945:FreeRTOS/Src/tasks.c **** 				}
4946:FreeRTOS/Src/tasks.c **** 			}
4947:FreeRTOS/Src/tasks.c **** 		}
4948:FreeRTOS/Src/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4949:FreeRTOS/Src/tasks.c **** 	}
4950:FreeRTOS/Src/tasks.c **** 
4951:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 99


4952:FreeRTOS/Src/tasks.c **** 
4953:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4954:FreeRTOS/Src/tasks.c **** 
4955:FreeRTOS/Src/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4956:FreeRTOS/Src/tasks.c **** 
4957:FreeRTOS/Src/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4958:FreeRTOS/Src/tasks.c **** 	{
4959:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
4960:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
4961:FreeRTOS/Src/tasks.c **** 
4962:FreeRTOS/Src/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4963:FreeRTOS/Src/tasks.c **** 		its notification state cleared. */
4964:FreeRTOS/Src/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4965:FreeRTOS/Src/tasks.c **** 
4966:FreeRTOS/Src/tasks.c **** 		taskENTER_CRITICAL();
4967:FreeRTOS/Src/tasks.c **** 		{
4968:FreeRTOS/Src/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4969:FreeRTOS/Src/tasks.c **** 			{
4970:FreeRTOS/Src/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4971:FreeRTOS/Src/tasks.c **** 				xReturn = pdPASS;
4972:FreeRTOS/Src/tasks.c **** 			}
4973:FreeRTOS/Src/tasks.c **** 			else
4974:FreeRTOS/Src/tasks.c **** 			{
4975:FreeRTOS/Src/tasks.c **** 				xReturn = pdFAIL;
4976:FreeRTOS/Src/tasks.c **** 			}
4977:FreeRTOS/Src/tasks.c **** 		}
4978:FreeRTOS/Src/tasks.c **** 		taskEXIT_CRITICAL();
4979:FreeRTOS/Src/tasks.c **** 
4980:FreeRTOS/Src/tasks.c **** 		return xReturn;
4981:FreeRTOS/Src/tasks.c **** 	}
4982:FreeRTOS/Src/tasks.c **** 
4983:FreeRTOS/Src/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4984:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
4985:FreeRTOS/Src/tasks.c **** 
4986:FreeRTOS/Src/tasks.c **** 
4987:FreeRTOS/Src/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4988:FreeRTOS/Src/tasks.c **** {
 584              		.loc 1 4988 0
 585              		.cfi_startproc
 586              		@ args = 0, pretend = 0, frame = 0
 587              		@ frame_needed = 0, uses_anonymous_args = 0
 588              	.LVL52:
 589 0000 70B5     		push	{r4, r5, r6, lr}
 590              	.LCFI6:
 591              		.cfi_def_cfa_offset 16
 592              		.cfi_offset 4, -16
 593              		.cfi_offset 5, -12
 594              		.cfi_offset 6, -8
 595              		.cfi_offset 14, -4
 596 0002 0446     		mov	r4, r0
 597 0004 0E46     		mov	r6, r1
4989:FreeRTOS/Src/tasks.c **** TickType_t xTimeToWake;
4990:FreeRTOS/Src/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 598              		.loc 1 4990 0
 599 0006 1D4B     		ldr	r3, .L54
 600 0008 1D68     		ldr	r5, [r3]
 601              	.LVL53:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 100


4991:FreeRTOS/Src/tasks.c **** 
4992:FreeRTOS/Src/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4993:FreeRTOS/Src/tasks.c **** 	{
4994:FreeRTOS/Src/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4995:FreeRTOS/Src/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4996:FreeRTOS/Src/tasks.c **** 		when the task leaves the Blocked state. */
4997:FreeRTOS/Src/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4998:FreeRTOS/Src/tasks.c **** 	}
4999:FreeRTOS/Src/tasks.c **** 	#endif
5000:FreeRTOS/Src/tasks.c **** 
5001:FreeRTOS/Src/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5002:FreeRTOS/Src/tasks.c **** 	as the same list item is used for both lists. */
5003:FreeRTOS/Src/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 602              		.loc 1 5003 0
 603 000a 1D4B     		ldr	r3, .L54+4
 604 000c 1868     		ldr	r0, [r3]
 605              	.LVL54:
 606 000e 0430     		adds	r0, r0, #4
 607 0010 FFF7FEFF 		bl	uxListRemove
 608              	.LVL55:
 609 0014 50B9     		cbnz	r0, .L49
5004:FreeRTOS/Src/tasks.c **** 	{
5005:FreeRTOS/Src/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5006:FreeRTOS/Src/tasks.c **** 		check, and the port reset macro can be called directly. */
5007:FreeRTOS/Src/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
 610              		.loc 1 5007 0
 611 0016 1A4B     		ldr	r3, .L54+4
 612 0018 1B68     		ldr	r3, [r3]
 613 001a DA6A     		ldr	r2, [r3, #44]
 614 001c 0123     		movs	r3, #1
 615 001e 03FA02F2 		lsl	r2, r3, r2
 616 0022 1849     		ldr	r1, .L54+8
 617 0024 0B68     		ldr	r3, [r1]
 618 0026 23EA0203 		bic	r3, r3, r2
 619 002a 0B60     		str	r3, [r1]
 620              	.L49:
5008:FreeRTOS/Src/tasks.c **** 	}
5009:FreeRTOS/Src/tasks.c **** 	else
5010:FreeRTOS/Src/tasks.c **** 	{
5011:FreeRTOS/Src/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5012:FreeRTOS/Src/tasks.c **** 	}
5013:FreeRTOS/Src/tasks.c **** 
5014:FreeRTOS/Src/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5015:FreeRTOS/Src/tasks.c **** 	{
5016:FreeRTOS/Src/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 621              		.loc 1 5016 0
 622 002c B4F1FF3F 		cmp	r4, #-1
 623 0030 07D1     		bne	.L50
 624              		.loc 1 5016 0 is_stmt 0 discriminator 1
 625 0032 36B1     		cbz	r6, .L50
5017:FreeRTOS/Src/tasks.c **** 		{
5018:FreeRTOS/Src/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5019:FreeRTOS/Src/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5020:FreeRTOS/Src/tasks.c **** 			indefinitely. */
5021:FreeRTOS/Src/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 626              		.loc 1 5021 0 is_stmt 1
 627 0034 124B     		ldr	r3, .L54+4
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 101


 628 0036 1968     		ldr	r1, [r3]
 629 0038 0431     		adds	r1, r1, #4
 630 003a 1348     		ldr	r0, .L54+12
 631 003c FFF7FEFF 		bl	vListInsertEnd
 632              	.LVL56:
 633 0040 70BD     		pop	{r4, r5, r6, pc}
 634              	.LVL57:
 635              	.L50:
5022:FreeRTOS/Src/tasks.c **** 		}
5023:FreeRTOS/Src/tasks.c **** 		else
5024:FreeRTOS/Src/tasks.c **** 		{
5025:FreeRTOS/Src/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5026:FreeRTOS/Src/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5027:FreeRTOS/Src/tasks.c **** 			kernel will manage it correctly. */
5028:FreeRTOS/Src/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
 636              		.loc 1 5028 0
 637 0042 2C44     		add	r4, r4, r5
 638              	.LVL58:
5029:FreeRTOS/Src/tasks.c **** 
5030:FreeRTOS/Src/tasks.c **** 			/* The list item will be inserted in wake time order. */
5031:FreeRTOS/Src/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 639              		.loc 1 5031 0
 640 0044 0E4B     		ldr	r3, .L54+4
 641 0046 1B68     		ldr	r3, [r3]
 642 0048 5C60     		str	r4, [r3, #4]
5032:FreeRTOS/Src/tasks.c **** 
5033:FreeRTOS/Src/tasks.c **** 			if( xTimeToWake < xConstTickCount )
 643              		.loc 1 5033 0
 644 004a A542     		cmp	r5, r4
 645 004c 07D9     		bls	.L52
5034:FreeRTOS/Src/tasks.c **** 			{
5035:FreeRTOS/Src/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5036:FreeRTOS/Src/tasks.c **** 				list. */
5037:FreeRTOS/Src/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 646              		.loc 1 5037 0
 647 004e 0F4B     		ldr	r3, .L54+16
 648 0050 1868     		ldr	r0, [r3]
 649 0052 0B4B     		ldr	r3, .L54+4
 650 0054 1968     		ldr	r1, [r3]
 651 0056 0431     		adds	r1, r1, #4
 652 0058 FFF7FEFF 		bl	vListInsert
 653              	.LVL59:
 654 005c 70BD     		pop	{r4, r5, r6, pc}
 655              	.LVL60:
 656              	.L52:
5038:FreeRTOS/Src/tasks.c **** 			}
5039:FreeRTOS/Src/tasks.c **** 			else
5040:FreeRTOS/Src/tasks.c **** 			{
5041:FreeRTOS/Src/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5042:FreeRTOS/Src/tasks.c **** 				is used. */
5043:FreeRTOS/Src/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 657              		.loc 1 5043 0
 658 005e 0C4B     		ldr	r3, .L54+20
 659 0060 1868     		ldr	r0, [r3]
 660 0062 074B     		ldr	r3, .L54+4
 661 0064 1968     		ldr	r1, [r3]
 662 0066 0431     		adds	r1, r1, #4
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 102


 663 0068 FFF7FEFF 		bl	vListInsert
 664              	.LVL61:
5044:FreeRTOS/Src/tasks.c **** 
5045:FreeRTOS/Src/tasks.c **** 				/* If the task entering the blocked state was placed at the
5046:FreeRTOS/Src/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5047:FreeRTOS/Src/tasks.c **** 				needs to be updated too. */
5048:FreeRTOS/Src/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
 665              		.loc 1 5048 0
 666 006c 094B     		ldr	r3, .L54+24
 667 006e 1B68     		ldr	r3, [r3]
 668 0070 9C42     		cmp	r4, r3
 669 0072 01D2     		bcs	.L48
5049:FreeRTOS/Src/tasks.c **** 				{
5050:FreeRTOS/Src/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
 670              		.loc 1 5050 0
 671 0074 074B     		ldr	r3, .L54+24
 672 0076 1C60     		str	r4, [r3]
 673              	.L48:
 674 0078 70BD     		pop	{r4, r5, r6, pc}
 675              	.LVL62:
 676              	.L55:
 677 007a 00BF     		.align	2
 678              	.L54:
 679 007c 00000000 		.word	.LANCHOR15
 680 0080 00000000 		.word	.LANCHOR10
 681 0084 00000000 		.word	.LANCHOR13
 682 0088 00000000 		.word	.LANCHOR0
 683 008c 00000000 		.word	.LANCHOR8
 684 0090 00000000 		.word	.LANCHOR2
 685 0094 00000000 		.word	.LANCHOR3
 686              		.cfi_endproc
 687              	.LFE75:
 689              		.section	.text.xTaskCreate,"ax",%progbits
 690              		.align	2
 691              		.global	xTaskCreate
 692              		.thumb
 693              		.thumb_func
 695              	xTaskCreate:
 696              	.LFB32:
 753:FreeRTOS/Src/tasks.c **** 	TCB_t *pxNewTCB;
 697              		.loc 1 753 0
 698              		.cfi_startproc
 699              		@ args = 8, pretend = 0, frame = 0
 700              		@ frame_needed = 0, uses_anonymous_args = 0
 701              	.LVL63:
 702 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 703              	.LCFI7:
 704              		.cfi_def_cfa_offset 28
 705              		.cfi_offset 4, -28
 706              		.cfi_offset 5, -24
 707              		.cfi_offset 6, -20
 708              		.cfi_offset 7, -16
 709              		.cfi_offset 8, -12
 710              		.cfi_offset 9, -8
 711              		.cfi_offset 14, -4
 712 0004 85B0     		sub	sp, sp, #20
 713              	.LCFI8:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 103


 714              		.cfi_def_cfa_offset 48
 715 0006 0646     		mov	r6, r0
 716 0008 0F46     		mov	r7, r1
 717 000a 1546     		mov	r5, r2
 718 000c 9846     		mov	r8, r3
 719              	.LBB27:
 787:FreeRTOS/Src/tasks.c **** 
 720              		.loc 1 787 0
 721 000e 9000     		lsls	r0, r2, #2
 722              	.LVL64:
 723 0010 FFF7FEFF 		bl	pvPortMalloc
 724              	.LVL65:
 789:FreeRTOS/Src/tasks.c **** 			{
 725              		.loc 1 789 0
 726 0014 60B1     		cbz	r0, .L60
 727 0016 8146     		mov	r9, r0
 792:FreeRTOS/Src/tasks.c **** 
 728              		.loc 1 792 0
 729 0018 4C20     		movs	r0, #76
 730              	.LVL66:
 731 001a FFF7FEFF 		bl	pvPortMalloc
 732              	.LVL67:
 794:FreeRTOS/Src/tasks.c **** 				{
 733              		.loc 1 794 0
 734 001e 0446     		mov	r4, r0
 735 0020 10B1     		cbz	r0, .L58
 797:FreeRTOS/Src/tasks.c **** 				}
 736              		.loc 1 797 0
 737 0022 C0F83090 		str	r9, [r0, #48]
 738 0026 04E0     		b	.L57
 739              	.L58:
 803:FreeRTOS/Src/tasks.c **** 				}
 740              		.loc 1 803 0
 741 0028 4846     		mov	r0, r9
 742              	.LVL68:
 743 002a FFF7FEFF 		bl	vPortFree
 744              	.LVL69:
 745 002e 00E0     		b	.L57
 746              	.LVL70:
 747              	.L60:
 808:FreeRTOS/Src/tasks.c **** 			}
 748              		.loc 1 808 0
 749 0030 0024     		movs	r4, #0
 750              	.LVL71:
 751              	.L57:
 752              	.LBE27:
 813:FreeRTOS/Src/tasks.c **** 		{
 753              		.loc 1 813 0
 754 0032 8CB1     		cbz	r4, .L61
 823:FreeRTOS/Src/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 755              		.loc 1 823 0
 756 0034 0023     		movs	r3, #0
 757 0036 0393     		str	r3, [sp, #12]
 758 0038 0294     		str	r4, [sp, #8]
 759 003a 0D9B     		ldr	r3, [sp, #52]
 760 003c 0193     		str	r3, [sp, #4]
 761 003e 0C9B     		ldr	r3, [sp, #48]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 104


 762 0040 0093     		str	r3, [sp]
 763 0042 4346     		mov	r3, r8
 764 0044 2A46     		mov	r2, r5
 765 0046 3946     		mov	r1, r7
 766 0048 3046     		mov	r0, r6
 767 004a FFF7FEFF 		bl	prvInitialiseNewTask
 768              	.LVL72:
 824:FreeRTOS/Src/tasks.c **** 			xReturn = pdPASS;
 769              		.loc 1 824 0
 770 004e 2046     		mov	r0, r4
 771 0050 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 772              	.LVL73:
 825:FreeRTOS/Src/tasks.c **** 		}
 773              		.loc 1 825 0
 774 0054 0120     		movs	r0, #1
 775 0056 01E0     		b	.L59
 776              	.LVL74:
 777              	.L61:
 829:FreeRTOS/Src/tasks.c **** 		}
 778              		.loc 1 829 0
 779 0058 4FF0FF30 		mov	r0, #-1
 780              	.L59:
 781              	.LVL75:
 833:FreeRTOS/Src/tasks.c **** 
 782              		.loc 1 833 0
 783 005c 05B0     		add	sp, sp, #20
 784              	.LCFI9:
 785              		.cfi_def_cfa_offset 28
 786              		@ sp needed
 787 005e BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 788              		.cfi_endproc
 789              	.LFE32:
 791 0062 00BF     		.section	.text.vTaskDelete,"ax",%progbits
 792              		.align	2
 793              		.global	vTaskDelete
 794              		.thumb
 795              		.thumb_func
 797              	vTaskDelete:
 798              	.LFB35:
1130:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
 799              		.loc 1 1130 0
 800              		.cfi_startproc
 801              		@ args = 0, pretend = 0, frame = 0
 802              		@ frame_needed = 0, uses_anonymous_args = 0
 803              	.LVL76:
 804 0000 38B5     		push	{r3, r4, r5, lr}
 805              	.LCFI10:
 806              		.cfi_def_cfa_offset 16
 807              		.cfi_offset 3, -16
 808              		.cfi_offset 4, -12
 809              		.cfi_offset 5, -8
 810              		.cfi_offset 14, -4
 811 0002 0446     		mov	r4, r0
1133:FreeRTOS/Src/tasks.c **** 		{
 812              		.loc 1 1133 0
 813 0004 FFF7FEFF 		bl	vPortEnterCritical
 814              	.LVL77:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 105


1137:FreeRTOS/Src/tasks.c **** 
 815              		.loc 1 1137 0
 816 0008 0CB9     		cbnz	r4, .L64
1137:FreeRTOS/Src/tasks.c **** 
 817              		.loc 1 1137 0 is_stmt 0 discriminator 1
 818 000a 244B     		ldr	r3, .L71
 819 000c 1C68     		ldr	r4, [r3]
 820              	.LVL78:
 821              	.L64:
1140:FreeRTOS/Src/tasks.c **** 			{
 822              		.loc 1 1140 0 is_stmt 1 discriminator 4
 823 000e 251D     		adds	r5, r4, #4
 824 0010 2846     		mov	r0, r5
 825 0012 FFF7FEFF 		bl	uxListRemove
 826              	.LVL79:
 827 0016 70B9     		cbnz	r0, .L65
1142:FreeRTOS/Src/tasks.c **** 			}
 828              		.loc 1 1142 0
 829 0018 E36A     		ldr	r3, [r4, #44]
 830 001a 03EB8301 		add	r1, r3, r3, lsl #2
 831 001e 8A00     		lsls	r2, r1, #2
 832 0020 1F49     		ldr	r1, .L71+4
 833 0022 8A58     		ldr	r2, [r1, r2]
 834 0024 3AB9     		cbnz	r2, .L65
1142:FreeRTOS/Src/tasks.c **** 			}
 835              		.loc 1 1142 0 is_stmt 0 discriminator 1
 836 0026 0122     		movs	r2, #1
 837 0028 02FA03F3 		lsl	r3, r2, r3
 838 002c 1D49     		ldr	r1, .L71+8
 839 002e 0A68     		ldr	r2, [r1]
 840 0030 22EA0303 		bic	r3, r2, r3
 841 0034 0B60     		str	r3, [r1]
 842              	.L65:
1150:FreeRTOS/Src/tasks.c **** 			{
 843              		.loc 1 1150 0 is_stmt 1
 844 0036 A36A     		ldr	r3, [r4, #40]
 845 0038 1BB1     		cbz	r3, .L66
1152:FreeRTOS/Src/tasks.c **** 			}
 846              		.loc 1 1152 0
 847 003a 04F11800 		add	r0, r4, #24
 848 003e FFF7FEFF 		bl	uxListRemove
 849              	.LVL80:
 850              	.L66:
1163:FreeRTOS/Src/tasks.c **** 
 851              		.loc 1 1163 0
 852 0042 194A     		ldr	r2, .L71+12
 853 0044 1368     		ldr	r3, [r2]
 854 0046 0133     		adds	r3, r3, #1
 855 0048 1360     		str	r3, [r2]
1165:FreeRTOS/Src/tasks.c **** 			{
 856              		.loc 1 1165 0
 857 004a 144B     		ldr	r3, .L71
 858 004c 1B68     		ldr	r3, [r3]
 859 004e 9C42     		cmp	r4, r3
 860 0050 08D1     		bne	.L67
1172:FreeRTOS/Src/tasks.c **** 
 861              		.loc 1 1172 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 106


 862 0052 2946     		mov	r1, r5
 863 0054 1548     		ldr	r0, .L71+16
 864 0056 FFF7FEFF 		bl	vListInsertEnd
 865              	.LVL81:
1177:FreeRTOS/Src/tasks.c **** 
 866              		.loc 1 1177 0
 867 005a 154A     		ldr	r2, .L71+20
 868 005c 1368     		ldr	r3, [r2]
 869 005e 0133     		adds	r3, r3, #1
 870 0060 1360     		str	r3, [r2]
 871 0062 08E0     		b	.L68
 872              	.L67:
1188:FreeRTOS/Src/tasks.c **** 				prvDeleteTCB( pxTCB );
 873              		.loc 1 1188 0
 874 0064 134A     		ldr	r2, .L71+24
 875 0066 1368     		ldr	r3, [r2]
 876 0068 013B     		subs	r3, r3, #1
 877 006a 1360     		str	r3, [r2]
1189:FreeRTOS/Src/tasks.c **** 
 878              		.loc 1 1189 0
 879 006c 2046     		mov	r0, r4
 880 006e FFF7FEFF 		bl	prvDeleteTCB
 881              	.LVL82:
1193:FreeRTOS/Src/tasks.c **** 			}
 882              		.loc 1 1193 0
 883 0072 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 884              	.LVL83:
 885              	.L68:
1198:FreeRTOS/Src/tasks.c **** 
 886              		.loc 1 1198 0
 887 0076 FFF7FEFF 		bl	vPortExitCritical
 888              	.LVL84:
1202:FreeRTOS/Src/tasks.c **** 		{
 889              		.loc 1 1202 0
 890 007a 0F4B     		ldr	r3, .L71+28
 891 007c 1B68     		ldr	r3, [r3]
 892 007e 5BB1     		cbz	r3, .L63
1204:FreeRTOS/Src/tasks.c **** 			{
 893              		.loc 1 1204 0
 894 0080 064B     		ldr	r3, .L71
 895 0082 1B68     		ldr	r3, [r3]
 896 0084 9C42     		cmp	r4, r3
 897 0086 07D1     		bne	.L63
1207:FreeRTOS/Src/tasks.c **** 			}
 898              		.loc 1 1207 0
 899 0088 4FF08052 		mov	r2, #268435456
 900 008c 0B4B     		ldr	r3, .L71+32
 901 008e 1A60     		str	r2, [r3]
 902              		.syntax unified
 903              	@ 1207 "FreeRTOS/Src/tasks.c" 1
 904 0090 BFF34F8F 		dsb
 905              	@ 0 "" 2
 906              	@ 1207 "FreeRTOS/Src/tasks.c" 1
 907 0094 BFF36F8F 		isb
 908              	@ 0 "" 2
 909              		.thumb
 910              		.syntax unified
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 107


 911              	.L63:
 912 0098 38BD     		pop	{r3, r4, r5, pc}
 913              	.LVL85:
 914              	.L72:
 915 009a 00BF     		.align	2
 916              	.L71:
 917 009c 00000000 		.word	.LANCHOR10
 918 00a0 00000000 		.word	.LANCHOR4
 919 00a4 00000000 		.word	.LANCHOR13
 920 00a8 00000000 		.word	.LANCHOR12
 921 00ac 00000000 		.word	.LANCHOR7
 922 00b0 00000000 		.word	.LANCHOR14
 923 00b4 00000000 		.word	.LANCHOR9
 924 00b8 00000000 		.word	.LANCHOR11
 925 00bc 04ED00E0 		.word	-536810236
 926              		.cfi_endproc
 927              	.LFE35:
 929              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 930              		.align	2
 931              		.global	uxTaskPriorityGet
 932              		.thumb
 933              		.thumb_func
 935              	uxTaskPriorityGet:
 936              	.LFB38:
1443:FreeRTOS/Src/tasks.c **** 	TCB_t const *pxTCB;
 937              		.loc 1 1443 0
 938              		.cfi_startproc
 939              		@ args = 0, pretend = 0, frame = 0
 940              		@ frame_needed = 0, uses_anonymous_args = 0
 941              	.LVL86:
 942 0000 10B5     		push	{r4, lr}
 943              	.LCFI11:
 944              		.cfi_def_cfa_offset 8
 945              		.cfi_offset 4, -8
 946              		.cfi_offset 14, -4
 947 0002 0446     		mov	r4, r0
1447:FreeRTOS/Src/tasks.c **** 		{
 948              		.loc 1 1447 0
 949 0004 FFF7FEFF 		bl	vPortEnterCritical
 950              	.LVL87:
1451:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 951              		.loc 1 1451 0
 952 0008 0CB9     		cbnz	r4, .L74
1451:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 953              		.loc 1 1451 0 is_stmt 0 discriminator 1
 954 000a 034B     		ldr	r3, .L77
 955 000c 1C68     		ldr	r4, [r3]
 956              	.LVL88:
 957              	.L74:
1452:FreeRTOS/Src/tasks.c **** 		}
 958              		.loc 1 1452 0 is_stmt 1 discriminator 4
 959 000e E46A     		ldr	r4, [r4, #44]
 960              	.LVL89:
1454:FreeRTOS/Src/tasks.c **** 
 961              		.loc 1 1454 0 discriminator 4
 962 0010 FFF7FEFF 		bl	vPortExitCritical
 963              	.LVL90:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 108


1457:FreeRTOS/Src/tasks.c **** 
 964              		.loc 1 1457 0 discriminator 4
 965 0014 2046     		mov	r0, r4
 966 0016 10BD     		pop	{r4, pc}
 967              	.LVL91:
 968              	.L78:
 969              		.align	2
 970              	.L77:
 971 0018 00000000 		.word	.LANCHOR10
 972              		.cfi_endproc
 973              	.LFE38:
 975              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 976              		.align	2
 977              		.global	uxTaskPriorityGetFromISR
 978              		.thumb
 979              		.thumb_func
 981              	uxTaskPriorityGetFromISR:
 982              	.LFB39:
1465:FreeRTOS/Src/tasks.c **** 	TCB_t const *pxTCB;
 983              		.loc 1 1465 0
 984              		.cfi_startproc
 985              		@ args = 0, pretend = 0, frame = 0
 986              		@ frame_needed = 0, uses_anonymous_args = 0
 987              		@ link register save eliminated.
 988              	.LVL92:
 989              	.LBB28:
 990              	.LBB29:
 991              		.file 2 "FreeRTOS/ARM_CM3/portmacro.h"
   1:FreeRTOS/ARM_CM3/portmacro.h **** /*
   2:FreeRTOS/ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/ARM_CM3/portmacro.h ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/ARM_CM3/portmacro.h ****  *
   5:FreeRTOS/ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/ARM_CM3/portmacro.h ****  * subject to the following conditions:
  11:FreeRTOS/ARM_CM3/portmacro.h ****  *
  12:FreeRTOS/ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  14:FreeRTOS/ARM_CM3/portmacro.h ****  *
  15:FreeRTOS/ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/ARM_CM3/portmacro.h ****  *
  22:FreeRTOS/ARM_CM3/portmacro.h ****  * http://www.FreeRTOS.org
  23:FreeRTOS/ARM_CM3/portmacro.h ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/ARM_CM3/portmacro.h ****  *
  25:FreeRTOS/ARM_CM3/portmacro.h ****  * 1 tab == 4 spaces!
  26:FreeRTOS/ARM_CM3/portmacro.h ****  */
  27:FreeRTOS/ARM_CM3/portmacro.h **** 
  28:FreeRTOS/ARM_CM3/portmacro.h **** 
  29:FreeRTOS/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 109


  30:FreeRTOS/ARM_CM3/portmacro.h **** #define PORTMACRO_H
  31:FreeRTOS/ARM_CM3/portmacro.h **** 
  32:FreeRTOS/ARM_CM3/portmacro.h **** #ifdef __cplusplus
  33:FreeRTOS/ARM_CM3/portmacro.h **** extern "C" {
  34:FreeRTOS/ARM_CM3/portmacro.h **** #endif
  35:FreeRTOS/ARM_CM3/portmacro.h **** 
  36:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  37:FreeRTOS/ARM_CM3/portmacro.h ****  * Port specific definitions.
  38:FreeRTOS/ARM_CM3/portmacro.h ****  *
  39:FreeRTOS/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:FreeRTOS/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  41:FreeRTOS/ARM_CM3/portmacro.h ****  *
  42:FreeRTOS/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  43:FreeRTOS/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  44:FreeRTOS/ARM_CM3/portmacro.h ****  */
  45:FreeRTOS/ARM_CM3/portmacro.h **** 
  46:FreeRTOS/ARM_CM3/portmacro.h **** /* Type definitions. */
  47:FreeRTOS/ARM_CM3/portmacro.h **** #define portCHAR		char
  48:FreeRTOS/ARM_CM3/portmacro.h **** #define portFLOAT		float
  49:FreeRTOS/ARM_CM3/portmacro.h **** #define portDOUBLE		double
  50:FreeRTOS/ARM_CM3/portmacro.h **** #define portLONG		long
  51:FreeRTOS/ARM_CM3/portmacro.h **** #define portSHORT		short
  52:FreeRTOS/ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:FreeRTOS/ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  54:FreeRTOS/ARM_CM3/portmacro.h **** 
  55:FreeRTOS/ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:FreeRTOS/ARM_CM3/portmacro.h **** typedef long BaseType_t;
  57:FreeRTOS/ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
  58:FreeRTOS/ARM_CM3/portmacro.h **** 
  59:FreeRTOS/ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:FreeRTOS/ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
  61:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:FreeRTOS/ARM_CM3/portmacro.h **** #else
  63:FreeRTOS/ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
  64:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:FreeRTOS/ARM_CM3/portmacro.h **** 
  66:FreeRTOS/ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:FreeRTOS/ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
  68:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:FreeRTOS/ARM_CM3/portmacro.h **** #endif
  70:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  71:FreeRTOS/ARM_CM3/portmacro.h **** 
  72:FreeRTOS/ARM_CM3/portmacro.h **** /* Architecture specifics. */
  73:FreeRTOS/ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:FreeRTOS/ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:FreeRTOS/ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  77:FreeRTOS/ARM_CM3/portmacro.h **** 
  78:FreeRTOS/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  79:FreeRTOS/ARM_CM3/portmacro.h **** #define portYIELD() 															\
  80:FreeRTOS/ARM_CM3/portmacro.h **** {																				\
  81:FreeRTOS/ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:FreeRTOS/ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:FreeRTOS/ARM_CM3/portmacro.h **** 																				\
  84:FreeRTOS/ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:FreeRTOS/ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:FreeRTOS/ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 110


  87:FreeRTOS/ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
  88:FreeRTOS/ARM_CM3/portmacro.h **** }
  89:FreeRTOS/ARM_CM3/portmacro.h **** 
  90:FreeRTOS/ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:FreeRTOS/ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:FreeRTOS/ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:FreeRTOS/ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  95:FreeRTOS/ARM_CM3/portmacro.h **** 
  96:FreeRTOS/ARM_CM3/portmacro.h **** /* Critical section management. */
  97:FreeRTOS/ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
  98:FreeRTOS/ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
  99:FreeRTOS/ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:FreeRTOS/ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:FreeRTOS/ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:FreeRTOS/ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:FreeRTOS/ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:FreeRTOS/ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:FreeRTOS/ARM_CM3/portmacro.h **** 
 106:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 107:FreeRTOS/ARM_CM3/portmacro.h **** 
 108:FreeRTOS/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:FreeRTOS/ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:FreeRTOS/ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 111:FreeRTOS/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:FreeRTOS/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 114:FreeRTOS/ARM_CM3/portmacro.h **** 
 115:FreeRTOS/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 116:FreeRTOS/ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:FreeRTOS/ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:FreeRTOS/ARM_CM3/portmacro.h **** #endif
 120:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 121:FreeRTOS/ARM_CM3/portmacro.h **** 
 122:FreeRTOS/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 123:FreeRTOS/ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:FreeRTOS/ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:FreeRTOS/ARM_CM3/portmacro.h **** #endif
 126:FreeRTOS/ARM_CM3/portmacro.h **** 
 127:FreeRTOS/ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:FreeRTOS/ARM_CM3/portmacro.h **** 
 129:FreeRTOS/ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 130:FreeRTOS/ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:FreeRTOS/ARM_CM3/portmacro.h **** 	{
 132:FreeRTOS/ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 133:FreeRTOS/ARM_CM3/portmacro.h **** 
 134:FreeRTOS/ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:FreeRTOS/ARM_CM3/portmacro.h **** 		return ucReturn;
 136:FreeRTOS/ARM_CM3/portmacro.h **** 	}
 137:FreeRTOS/ARM_CM3/portmacro.h **** 
 138:FreeRTOS/ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 139:FreeRTOS/ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:FreeRTOS/ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:FreeRTOS/ARM_CM3/portmacro.h **** 	#endif
 142:FreeRTOS/ARM_CM3/portmacro.h **** 
 143:FreeRTOS/ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 111


 144:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:FreeRTOS/ARM_CM3/portmacro.h **** 
 147:FreeRTOS/ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:FreeRTOS/ARM_CM3/portmacro.h **** 
 149:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:FreeRTOS/ARM_CM3/portmacro.h **** 
 151:FreeRTOS/ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:FreeRTOS/ARM_CM3/portmacro.h **** 
 153:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 154:FreeRTOS/ARM_CM3/portmacro.h **** 
 155:FreeRTOS/ARM_CM3/portmacro.h **** #ifdef configASSERT
 156:FreeRTOS/ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:FreeRTOS/ARM_CM3/portmacro.h **** #endif
 159:FreeRTOS/ARM_CM3/portmacro.h **** 
 160:FreeRTOS/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 161:FreeRTOS/ARM_CM3/portmacro.h **** #define portNOP()
 162:FreeRTOS/ARM_CM3/portmacro.h **** 
 163:FreeRTOS/ARM_CM3/portmacro.h **** #define portINLINE	__inline
 164:FreeRTOS/ARM_CM3/portmacro.h **** 
 165:FreeRTOS/ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 166:FreeRTOS/ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:FreeRTOS/ARM_CM3/portmacro.h **** #endif
 168:FreeRTOS/ARM_CM3/portmacro.h **** 
 169:FreeRTOS/ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 170:FreeRTOS/ARM_CM3/portmacro.h **** {
 171:FreeRTOS/ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 172:FreeRTOS/ARM_CM3/portmacro.h **** BaseType_t xReturn;
 173:FreeRTOS/ARM_CM3/portmacro.h **** 
 174:FreeRTOS/ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 175:FreeRTOS/ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 176:FreeRTOS/ARM_CM3/portmacro.h **** 
 177:FreeRTOS/ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 178:FreeRTOS/ARM_CM3/portmacro.h **** 	{
 179:FreeRTOS/ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 180:FreeRTOS/ARM_CM3/portmacro.h **** 	}
 181:FreeRTOS/ARM_CM3/portmacro.h **** 	else
 182:FreeRTOS/ARM_CM3/portmacro.h **** 	{
 183:FreeRTOS/ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 184:FreeRTOS/ARM_CM3/portmacro.h **** 	}
 185:FreeRTOS/ARM_CM3/portmacro.h **** 
 186:FreeRTOS/ARM_CM3/portmacro.h **** 	return xReturn;
 187:FreeRTOS/ARM_CM3/portmacro.h **** }
 188:FreeRTOS/ARM_CM3/portmacro.h **** 
 189:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 190:FreeRTOS/ARM_CM3/portmacro.h **** 
 191:FreeRTOS/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 192:FreeRTOS/ARM_CM3/portmacro.h **** {
 193:FreeRTOS/ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 194:FreeRTOS/ARM_CM3/portmacro.h **** 
 195:FreeRTOS/ARM_CM3/portmacro.h **** 	__asm volatile
 196:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 197:FreeRTOS/ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n" \
 198:FreeRTOS/ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 199:FreeRTOS/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 200:FreeRTOS/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 112


 201:FreeRTOS/ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 202:FreeRTOS/ARM_CM3/portmacro.h **** 	);
 203:FreeRTOS/ARM_CM3/portmacro.h **** }
 204:FreeRTOS/ARM_CM3/portmacro.h **** 
 205:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 206:FreeRTOS/ARM_CM3/portmacro.h **** 
 207:FreeRTOS/ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 208:FreeRTOS/ARM_CM3/portmacro.h **** {
 209:FreeRTOS/ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 210:FreeRTOS/ARM_CM3/portmacro.h **** 
 211:FreeRTOS/ARM_CM3/portmacro.h **** 	__asm volatile
 992              		.loc 2 211 0
 993              		.syntax unified
 994              	@ 211 "FreeRTOS/ARM_CM3/portmacro.h" 1
 995 0000 EFF31183 			mrs r3, basepri											
 996 0004 4FF0BF02 		mov r2, #191												
 997 0008 82F31188 		msr basepri, r2											
 998 000c BFF36F8F 		isb														
 999 0010 BFF34F8F 		dsb														
 1000              	
 1001              	@ 0 "" 2
 1002              		.thumb
 1003              		.syntax unified
 1004              	.LBE29:
 1005              	.LBE28:
1491:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1006              		.loc 1 1491 0
 1007 0014 08B9     		cbnz	r0, .L80
1491:FreeRTOS/Src/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1008              		.loc 1 1491 0 is_stmt 0 discriminator 1
 1009 0016 034A     		ldr	r2, .L82
 1010 0018 1068     		ldr	r0, [r2]
 1011              	.LVL93:
 1012              	.L80:
1492:FreeRTOS/Src/tasks.c **** 		}
 1013              		.loc 1 1492 0 is_stmt 1 discriminator 4
 1014 001a C06A     		ldr	r0, [r0, #44]
 1015              	.LVL94:
 1016              	.LBB30:
 1017              	.LBB31:
 212:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 213:FreeRTOS/ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 214:FreeRTOS/ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n" \
 215:FreeRTOS/ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 216:FreeRTOS/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 217:FreeRTOS/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 218:FreeRTOS/ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 219:FreeRTOS/ARM_CM3/portmacro.h **** 	);
 220:FreeRTOS/ARM_CM3/portmacro.h **** 
 221:FreeRTOS/ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 222:FreeRTOS/ARM_CM3/portmacro.h **** 	warnings. */
 223:FreeRTOS/ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 224:FreeRTOS/ARM_CM3/portmacro.h **** }
 225:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 226:FreeRTOS/ARM_CM3/portmacro.h **** 
 227:FreeRTOS/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 228:FreeRTOS/ARM_CM3/portmacro.h **** {
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 113


 229:FreeRTOS/ARM_CM3/portmacro.h **** 	__asm volatile
 1018              		.loc 2 229 0 discriminator 4
 1019              		.syntax unified
 1020              	@ 229 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1021 001c 83F31188 			msr basepri, r3	
 1022              	@ 0 "" 2
 1023              	.LVL95:
 1024              		.thumb
 1025              		.syntax unified
 1026              	.LBE31:
 1027              	.LBE30:
1497:FreeRTOS/Src/tasks.c **** 
 1028              		.loc 1 1497 0 discriminator 4
 1029 0020 7047     		bx	lr
 1030              	.L83:
 1031 0022 00BF     		.align	2
 1032              	.L82:
 1033 0024 00000000 		.word	.LANCHOR10
 1034              		.cfi_endproc
 1035              	.LFE39:
 1037              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1038              		.align	2
 1039              		.global	vTaskPrioritySet
 1040              		.thumb
 1041              		.thumb_func
 1043              	vTaskPrioritySet:
 1044              	.LFB40:
1505:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
 1045              		.loc 1 1505 0
 1046              		.cfi_startproc
 1047              		@ args = 0, pretend = 0, frame = 0
 1048              		@ frame_needed = 0, uses_anonymous_args = 0
 1049              	.LVL96:
 1050 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1051              	.LCFI12:
 1052              		.cfi_def_cfa_offset 24
 1053              		.cfi_offset 3, -24
 1054              		.cfi_offset 4, -20
 1055              		.cfi_offset 5, -16
 1056              		.cfi_offset 6, -12
 1057              		.cfi_offset 7, -8
 1058              		.cfi_offset 14, -4
 1059 0002 0546     		mov	r5, r0
 1060 0004 0C46     		mov	r4, r1
 1061              	.LVL97:
1513:FreeRTOS/Src/tasks.c **** 		{
 1062              		.loc 1 1513 0
 1063 0006 0429     		cmp	r1, #4
 1064 0008 00D9     		bls	.L85
1515:FreeRTOS/Src/tasks.c **** 		}
 1065              		.loc 1 1515 0
 1066 000a 0424     		movs	r4, #4
 1067              	.L85:
 1068              	.LVL98:
1522:FreeRTOS/Src/tasks.c **** 		{
 1069              		.loc 1 1522 0
 1070 000c FFF7FEFF 		bl	vPortEnterCritical
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 114


 1071              	.LVL99:
1526:FreeRTOS/Src/tasks.c **** 
 1072              		.loc 1 1526 0
 1073 0010 0DB9     		cbnz	r5, .L86
1526:FreeRTOS/Src/tasks.c **** 
 1074              		.loc 1 1526 0 is_stmt 0 discriminator 1
 1075 0012 2A4B     		ldr	r3, .L98
 1076 0014 1D68     		ldr	r5, [r3]
 1077              	.LVL100:
 1078              	.L86:
1536:FreeRTOS/Src/tasks.c **** 			}
 1079              		.loc 1 1536 0 is_stmt 1 discriminator 4
 1080 0016 EE6A     		ldr	r6, [r5, #44]
 1081              	.LVL101:
1540:FreeRTOS/Src/tasks.c **** 			{
 1082              		.loc 1 1540 0 discriminator 4
 1083 0018 B442     		cmp	r4, r6
 1084 001a 4BD0     		beq	.L87
1544:FreeRTOS/Src/tasks.c **** 				{
 1085              		.loc 1 1544 0
 1086 001c 0AD9     		bls	.L88
1546:FreeRTOS/Src/tasks.c **** 					{
 1087              		.loc 1 1546 0
 1088 001e 274B     		ldr	r3, .L98
 1089 0020 1B68     		ldr	r3, [r3]
 1090 0022 9D42     		cmp	r5, r3
 1091 0024 0CD0     		beq	.L94
1551:FreeRTOS/Src/tasks.c **** 						{
 1092              		.loc 1 1551 0
 1093 0026 254B     		ldr	r3, .L98
 1094 0028 1B68     		ldr	r3, [r3]
 1095 002a DB6A     		ldr	r3, [r3, #44]
 1096 002c 9C42     		cmp	r4, r3
 1097 002e 09D2     		bcs	.L95
1508:FreeRTOS/Src/tasks.c **** 
 1098              		.loc 1 1508 0
 1099 0030 0027     		movs	r7, #0
 1100 0032 0AE0     		b	.L89
 1101              	.L88:
1567:FreeRTOS/Src/tasks.c **** 				{
 1102              		.loc 1 1567 0
 1103 0034 214B     		ldr	r3, .L98
 1104 0036 1B68     		ldr	r3, [r3]
 1105 0038 9D42     		cmp	r5, r3
 1106 003a 05D0     		beq	.L96
1508:FreeRTOS/Src/tasks.c **** 
 1107              		.loc 1 1508 0
 1108 003c 0027     		movs	r7, #0
 1109 003e 04E0     		b	.L89
 1110              	.L94:
 1111 0040 0027     		movs	r7, #0
 1112 0042 02E0     		b	.L89
 1113              	.L95:
1553:FreeRTOS/Src/tasks.c **** 						}
 1114              		.loc 1 1553 0
 1115 0044 0127     		movs	r7, #1
 1116 0046 00E0     		b	.L89
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 115


 1117              	.L96:
1572:FreeRTOS/Src/tasks.c **** 				}
 1118              		.loc 1 1572 0
 1119 0048 0127     		movs	r7, #1
 1120              	.L89:
 1121              	.LVL102:
1604:FreeRTOS/Src/tasks.c **** 				}
 1122              		.loc 1 1604 0
 1123 004a EC62     		str	r4, [r5, #44]
1610:FreeRTOS/Src/tasks.c **** 				{
 1124              		.loc 1 1610 0
 1125 004c AB69     		ldr	r3, [r5, #24]
 1126 004e 002B     		cmp	r3, #0
 1127 0050 02DB     		blt	.L90
1612:FreeRTOS/Src/tasks.c **** 				}
 1128              		.loc 1 1612 0
 1129 0052 C4F10504 		rsb	r4, r4, #5
 1130              	.LVL103:
 1131 0056 AC61     		str	r4, [r5, #24]
 1132              	.L90:
1623:FreeRTOS/Src/tasks.c **** 				{
 1133              		.loc 1 1623 0
 1134 0058 6969     		ldr	r1, [r5, #20]
 1135 005a 06EB8602 		add	r2, r6, r6, lsl #2
 1136 005e 9300     		lsls	r3, r2, #2
 1137 0060 174A     		ldr	r2, .L98+4
 1138 0062 1344     		add	r3, r3, r2
 1139 0064 9942     		cmp	r1, r3
 1140 0066 1CD1     		bne	.L91
1628:FreeRTOS/Src/tasks.c **** 					{
 1141              		.loc 1 1628 0
 1142 0068 2C1D     		adds	r4, r5, #4
 1143 006a 2046     		mov	r0, r4
 1144 006c FFF7FEFF 		bl	uxListRemove
 1145              	.LVL104:
 1146 0070 38B9     		cbnz	r0, .L92
1633:FreeRTOS/Src/tasks.c **** 					}
 1147              		.loc 1 1633 0
 1148 0072 0123     		movs	r3, #1
 1149 0074 03FA06F6 		lsl	r6, r3, r6
 1150              	.LVL105:
 1151 0078 124A     		ldr	r2, .L98+8
 1152 007a 1368     		ldr	r3, [r2]
 1153 007c 23EA0606 		bic	r6, r3, r6
 1154 0080 1660     		str	r6, [r2]
 1155              	.L92:
1639:FreeRTOS/Src/tasks.c **** 				}
 1156              		.loc 1 1639 0
 1157 0082 EB6A     		ldr	r3, [r5, #44]
 1158 0084 0122     		movs	r2, #1
 1159 0086 02FA03F1 		lsl	r1, r2, r3
 1160 008a 0E48     		ldr	r0, .L98+8
 1161 008c 0268     		ldr	r2, [r0]
 1162 008e 0A43     		orrs	r2, r2, r1
 1163 0090 0260     		str	r2, [r0]
 1164 0092 03EB8303 		add	r3, r3, r3, lsl #2
 1165 0096 9A00     		lsls	r2, r3, #2
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 116


 1166 0098 2146     		mov	r1, r4
 1167 009a 0948     		ldr	r0, .L98+4
 1168 009c 1044     		add	r0, r0, r2
 1169 009e FFF7FEFF 		bl	vListInsertEnd
 1170              	.LVL106:
 1171              	.L91:
1646:FreeRTOS/Src/tasks.c **** 				{
 1172              		.loc 1 1646 0
 1173 00a2 3FB1     		cbz	r7, .L87
1648:FreeRTOS/Src/tasks.c **** 				}
 1174              		.loc 1 1648 0
 1175 00a4 4FF08052 		mov	r2, #268435456
 1176 00a8 074B     		ldr	r3, .L98+12
 1177 00aa 1A60     		str	r2, [r3]
 1178              		.syntax unified
 1179              	@ 1648 "FreeRTOS/Src/tasks.c" 1
 1180 00ac BFF34F8F 		dsb
 1181              	@ 0 "" 2
 1182              	@ 1648 "FreeRTOS/Src/tasks.c" 1
 1183 00b0 BFF36F8F 		isb
 1184              	@ 0 "" 2
 1185              	.LVL107:
 1186              		.thumb
 1187              		.syntax unified
 1188              	.L87:
1660:FreeRTOS/Src/tasks.c **** 	}
 1189              		.loc 1 1660 0
 1190 00b4 FFF7FEFF 		bl	vPortExitCritical
 1191              	.LVL108:
 1192 00b8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1193              	.LVL109:
 1194              	.L99:
 1195 00ba 00BF     		.align	2
 1196              	.L98:
 1197 00bc 00000000 		.word	.LANCHOR10
 1198 00c0 00000000 		.word	.LANCHOR4
 1199 00c4 00000000 		.word	.LANCHOR13
 1200 00c8 04ED00E0 		.word	-536810236
 1201              		.cfi_endproc
 1202              	.LFE40:
 1204              		.section	.text.vTaskResume,"ax",%progbits
 1205              		.align	2
 1206              		.global	vTaskResume
 1207              		.thumb
 1208              		.thumb_func
 1210              	vTaskResume:
 1211              	.LFB43:
1816:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1212              		.loc 1 1816 0
 1213              		.cfi_startproc
 1214              		@ args = 0, pretend = 0, frame = 0
 1215              		@ frame_needed = 0, uses_anonymous_args = 0
 1216              	.LVL110:
 1217 0000 38B5     		push	{r3, r4, r5, lr}
 1218              	.LCFI13:
 1219              		.cfi_def_cfa_offset 16
 1220              		.cfi_offset 3, -16
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 117


 1221              		.cfi_offset 4, -12
 1222              		.cfi_offset 5, -8
 1223              		.cfi_offset 14, -4
 1224              	.LVL111:
1824:FreeRTOS/Src/tasks.c **** 		{
 1225              		.loc 1 1824 0
 1226 0002 184B     		ldr	r3, .L104
 1227 0004 1B68     		ldr	r3, [r3]
 1228 0006 9842     		cmp	r0, r3
 1229 0008 2BD0     		beq	.L100
1824:FreeRTOS/Src/tasks.c **** 		{
 1230              		.loc 1 1824 0 is_stmt 0 discriminator 1
 1231 000a 50B3     		cbz	r0, .L100
 1232 000c 0446     		mov	r4, r0
1826:FreeRTOS/Src/tasks.c **** 			{
 1233              		.loc 1 1826 0 is_stmt 1
 1234 000e FFF7FEFF 		bl	vPortEnterCritical
 1235              	.LVL112:
1828:FreeRTOS/Src/tasks.c **** 				{
 1236              		.loc 1 1828 0
 1237 0012 2046     		mov	r0, r4
 1238 0014 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1239              	.LVL113:
 1240 0018 08B3     		cbz	r0, .L102
1834:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1241              		.loc 1 1834 0
 1242 001a 251D     		adds	r5, r4, #4
 1243 001c 2846     		mov	r0, r5
 1244 001e FFF7FEFF 		bl	uxListRemove
 1245              	.LVL114:
1835:FreeRTOS/Src/tasks.c **** 
 1246              		.loc 1 1835 0
 1247 0022 E36A     		ldr	r3, [r4, #44]
 1248 0024 0122     		movs	r2, #1
 1249 0026 02FA03F1 		lsl	r1, r2, r3
 1250 002a 0F48     		ldr	r0, .L104+4
 1251 002c 0268     		ldr	r2, [r0]
 1252 002e 0A43     		orrs	r2, r2, r1
 1253 0030 0260     		str	r2, [r0]
 1254 0032 03EB8303 		add	r3, r3, r3, lsl #2
 1255 0036 9A00     		lsls	r2, r3, #2
 1256 0038 2946     		mov	r1, r5
 1257 003a 0C48     		ldr	r0, .L104+8
 1258 003c 1044     		add	r0, r0, r2
 1259 003e FFF7FEFF 		bl	vListInsertEnd
 1260              	.LVL115:
1838:FreeRTOS/Src/tasks.c **** 					{
 1261              		.loc 1 1838 0
 1262 0042 E26A     		ldr	r2, [r4, #44]
 1263 0044 074B     		ldr	r3, .L104
 1264 0046 1B68     		ldr	r3, [r3]
 1265 0048 DB6A     		ldr	r3, [r3, #44]
 1266 004a 9A42     		cmp	r2, r3
 1267 004c 07D3     		bcc	.L102
1843:FreeRTOS/Src/tasks.c **** 					}
 1268              		.loc 1 1843 0
 1269 004e 4FF08052 		mov	r2, #268435456
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 118


 1270 0052 074B     		ldr	r3, .L104+12
 1271 0054 1A60     		str	r2, [r3]
 1272              		.syntax unified
 1273              	@ 1843 "FreeRTOS/Src/tasks.c" 1
 1274 0056 BFF34F8F 		dsb
 1275              	@ 0 "" 2
 1276              	@ 1843 "FreeRTOS/Src/tasks.c" 1
 1277 005a BFF36F8F 		isb
 1278              	@ 0 "" 2
 1279              		.thumb
 1280              		.syntax unified
 1281              	.L102:
1855:FreeRTOS/Src/tasks.c **** 		}
 1282              		.loc 1 1855 0
 1283 005e FFF7FEFF 		bl	vPortExitCritical
 1284              	.LVL116:
 1285              	.L100:
 1286 0062 38BD     		pop	{r3, r4, r5, pc}
 1287              	.L105:
 1288              		.align	2
 1289              	.L104:
 1290 0064 00000000 		.word	.LANCHOR10
 1291 0068 00000000 		.word	.LANCHOR13
 1292 006c 00000000 		.word	.LANCHOR4
 1293 0070 04ED00E0 		.word	-536810236
 1294              		.cfi_endproc
 1295              	.LFE43:
 1297              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1298              		.align	2
 1299              		.global	xTaskResumeFromISR
 1300              		.thumb
 1301              		.thumb_func
 1303              	xTaskResumeFromISR:
 1304              	.LFB44:
1870:FreeRTOS/Src/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1305              		.loc 1 1870 0
 1306              		.cfi_startproc
 1307              		@ args = 0, pretend = 0, frame = 0
 1308              		@ frame_needed = 0, uses_anonymous_args = 0
 1309              	.LVL117:
 1310 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1311              	.LCFI14:
 1312              		.cfi_def_cfa_offset 24
 1313              		.cfi_offset 3, -24
 1314              		.cfi_offset 4, -20
 1315              		.cfi_offset 5, -16
 1316              		.cfi_offset 6, -12
 1317              		.cfi_offset 7, -8
 1318              		.cfi_offset 14, -4
 1319 0002 0446     		mov	r4, r0
 1320              	.LVL118:
 1321              	.LBB32:
 1322              	.LBB33:
 211:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 1323              		.loc 2 211 0
 1324              		.syntax unified
 1325              	@ 211 "FreeRTOS/ARM_CM3/portmacro.h" 1
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 119


 1326 0004 EFF31185 			mrs r5, basepri											
 1327 0008 4FF0BF03 		mov r3, #191												
 1328 000c 83F31188 		msr basepri, r3											
 1329 0010 BFF36F8F 		isb														
 1330 0014 BFF34F8F 		dsb														
 1331              	
 1332              	@ 0 "" 2
 1333              		.thumb
 1334              		.syntax unified
 1335              	.LBE33:
 1336              	.LBE32:
1897:FreeRTOS/Src/tasks.c **** 			{
 1337              		.loc 1 1897 0
 1338 0018 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1339              	.LVL119:
 1340 001c 38B3     		cbz	r0, .L110
1902:FreeRTOS/Src/tasks.c **** 				{
 1341              		.loc 1 1902 0
 1342 001e 164B     		ldr	r3, .L113
 1343 0020 1B68     		ldr	r3, [r3]
 1344 0022 EBB9     		cbnz	r3, .L108
1906:FreeRTOS/Src/tasks.c **** 					{
 1345              		.loc 1 1906 0
 1346 0024 E26A     		ldr	r2, [r4, #44]
 1347 0026 154B     		ldr	r3, .L113+4
 1348 0028 1B68     		ldr	r3, [r3]
 1349 002a DB6A     		ldr	r3, [r3, #44]
 1350 002c 9A42     		cmp	r2, r3
 1351 002e 01D2     		bcs	.L111
1871:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1352              		.loc 1 1871 0
 1353 0030 0026     		movs	r6, #0
 1354 0032 00E0     		b	.L109
 1355              	.L111:
1908:FreeRTOS/Src/tasks.c **** 					}
 1356              		.loc 1 1908 0
 1357 0034 0126     		movs	r6, #1
 1358              	.L109:
 1359              	.LVL120:
1915:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1360              		.loc 1 1915 0
 1361 0036 271D     		adds	r7, r4, #4
 1362 0038 3846     		mov	r0, r7
 1363 003a FFF7FEFF 		bl	uxListRemove
 1364              	.LVL121:
1916:FreeRTOS/Src/tasks.c **** 				}
 1365              		.loc 1 1916 0
 1366 003e E36A     		ldr	r3, [r4, #44]
 1367 0040 0122     		movs	r2, #1
 1368 0042 02FA03F1 		lsl	r1, r2, r3
 1369 0046 0E48     		ldr	r0, .L113+8
 1370 0048 0268     		ldr	r2, [r0]
 1371 004a 0A43     		orrs	r2, r2, r1
 1372 004c 0260     		str	r2, [r0]
 1373 004e 03EB8303 		add	r3, r3, r3, lsl #2
 1374 0052 9A00     		lsls	r2, r3, #2
 1375 0054 3946     		mov	r1, r7
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 120


 1376 0056 0B48     		ldr	r0, .L113+12
 1377 0058 1044     		add	r0, r0, r2
 1378 005a FFF7FEFF 		bl	vListInsertEnd
 1379              	.LVL122:
 1380 005e 07E0     		b	.L107
 1381              	.LVL123:
 1382              	.L108:
1923:FreeRTOS/Src/tasks.c **** 				}
 1383              		.loc 1 1923 0
 1384 0060 04F11801 		add	r1, r4, #24
 1385 0064 0848     		ldr	r0, .L113+16
 1386 0066 FFF7FEFF 		bl	vListInsertEnd
 1387              	.LVL124:
1871:FreeRTOS/Src/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1388              		.loc 1 1871 0
 1389 006a 0026     		movs	r6, #0
 1390 006c 00E0     		b	.L107
 1391              	.L110:
 1392 006e 0026     		movs	r6, #0
 1393              	.LVL125:
 1394              	.L107:
 1395              	.LBB34:
 1396              	.LBB35:
 1397              		.loc 2 229 0
 1398              		.syntax unified
 1399              	@ 229 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1400 0070 85F31188 			msr basepri, r5	
 1401              	@ 0 "" 2
 1402              	.LVL126:
 1403              		.thumb
 1404              		.syntax unified
 1405              	.LBE35:
 1406              	.LBE34:
1934:FreeRTOS/Src/tasks.c **** 
 1407              		.loc 1 1934 0
 1408 0074 3046     		mov	r0, r6
 1409 0076 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1410              	.LVL127:
 1411              	.L114:
 1412              		.align	2
 1413              	.L113:
 1414 0078 00000000 		.word	.LANCHOR16
 1415 007c 00000000 		.word	.LANCHOR10
 1416 0080 00000000 		.word	.LANCHOR13
 1417 0084 00000000 		.word	.LANCHOR4
 1418 0088 00000000 		.word	.LANCHOR1
 1419              		.cfi_endproc
 1420              	.LFE44:
 1422              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1423              		.align	2
 1424              		.global	vTaskStartScheduler
 1425              		.thumb
 1426              		.thumb_func
 1428              	vTaskStartScheduler:
 1429              	.LFB45:
1940:FreeRTOS/Src/tasks.c **** BaseType_t xReturn;
 1430              		.loc 1 1940 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 121


 1431              		.cfi_startproc
 1432              		@ args = 0, pretend = 0, frame = 0
 1433              		@ frame_needed = 0, uses_anonymous_args = 0
 1434 0000 00B5     		push	{lr}
 1435              	.LCFI15:
 1436              		.cfi_def_cfa_offset 4
 1437              		.cfi_offset 14, -4
 1438 0002 83B0     		sub	sp, sp, #12
 1439              	.LCFI16:
 1440              		.cfi_def_cfa_offset 16
1973:FreeRTOS/Src/tasks.c **** 								configIDLE_TASK_NAME,
 1441              		.loc 1 1973 0
 1442 0004 104B     		ldr	r3, .L118
 1443 0006 0193     		str	r3, [sp, #4]
 1444 0008 0023     		movs	r3, #0
 1445 000a 0093     		str	r3, [sp]
 1446 000c 8022     		movs	r2, #128
 1447 000e 0F49     		ldr	r1, .L118+4
 1448 0010 0F48     		ldr	r0, .L118+8
 1449 0012 FFF7FEFF 		bl	xTaskCreate
 1450              	.LVL128:
1995:FreeRTOS/Src/tasks.c **** 	{
 1451              		.loc 1 1995 0
 1452 0016 0128     		cmp	r0, #1
 1453 0018 13D1     		bne	.L115
 1454              	.LBB36:
 1455              	.LBB37:
 195:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 1456              		.loc 2 195 0
 1457              		.syntax unified
 1458              	@ 195 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1459 001a 4FF0BF03 			mov r3, #191												
 1460 001e 83F31188 		msr basepri, r3											
 1461 0022 BFF36F8F 		isb														
 1462 0026 BFF34F8F 		dsb														
 1463              	
 1464              	@ 0 "" 2
 1465              		.thumb
 1466              		.syntax unified
 1467              	.LBE37:
 1468              	.LBE36:
2021:FreeRTOS/Src/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1469              		.loc 1 2021 0
 1470 002a 4FF0FF32 		mov	r2, #-1
 1471 002e 094B     		ldr	r3, .L118+12
 1472 0030 1A60     		str	r2, [r3]
2022:FreeRTOS/Src/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1473              		.loc 1 2022 0
 1474 0032 0122     		movs	r2, #1
 1475 0034 084B     		ldr	r3, .L118+16
 1476 0036 1A60     		str	r2, [r3]
2023:FreeRTOS/Src/tasks.c **** 
 1477              		.loc 1 2023 0
 1478 0038 0022     		movs	r2, #0
 1479 003a 084B     		ldr	r3, .L118+20
 1480 003c 1A60     		str	r2, [r3]
2037:FreeRTOS/Src/tasks.c **** 		{
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 122


 1481              		.loc 1 2037 0
 1482 003e FFF7FEFF 		bl	xPortStartScheduler
 1483              	.LVL129:
 1484              	.L115:
2058:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 1485              		.loc 1 2058 0
 1486 0042 03B0     		add	sp, sp, #12
 1487              	.LCFI17:
 1488              		.cfi_def_cfa_offset 4
 1489              		@ sp needed
 1490 0044 5DF804FB 		ldr	pc, [sp], #4
 1491              	.L119:
 1492              		.align	2
 1493              	.L118:
 1494 0048 00000000 		.word	.LANCHOR17
 1495 004c 00000000 		.word	.LC0
 1496 0050 00000000 		.word	prvIdleTask
 1497 0054 00000000 		.word	.LANCHOR3
 1498 0058 00000000 		.word	.LANCHOR11
 1499 005c 00000000 		.word	.LANCHOR15
 1500              		.cfi_endproc
 1501              	.LFE45:
 1503              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1504              		.align	2
 1505              		.global	vTaskEndScheduler
 1506              		.thumb
 1507              		.thumb_func
 1509              	vTaskEndScheduler:
 1510              	.LFB46:
2062:FreeRTOS/Src/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1511              		.loc 1 2062 0
 1512              		.cfi_startproc
 1513              		@ args = 0, pretend = 0, frame = 0
 1514              		@ frame_needed = 0, uses_anonymous_args = 0
 1515 0000 08B5     		push	{r3, lr}
 1516              	.LCFI18:
 1517              		.cfi_def_cfa_offset 8
 1518              		.cfi_offset 3, -8
 1519              		.cfi_offset 14, -4
 1520              	.LBB38:
 1521              	.LBB39:
 195:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 1522              		.loc 2 195 0
 1523              		.syntax unified
 1524              	@ 195 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1525 0002 4FF0BF03 			mov r3, #191												
 1526 0006 83F31188 		msr basepri, r3											
 1527 000a BFF36F8F 		isb														
 1528 000e BFF34F8F 		dsb														
 1529              	
 1530              	@ 0 "" 2
 1531              		.thumb
 1532              		.syntax unified
 1533              	.LBE39:
 1534              	.LBE38:
2067:FreeRTOS/Src/tasks.c **** 	vPortEndScheduler();
 1535              		.loc 1 2067 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 123


 1536 0012 0022     		movs	r2, #0
 1537 0014 024B     		ldr	r3, .L122
 1538 0016 1A60     		str	r2, [r3]
2068:FreeRTOS/Src/tasks.c **** }
 1539              		.loc 1 2068 0
 1540 0018 FFF7FEFF 		bl	vPortEndScheduler
 1541              	.LVL130:
 1542 001c 08BD     		pop	{r3, pc}
 1543              	.L123:
 1544 001e 00BF     		.align	2
 1545              	.L122:
 1546 0020 00000000 		.word	.LANCHOR11
 1547              		.cfi_endproc
 1548              	.LFE46:
 1550              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1551              		.align	2
 1552              		.global	vTaskSuspendAll
 1553              		.thumb
 1554              		.thumb_func
 1556              	vTaskSuspendAll:
 1557              	.LFB47:
2073:FreeRTOS/Src/tasks.c **** 	/* A critical section is not required as the variable is of type
 1558              		.loc 1 2073 0
 1559              		.cfi_startproc
 1560              		@ args = 0, pretend = 0, frame = 0
 1561              		@ frame_needed = 0, uses_anonymous_args = 0
 1562              		@ link register save eliminated.
2078:FreeRTOS/Src/tasks.c **** }
 1563              		.loc 1 2078 0
 1564 0000 024A     		ldr	r2, .L125
 1565 0002 1368     		ldr	r3, [r2]
 1566 0004 0133     		adds	r3, r3, #1
 1567 0006 1360     		str	r3, [r2]
 1568 0008 7047     		bx	lr
 1569              	.L126:
 1570 000a 00BF     		.align	2
 1571              	.L125:
 1572 000c 00000000 		.word	.LANCHOR16
 1573              		.cfi_endproc
 1574              	.LFE47:
 1576              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1577              		.align	2
 1578              		.global	xTaskGetTickCount
 1579              		.thumb
 1580              		.thumb_func
 1582              	xTaskGetTickCount:
 1583              	.LFB49:
2256:FreeRTOS/Src/tasks.c **** TickType_t xTicks;
 1584              		.loc 1 2256 0
 1585              		.cfi_startproc
 1586              		@ args = 0, pretend = 0, frame = 0
 1587              		@ frame_needed = 0, uses_anonymous_args = 0
 1588              		@ link register save eliminated.
2262:FreeRTOS/Src/tasks.c **** 	}
 1589              		.loc 1 2262 0
 1590 0000 014B     		ldr	r3, .L128
 1591 0002 1868     		ldr	r0, [r3]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 124


 1592              	.LVL131:
2267:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 1593              		.loc 1 2267 0
 1594 0004 7047     		bx	lr
 1595              	.L129:
 1596 0006 00BF     		.align	2
 1597              	.L128:
 1598 0008 00000000 		.word	.LANCHOR15
 1599              		.cfi_endproc
 1600              	.LFE49:
 1602              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1603              		.align	2
 1604              		.global	xTaskGetTickCountFromISR
 1605              		.thumb
 1606              		.thumb_func
 1608              	xTaskGetTickCountFromISR:
 1609              	.LFB50:
2271:FreeRTOS/Src/tasks.c **** TickType_t xReturn;
 1610              		.loc 1 2271 0
 1611              		.cfi_startproc
 1612              		@ args = 0, pretend = 0, frame = 0
 1613              		@ frame_needed = 0, uses_anonymous_args = 0
 1614              		@ link register save eliminated.
 1615              	.LVL132:
2293:FreeRTOS/Src/tasks.c **** 	}
 1616              		.loc 1 2293 0
 1617 0000 014B     		ldr	r3, .L131
 1618 0002 1868     		ldr	r0, [r3]
 1619              	.LVL133:
2298:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 1620              		.loc 1 2298 0
 1621 0004 7047     		bx	lr
 1622              	.L132:
 1623 0006 00BF     		.align	2
 1624              	.L131:
 1625 0008 00000000 		.word	.LANCHOR15
 1626              		.cfi_endproc
 1627              	.LFE50:
 1629              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1630              		.align	2
 1631              		.global	uxTaskGetNumberOfTasks
 1632              		.thumb
 1633              		.thumb_func
 1635              	uxTaskGetNumberOfTasks:
 1636              	.LFB51:
2302:FreeRTOS/Src/tasks.c **** 	/* A critical section is not required because the variables are of type
 1637              		.loc 1 2302 0
 1638              		.cfi_startproc
 1639              		@ args = 0, pretend = 0, frame = 0
 1640              		@ frame_needed = 0, uses_anonymous_args = 0
 1641              		@ link register save eliminated.
2305:FreeRTOS/Src/tasks.c **** }
 1642              		.loc 1 2305 0
 1643 0000 014B     		ldr	r3, .L134
 1644 0002 1868     		ldr	r0, [r3]
2306:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 1645              		.loc 1 2306 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 125


 1646 0004 7047     		bx	lr
 1647              	.L135:
 1648 0006 00BF     		.align	2
 1649              	.L134:
 1650 0008 00000000 		.word	.LANCHOR9
 1651              		.cfi_endproc
 1652              	.LFE51:
 1654              		.section	.text.pcTaskGetName,"ax",%progbits
 1655              		.align	2
 1656              		.global	pcTaskGetName
 1657              		.thumb
 1658              		.thumb_func
 1660              	pcTaskGetName:
 1661              	.LFB52:
2310:FreeRTOS/Src/tasks.c **** TCB_t *pxTCB;
 1662              		.loc 1 2310 0
 1663              		.cfi_startproc
 1664              		@ args = 0, pretend = 0, frame = 0
 1665              		@ frame_needed = 0, uses_anonymous_args = 0
 1666              		@ link register save eliminated.
 1667              	.LVL134:
2315:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTCB );
 1668              		.loc 1 2315 0
 1669 0000 0346     		mov	r3, r0
 1670 0002 08B9     		cbnz	r0, .L137
2315:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTCB );
 1671              		.loc 1 2315 0 is_stmt 0 discriminator 1
 1672 0004 024B     		ldr	r3, .L138
 1673 0006 1B68     		ldr	r3, [r3]
 1674              	.LVL135:
 1675              	.L137:
2318:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 1676              		.loc 1 2318 0 is_stmt 1 discriminator 4
 1677 0008 03F13400 		add	r0, r3, #52
 1678 000c 7047     		bx	lr
 1679              	.L139:
 1680 000e 00BF     		.align	2
 1681              	.L138:
 1682 0010 00000000 		.word	.LANCHOR10
 1683              		.cfi_endproc
 1684              	.LFE52:
 1686              		.section	.text.xTaskIncrementTick,"ax",%progbits
 1687              		.align	2
 1688              		.global	xTaskIncrementTick
 1689              		.thumb
 1690              		.thumb_func
 1692              	xTaskIncrementTick:
 1693              	.LFB53:
2637:FreeRTOS/Src/tasks.c **** TCB_t * pxTCB;
 1694              		.loc 1 2637 0
 1695              		.cfi_startproc
 1696              		@ args = 0, pretend = 0, frame = 0
 1697              		@ frame_needed = 0, uses_anonymous_args = 0
 1698 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1699              	.LCFI19:
 1700              		.cfi_def_cfa_offset 24
 1701              		.cfi_offset 3, -24
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 126


 1702              		.cfi_offset 4, -20
 1703              		.cfi_offset 5, -16
 1704              		.cfi_offset 6, -12
 1705              		.cfi_offset 7, -8
 1706              		.cfi_offset 14, -4
 1707              	.LVL136:
2646:FreeRTOS/Src/tasks.c **** 	{
 1708              		.loc 1 2646 0
 1709 0002 354B     		ldr	r3, .L157
 1710 0004 1B68     		ldr	r3, [r3]
 1711 0006 002B     		cmp	r3, #0
 1712 0008 58D1     		bne	.L141
 1713              	.LBB40:
2650:FreeRTOS/Src/tasks.c **** 
 1714              		.loc 1 2650 0
 1715 000a 344B     		ldr	r3, .L157+4
 1716 000c 1E68     		ldr	r6, [r3]
 1717 000e 0136     		adds	r6, r6, #1
 1718              	.LVL137:
2654:FreeRTOS/Src/tasks.c **** 
 1719              		.loc 1 2654 0
 1720 0010 1E60     		str	r6, [r3]
2656:FreeRTOS/Src/tasks.c **** 		{
 1721              		.loc 1 2656 0
 1722 0012 5EB9     		cbnz	r6, .L142
 1723              	.LBB41:
2658:FreeRTOS/Src/tasks.c **** 		}
 1724              		.loc 1 2658 0
 1725 0014 324A     		ldr	r2, .L157+8
 1726 0016 1168     		ldr	r1, [r2]
 1727              	.LVL138:
 1728 0018 324B     		ldr	r3, .L157+12
 1729 001a 1868     		ldr	r0, [r3]
 1730 001c 1060     		str	r0, [r2]
 1731 001e 1960     		str	r1, [r3]
 1732 0020 314A     		ldr	r2, .L157+16
 1733 0022 1368     		ldr	r3, [r2]
 1734 0024 0133     		adds	r3, r3, #1
 1735 0026 1360     		str	r3, [r2]
 1736 0028 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1737              	.LVL139:
 1738              	.L142:
 1739              	.LBE41:
2669:FreeRTOS/Src/tasks.c **** 		{
 1740              		.loc 1 2669 0
 1741 002c 2F4B     		ldr	r3, .L157+20
 1742 002e 1B68     		ldr	r3, [r3]
 1743 0030 9E42     		cmp	r6, r3
 1744 0032 03D2     		bcs	.L152
 1745              	.LBE40:
2640:FreeRTOS/Src/tasks.c **** 
 1746              		.loc 1 2640 0
 1747 0034 0027     		movs	r7, #0
 1748 0036 36E0     		b	.L144
 1749              	.LVL140:
 1750              	.L153:
 1751              	.LBB42:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 127


2735:FreeRTOS/Src/tasks.c **** 						}
 1752              		.loc 1 2735 0
 1753 0038 0127     		movs	r7, #1
 1754              	.LVL141:
 1755 003a 00E0     		b	.L143
 1756              	.LVL142:
 1757              	.L152:
 1758 003c 0027     		movs	r7, #0
 1759              	.LVL143:
 1760              	.L143:
2673:FreeRTOS/Src/tasks.c **** 				{
 1761              		.loc 1 2673 0
 1762 003e 284B     		ldr	r3, .L157+8
 1763 0040 1B68     		ldr	r3, [r3]
 1764 0042 1B68     		ldr	r3, [r3]
 1765 0044 23B9     		cbnz	r3, .L145
2680:FreeRTOS/Src/tasks.c **** 					break;
 1766              		.loc 1 2680 0
 1767 0046 4FF0FF32 		mov	r2, #-1
 1768 004a 284B     		ldr	r3, .L157+20
 1769 004c 1A60     		str	r2, [r3]
2681:FreeRTOS/Src/tasks.c **** 				}
 1770              		.loc 1 2681 0
 1771 004e 2AE0     		b	.L144
 1772              	.L145:
2689:FreeRTOS/Src/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1773              		.loc 1 2689 0
 1774 0050 234B     		ldr	r3, .L157+8
 1775 0052 1B68     		ldr	r3, [r3]
 1776 0054 DB68     		ldr	r3, [r3, #12]
 1777 0056 DC68     		ldr	r4, [r3, #12]
 1778              	.LVL144:
2690:FreeRTOS/Src/tasks.c **** 
 1779              		.loc 1 2690 0
 1780 0058 6368     		ldr	r3, [r4, #4]
 1781              	.LVL145:
2692:FreeRTOS/Src/tasks.c **** 					{
 1782              		.loc 1 2692 0
 1783 005a 9E42     		cmp	r6, r3
 1784 005c 02D2     		bcs	.L146
2699:FreeRTOS/Src/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1785              		.loc 1 2699 0
 1786 005e 234A     		ldr	r2, .L157+20
 1787 0060 1360     		str	r3, [r2]
2700:FreeRTOS/Src/tasks.c **** 					}
 1788              		.loc 1 2700 0
 1789 0062 20E0     		b	.L144
 1790              	.L146:
2708:FreeRTOS/Src/tasks.c **** 
 1791              		.loc 1 2708 0
 1792 0064 251D     		adds	r5, r4, #4
 1793 0066 2846     		mov	r0, r5
 1794 0068 FFF7FEFF 		bl	uxListRemove
 1795              	.LVL146:
2712:FreeRTOS/Src/tasks.c **** 					{
 1796              		.loc 1 2712 0
 1797 006c A36A     		ldr	r3, [r4, #40]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 128


 1798 006e 1BB1     		cbz	r3, .L147
2714:FreeRTOS/Src/tasks.c **** 					}
 1799              		.loc 1 2714 0
 1800 0070 04F11800 		add	r0, r4, #24
 1801 0074 FFF7FEFF 		bl	uxListRemove
 1802              	.LVL147:
 1803              	.L147:
2723:FreeRTOS/Src/tasks.c **** 
 1804              		.loc 1 2723 0
 1805 0078 E36A     		ldr	r3, [r4, #44]
 1806 007a 0122     		movs	r2, #1
 1807 007c 02FA03F1 		lsl	r1, r2, r3
 1808 0080 1B48     		ldr	r0, .L157+24
 1809 0082 0268     		ldr	r2, [r0]
 1810 0084 0A43     		orrs	r2, r2, r1
 1811 0086 0260     		str	r2, [r0]
 1812 0088 03EB8303 		add	r3, r3, r3, lsl #2
 1813 008c 9A00     		lsls	r2, r3, #2
 1814 008e 2946     		mov	r1, r5
 1815 0090 1848     		ldr	r0, .L157+28
 1816 0092 1044     		add	r0, r0, r2
 1817 0094 FFF7FEFF 		bl	vListInsertEnd
 1818              	.LVL148:
2733:FreeRTOS/Src/tasks.c **** 						{
 1819              		.loc 1 2733 0
 1820 0098 E26A     		ldr	r2, [r4, #44]
 1821 009a 174B     		ldr	r3, .L157+32
 1822 009c 1B68     		ldr	r3, [r3]
 1823 009e DB6A     		ldr	r3, [r3, #44]
 1824 00a0 9A42     		cmp	r2, r3
 1825 00a2 C9D2     		bcs	.L153
 1826 00a4 CBE7     		b	.L143
 1827              	.LVL149:
 1828              	.L144:
2752:FreeRTOS/Src/tasks.c **** 			{
 1829              		.loc 1 2752 0
 1830 00a6 144B     		ldr	r3, .L157+32
 1831 00a8 1B68     		ldr	r3, [r3]
 1832 00aa DB6A     		ldr	r3, [r3, #44]
 1833 00ac 03EB8303 		add	r3, r3, r3, lsl #2
 1834 00b0 9A00     		lsls	r2, r3, #2
 1835 00b2 104B     		ldr	r3, .L157+28
 1836 00b4 9B58     		ldr	r3, [r3, r2]
 1837 00b6 012B     		cmp	r3, #1
 1838 00b8 06D8     		bhi	.L154
 1839 00ba 06E0     		b	.L150
 1840              	.LVL150:
 1841              	.L141:
 1842              	.LBE42:
2780:FreeRTOS/Src/tasks.c **** 
 1843              		.loc 1 2780 0
 1844 00bc 0F4A     		ldr	r2, .L157+36
 1845 00be 1368     		ldr	r3, [r2]
 1846 00c0 0133     		adds	r3, r3, #1
 1847 00c2 1360     		str	r3, [r2]
2640:FreeRTOS/Src/tasks.c **** 
 1848              		.loc 1 2640 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 129


 1849 00c4 0027     		movs	r7, #0
 1850 00c6 00E0     		b	.L150
 1851              	.LVL151:
 1852              	.L154:
 1853              	.LBB43:
2754:FreeRTOS/Src/tasks.c **** 			}
 1854              		.loc 1 2754 0
 1855 00c8 0127     		movs	r7, #1
 1856              	.LVL152:
 1857              	.L150:
 1858              	.LBE43:
2793:FreeRTOS/Src/tasks.c **** 		{
 1859              		.loc 1 2793 0
 1860 00ca 0D4B     		ldr	r3, .L157+40
 1861 00cc 1B68     		ldr	r3, [r3]
 1862 00ce 03B1     		cbz	r3, .L151
2795:FreeRTOS/Src/tasks.c **** 		}
 1863              		.loc 1 2795 0
 1864 00d0 0127     		movs	r7, #1
 1865              	.LVL153:
 1866              	.L151:
2805:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 1867              		.loc 1 2805 0
 1868 00d2 3846     		mov	r0, r7
 1869 00d4 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1870              	.LVL154:
 1871              	.L158:
 1872 00d6 00BF     		.align	2
 1873              	.L157:
 1874 00d8 00000000 		.word	.LANCHOR16
 1875 00dc 00000000 		.word	.LANCHOR15
 1876 00e0 00000000 		.word	.LANCHOR2
 1877 00e4 00000000 		.word	.LANCHOR8
 1878 00e8 00000000 		.word	.LANCHOR18
 1879 00ec 00000000 		.word	.LANCHOR3
 1880 00f0 00000000 		.word	.LANCHOR13
 1881 00f4 00000000 		.word	.LANCHOR4
 1882 00f8 00000000 		.word	.LANCHOR10
 1883 00fc 00000000 		.word	.LANCHOR19
 1884 0100 00000000 		.word	.LANCHOR20
 1885              		.cfi_endproc
 1886              	.LFE53:
 1888              		.section	.text.xTaskResumeAll,"ax",%progbits
 1889              		.align	2
 1890              		.global	xTaskResumeAll
 1891              		.thumb
 1892              		.thumb_func
 1894              	xTaskResumeAll:
 1895              	.LFB48:
2146:FreeRTOS/Src/tasks.c **** TCB_t *pxTCB = NULL;
 1896              		.loc 1 2146 0
 1897              		.cfi_startproc
 1898              		@ args = 0, pretend = 0, frame = 0
 1899              		@ frame_needed = 0, uses_anonymous_args = 0
 1900 0000 38B5     		push	{r3, r4, r5, lr}
 1901              	.LCFI20:
 1902              		.cfi_def_cfa_offset 16
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 130


 1903              		.cfi_offset 3, -16
 1904              		.cfi_offset 4, -12
 1905              		.cfi_offset 5, -8
 1906              		.cfi_offset 14, -4
 1907              	.LVL155:
2159:FreeRTOS/Src/tasks.c **** 	{
 1908              		.loc 1 2159 0
 1909 0002 FFF7FEFF 		bl	vPortEnterCritical
 1910              	.LVL156:
2161:FreeRTOS/Src/tasks.c **** 
 1911              		.loc 1 2161 0
 1912 0006 2D4B     		ldr	r3, .L172
 1913 0008 1A68     		ldr	r2, [r3]
 1914 000a 013A     		subs	r2, r2, #1
 1915 000c 1A60     		str	r2, [r3]
2163:FreeRTOS/Src/tasks.c **** 		{
 1916              		.loc 1 2163 0
 1917 000e 1B68     		ldr	r3, [r3]
 1918 0010 002B     		cmp	r3, #0
 1919 0012 4CD1     		bne	.L168
2165:FreeRTOS/Src/tasks.c **** 			{
 1920              		.loc 1 2165 0
 1921 0014 2A4B     		ldr	r3, .L172+4
 1922 0016 1B68     		ldr	r3, [r3]
 1923 0018 33BB     		cbnz	r3, .L169
2148:FreeRTOS/Src/tasks.c **** 
 1924              		.loc 1 2148 0
 1925 001a 0024     		movs	r4, #0
 1926 001c 4AE0     		b	.L160
 1927              	.LVL157:
 1928              	.L163:
2171:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1929              		.loc 1 2171 0
 1930 001e 294B     		ldr	r3, .L172+8
 1931 0020 DB68     		ldr	r3, [r3, #12]
 1932 0022 DC68     		ldr	r4, [r3, #12]
 1933              	.LVL158:
2172:FreeRTOS/Src/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1934              		.loc 1 2172 0
 1935 0024 04F11800 		add	r0, r4, #24
 1936 0028 FFF7FEFF 		bl	uxListRemove
 1937              	.LVL159:
2173:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1938              		.loc 1 2173 0
 1939 002c 251D     		adds	r5, r4, #4
 1940 002e 2846     		mov	r0, r5
 1941 0030 FFF7FEFF 		bl	uxListRemove
 1942              	.LVL160:
2174:FreeRTOS/Src/tasks.c **** 
 1943              		.loc 1 2174 0
 1944 0034 E36A     		ldr	r3, [r4, #44]
 1945 0036 0122     		movs	r2, #1
 1946 0038 02FA03F1 		lsl	r1, r2, r3
 1947 003c 2248     		ldr	r0, .L172+12
 1948 003e 0268     		ldr	r2, [r0]
 1949 0040 0A43     		orrs	r2, r2, r1
 1950 0042 0260     		str	r2, [r0]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 131


 1951 0044 03EB8303 		add	r3, r3, r3, lsl #2
 1952 0048 9A00     		lsls	r2, r3, #2
 1953 004a 2946     		mov	r1, r5
 1954 004c 1F48     		ldr	r0, .L172+16
 1955 004e 1044     		add	r0, r0, r2
 1956 0050 FFF7FEFF 		bl	vListInsertEnd
 1957              	.LVL161:
2178:FreeRTOS/Src/tasks.c **** 					{
 1958              		.loc 1 2178 0
 1959 0054 E26A     		ldr	r2, [r4, #44]
 1960 0056 1E4B     		ldr	r3, .L172+20
 1961 0058 1B68     		ldr	r3, [r3]
 1962 005a DB6A     		ldr	r3, [r3, #44]
 1963 005c 9A42     		cmp	r2, r3
 1964 005e 04D3     		bcc	.L161
2180:FreeRTOS/Src/tasks.c **** 					}
 1965              		.loc 1 2180 0
 1966 0060 0122     		movs	r2, #1
 1967 0062 1C4B     		ldr	r3, .L172+24
 1968 0064 1A60     		str	r2, [r3]
 1969 0066 00E0     		b	.L161
 1970              	.LVL162:
 1971              	.L169:
 1972 0068 0024     		movs	r4, #0
 1973              	.LVL163:
 1974              	.L161:
2169:FreeRTOS/Src/tasks.c **** 				{
 1975              		.loc 1 2169 0
 1976 006a 164B     		ldr	r3, .L172+8
 1977 006c 1B68     		ldr	r3, [r3]
 1978 006e 002B     		cmp	r3, #0
 1979 0070 D5D1     		bne	.L163
2188:FreeRTOS/Src/tasks.c **** 				{
 1980              		.loc 1 2188 0
 1981 0072 0CB1     		cbz	r4, .L164
2196:FreeRTOS/Src/tasks.c **** 				}
 1982              		.loc 1 2196 0
 1983 0074 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1984              	.LVL164:
 1985              	.L164:
 1986              	.LBB44:
2204:FreeRTOS/Src/tasks.c **** 
 1987              		.loc 1 2204 0
 1988 0078 174B     		ldr	r3, .L172+28
 1989 007a 1C68     		ldr	r4, [r3]
 1990              	.LVL165:
2206:FreeRTOS/Src/tasks.c **** 					{
 1991              		.loc 1 2206 0
 1992 007c 54B1     		cbz	r4, .L165
 1993              	.L167:
2210:FreeRTOS/Src/tasks.c **** 							{
 1994              		.loc 1 2210 0
 1995 007e FFF7FEFF 		bl	xTaskIncrementTick
 1996              	.LVL166:
 1997 0082 10B1     		cbz	r0, .L166
2212:FreeRTOS/Src/tasks.c **** 							}
 1998              		.loc 1 2212 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 132


 1999 0084 0122     		movs	r2, #1
 2000 0086 134B     		ldr	r3, .L172+24
 2001 0088 1A60     		str	r2, [r3]
 2002              	.L166:
 2003              	.LVL167:
2219:FreeRTOS/Src/tasks.c **** 
 2004              		.loc 1 2219 0
 2005 008a 013C     		subs	r4, r4, #1
 2006              	.LVL168:
 2007 008c F7D1     		bne	.L167
2221:FreeRTOS/Src/tasks.c **** 					}
 2008              		.loc 1 2221 0
 2009 008e 0022     		movs	r2, #0
 2010 0090 114B     		ldr	r3, .L172+28
 2011 0092 1A60     		str	r2, [r3]
 2012              	.L165:
 2013              	.LBE44:
2229:FreeRTOS/Src/tasks.c **** 				{
 2014              		.loc 1 2229 0
 2015 0094 0F4B     		ldr	r3, .L172+24
 2016 0096 1B68     		ldr	r3, [r3]
 2017 0098 5BB1     		cbz	r3, .L170
 2018              	.LVL169:
2236:FreeRTOS/Src/tasks.c **** 				}
 2019              		.loc 1 2236 0
 2020 009a 4FF08052 		mov	r2, #268435456
 2021 009e 0F4B     		ldr	r3, .L172+32
 2022 00a0 1A60     		str	r2, [r3]
 2023              		.syntax unified
 2024              	@ 2236 "FreeRTOS/Src/tasks.c" 1
 2025 00a2 BFF34F8F 		dsb
 2026              	@ 0 "" 2
 2027              	@ 2236 "FreeRTOS/Src/tasks.c" 1
 2028 00a6 BFF36F8F 		isb
 2029              	@ 0 "" 2
2233:FreeRTOS/Src/tasks.c **** 					}
 2030              		.loc 1 2233 0
 2031              		.thumb
 2032              		.syntax unified
 2033 00aa 0124     		movs	r4, #1
 2034              	.LVL170:
 2035 00ac 02E0     		b	.L160
 2036              	.LVL171:
 2037              	.L168:
2148:FreeRTOS/Src/tasks.c **** 
 2038              		.loc 1 2148 0
 2039 00ae 0024     		movs	r4, #0
 2040 00b0 00E0     		b	.L160
 2041              	.LVL172:
 2042              	.L170:
 2043 00b2 0024     		movs	r4, #0
 2044              	.LVL173:
 2045              	.L160:
2249:FreeRTOS/Src/tasks.c **** 
 2046              		.loc 1 2249 0
 2047 00b4 FFF7FEFF 		bl	vPortExitCritical
 2048              	.LVL174:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 133


2252:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 2049              		.loc 1 2252 0
 2050 00b8 2046     		mov	r0, r4
 2051 00ba 38BD     		pop	{r3, r4, r5, pc}
 2052              	.LVL175:
 2053              	.L173:
 2054              		.align	2
 2055              	.L172:
 2056 00bc 00000000 		.word	.LANCHOR16
 2057 00c0 00000000 		.word	.LANCHOR9
 2058 00c4 00000000 		.word	.LANCHOR1
 2059 00c8 00000000 		.word	.LANCHOR13
 2060 00cc 00000000 		.word	.LANCHOR4
 2061 00d0 00000000 		.word	.LANCHOR10
 2062 00d4 00000000 		.word	.LANCHOR20
 2063 00d8 00000000 		.word	.LANCHOR19
 2064 00dc 04ED00E0 		.word	-536810236
 2065              		.cfi_endproc
 2066              	.LFE48:
 2068              		.section	.text.vTaskDelayUntil,"ax",%progbits
 2069              		.align	2
 2070              		.global	vTaskDelayUntil
 2071              		.thumb
 2072              		.thumb_func
 2074              	vTaskDelayUntil:
 2075              	.LFB36:
1222:FreeRTOS/Src/tasks.c **** 	TickType_t xTimeToWake;
 2076              		.loc 1 1222 0
 2077              		.cfi_startproc
 2078              		@ args = 0, pretend = 0, frame = 0
 2079              		@ frame_needed = 0, uses_anonymous_args = 0
 2080              	.LVL176:
 2081 0000 38B5     		push	{r3, r4, r5, lr}
 2082              	.LCFI21:
 2083              		.cfi_def_cfa_offset 16
 2084              		.cfi_offset 3, -16
 2085              		.cfi_offset 4, -12
 2086              		.cfi_offset 5, -8
 2087              		.cfi_offset 14, -4
 2088 0002 0546     		mov	r5, r0
 2089 0004 0C46     		mov	r4, r1
 2090              	.LVL177:
1230:FreeRTOS/Src/tasks.c **** 		{
 2091              		.loc 1 1230 0
 2092 0006 FFF7FEFF 		bl	vTaskSuspendAll
 2093              	.LVL178:
 2094              	.LBB45:
1234:FreeRTOS/Src/tasks.c **** 
 2095              		.loc 1 1234 0
 2096 000a 154B     		ldr	r3, .L184
 2097 000c 1868     		ldr	r0, [r3]
 2098              	.LVL179:
1237:FreeRTOS/Src/tasks.c **** 
 2099              		.loc 1 1237 0
 2100 000e 2A68     		ldr	r2, [r5]
 2101 0010 1319     		adds	r3, r2, r4
 2102              	.LVL180:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 134


1239:FreeRTOS/Src/tasks.c **** 			{
 2103              		.loc 1 1239 0
 2104 0012 9042     		cmp	r0, r2
 2105 0014 05D2     		bcs	.L175
1246:FreeRTOS/Src/tasks.c **** 				{
 2106              		.loc 1 1246 0
 2107 0016 9A42     		cmp	r2, r3
 2108 0018 09D9     		bls	.L179
1246:FreeRTOS/Src/tasks.c **** 				{
 2109              		.loc 1 1246 0 is_stmt 0 discriminator 1
 2110 001a 9842     		cmp	r0, r3
 2111 001c 09D3     		bcc	.L180
 2112              	.LBE45:
1224:FreeRTOS/Src/tasks.c **** 
 2113              		.loc 1 1224 0 is_stmt 1
 2114 001e 0022     		movs	r2, #0
 2115 0020 0CE0     		b	.L176
 2116              	.L175:
 2117              	.LBB46:
1260:FreeRTOS/Src/tasks.c **** 				{
 2118              		.loc 1 1260 0
 2119 0022 9A42     		cmp	r2, r3
 2120 0024 07D8     		bhi	.L181
1260:FreeRTOS/Src/tasks.c **** 				{
 2121              		.loc 1 1260 0 is_stmt 0 discriminator 1
 2122 0026 9842     		cmp	r0, r3
 2123 0028 07D3     		bcc	.L182
 2124              	.LBE46:
1224:FreeRTOS/Src/tasks.c **** 
 2125              		.loc 1 1224 0 is_stmt 1
 2126 002a 0022     		movs	r2, #0
 2127 002c 06E0     		b	.L176
 2128              	.L179:
 2129 002e 0022     		movs	r2, #0
 2130 0030 04E0     		b	.L176
 2131              	.L180:
 2132              	.LBB47:
1248:FreeRTOS/Src/tasks.c **** 				}
 2133              		.loc 1 1248 0
 2134 0032 0122     		movs	r2, #1
 2135 0034 02E0     		b	.L176
 2136              	.L181:
1262:FreeRTOS/Src/tasks.c **** 				}
 2137              		.loc 1 1262 0
 2138 0036 0122     		movs	r2, #1
 2139 0038 00E0     		b	.L176
 2140              	.L182:
 2141 003a 0122     		movs	r2, #1
 2142              	.L176:
 2143              	.LVL181:
1271:FreeRTOS/Src/tasks.c **** 
 2144              		.loc 1 1271 0
 2145 003c 2B60     		str	r3, [r5]
1273:FreeRTOS/Src/tasks.c **** 			{
 2146              		.loc 1 1273 0
 2147 003e 1AB1     		cbz	r2, .L177
1279:FreeRTOS/Src/tasks.c **** 			}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 135


 2148              		.loc 1 1279 0
 2149 0040 0021     		movs	r1, #0
 2150 0042 181A     		subs	r0, r3, r0
 2151              	.LVL182:
 2152 0044 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2153              	.LVL183:
 2154              	.L177:
 2155              	.LBE47:
1286:FreeRTOS/Src/tasks.c **** 
 2156              		.loc 1 1286 0
 2157 0048 FFF7FEFF 		bl	xTaskResumeAll
 2158              	.LVL184:
1290:FreeRTOS/Src/tasks.c **** 		{
 2159              		.loc 1 1290 0
 2160 004c 38B9     		cbnz	r0, .L174
1292:FreeRTOS/Src/tasks.c **** 		}
 2161              		.loc 1 1292 0
 2162 004e 4FF08052 		mov	r2, #268435456
 2163 0052 044B     		ldr	r3, .L184+4
 2164 0054 1A60     		str	r2, [r3]
 2165              		.syntax unified
 2166              	@ 1292 "FreeRTOS/Src/tasks.c" 1
 2167 0056 BFF34F8F 		dsb
 2168              	@ 0 "" 2
 2169              	@ 1292 "FreeRTOS/Src/tasks.c" 1
 2170 005a BFF36F8F 		isb
 2171              	@ 0 "" 2
 2172              		.thumb
 2173              		.syntax unified
 2174              	.L174:
 2175 005e 38BD     		pop	{r3, r4, r5, pc}
 2176              	.LVL185:
 2177              	.L185:
 2178              		.align	2
 2179              	.L184:
 2180 0060 00000000 		.word	.LANCHOR15
 2181 0064 04ED00E0 		.word	-536810236
 2182              		.cfi_endproc
 2183              	.LFE36:
 2185              		.section	.text.vTaskDelay,"ax",%progbits
 2186              		.align	2
 2187              		.global	vTaskDelay
 2188              		.thumb
 2189              		.thumb_func
 2191              	vTaskDelay:
 2192              	.LFB37:
1306:FreeRTOS/Src/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 2193              		.loc 1 1306 0
 2194              		.cfi_startproc
 2195              		@ args = 0, pretend = 0, frame = 0
 2196              		@ frame_needed = 0, uses_anonymous_args = 0
 2197              	.LVL186:
 2198 0000 10B5     		push	{r4, lr}
 2199              	.LCFI22:
 2200              		.cfi_def_cfa_offset 8
 2201              		.cfi_offset 4, -8
 2202              		.cfi_offset 14, -4
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 136


 2203              	.LVL187:
1310:FreeRTOS/Src/tasks.c **** 		{
 2204              		.loc 1 1310 0
 2205 0002 48B1     		cbz	r0, .L189
 2206 0004 0446     		mov	r4, r0
1313:FreeRTOS/Src/tasks.c **** 			{
 2207              		.loc 1 1313 0
 2208 0006 FFF7FEFF 		bl	vTaskSuspendAll
 2209              	.LVL188:
1324:FreeRTOS/Src/tasks.c **** 			}
 2210              		.loc 1 1324 0
 2211 000a 0021     		movs	r1, #0
 2212 000c 2046     		mov	r0, r4
 2213 000e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2214              	.LVL189:
1326:FreeRTOS/Src/tasks.c **** 		}
 2215              		.loc 1 1326 0
 2216 0012 FFF7FEFF 		bl	xTaskResumeAll
 2217              	.LVL190:
 2218 0016 00E0     		b	.L187
 2219              	.LVL191:
 2220              	.L189:
1307:FreeRTOS/Src/tasks.c **** 
 2221              		.loc 1 1307 0
 2222 0018 0020     		movs	r0, #0
 2223              	.LVL192:
 2224              	.L187:
1335:FreeRTOS/Src/tasks.c **** 		{
 2225              		.loc 1 1335 0
 2226 001a 38B9     		cbnz	r0, .L186
1337:FreeRTOS/Src/tasks.c **** 		}
 2227              		.loc 1 1337 0
 2228 001c 4FF08052 		mov	r2, #268435456
 2229 0020 034B     		ldr	r3, .L191
 2230 0022 1A60     		str	r2, [r3]
 2231              		.syntax unified
 2232              	@ 1337 "FreeRTOS/Src/tasks.c" 1
 2233 0024 BFF34F8F 		dsb
 2234              	@ 0 "" 2
 2235              	@ 1337 "FreeRTOS/Src/tasks.c" 1
 2236 0028 BFF36F8F 		isb
 2237              	@ 0 "" 2
 2238              		.thumb
 2239              		.syntax unified
 2240              	.L186:
 2241 002c 10BD     		pop	{r4, pc}
 2242              	.L192:
 2243 002e 00BF     		.align	2
 2244              	.L191:
 2245 0030 04ED00E0 		.word	-536810236
 2246              		.cfi_endproc
 2247              	.LFE37:
 2249              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2250              		.align	2
 2251              		.global	vTaskSwitchContext
 2252              		.thumb
 2253              		.thumb_func
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 137


 2255              	vTaskSwitchContext:
 2256              	.LFB54:
2901:FreeRTOS/Src/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2257              		.loc 1 2901 0
 2258              		.cfi_startproc
 2259              		@ args = 0, pretend = 0, frame = 0
 2260              		@ frame_needed = 0, uses_anonymous_args = 0
 2261              		@ link register save eliminated.
2902:FreeRTOS/Src/tasks.c **** 	{
 2262              		.loc 1 2902 0
 2263 0000 184B     		ldr	r3, .L198
 2264 0002 1B68     		ldr	r3, [r3]
 2265 0004 1BB1     		cbz	r3, .L194
2906:FreeRTOS/Src/tasks.c **** 	}
 2266              		.loc 1 2906 0
 2267 0006 0122     		movs	r2, #1
 2268 0008 174B     		ldr	r3, .L198+4
 2269 000a 1A60     		str	r2, [r3]
 2270 000c 7047     		bx	lr
 2271              	.L194:
2901:FreeRTOS/Src/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2272              		.loc 1 2901 0
 2273 000e 30B4     		push	{r4, r5}
 2274              	.LCFI23:
 2275              		.cfi_def_cfa_offset 8
 2276              		.cfi_offset 4, -8
 2277              		.cfi_offset 5, -4
2910:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2278              		.loc 1 2910 0
 2279 0010 0022     		movs	r2, #0
 2280 0012 154B     		ldr	r3, .L198+4
 2281 0014 1A60     		str	r2, [r3]
 2282              	.LBB48:
2952:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_IN();
 2283              		.loc 1 2952 0
 2284 0016 154B     		ldr	r3, .L198+8
 2285 0018 1B68     		ldr	r3, [r3]
 2286              	.LVL193:
 2287              	.LBB49:
 2288              	.LBB50:
 134:FreeRTOS/ARM_CM3/portmacro.h **** 		return ucReturn;
 2289              		.loc 2 134 0
 2290              		.syntax unified
 2291              	@ 134 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2292 001a B3FA83F3 		clz r3, r3
 2293              	@ 0 "" 2
 2294              	.LVL194:
 2295              		.thumb
 2296              		.syntax unified
 2297 001e DBB2     		uxtb	r3, r3
 2298              	.LBE50:
 2299              	.LBE49:
2952:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_IN();
 2300              		.loc 1 2952 0
 2301 0020 C3F11F03 		rsb	r3, r3, #31
 2302              	.LVL195:
 2303              	.LBB51:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 138


 2304 0024 124D     		ldr	r5, .L198+12
 2305 0026 9900     		lsls	r1, r3, #2
 2306 0028 CA18     		adds	r2, r1, r3
 2307 002a 9000     		lsls	r0, r2, #2
 2308 002c 2844     		add	r0, r0, r5
 2309 002e 4268     		ldr	r2, [r0, #4]
 2310 0030 5468     		ldr	r4, [r2, #4]
 2311 0032 4460     		str	r4, [r0, #4]
 2312 0034 1944     		add	r1, r1, r3
 2313 0036 8A00     		lsls	r2, r1, #2
 2314 0038 0832     		adds	r2, r2, #8
 2315 003a 2A44     		add	r2, r2, r5
 2316 003c 9442     		cmp	r4, r2
 2317 003e 05D1     		bne	.L196
2952:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_IN();
 2318              		.loc 1 2952 0 is_stmt 0 discriminator 1
 2319 0040 6068     		ldr	r0, [r4, #4]
 2320 0042 03EB8301 		add	r1, r3, r3, lsl #2
 2321 0046 8A00     		lsls	r2, r1, #2
 2322 0048 2A44     		add	r2, r2, r5
 2323 004a 5060     		str	r0, [r2, #4]
 2324              	.L196:
2952:FreeRTOS/Src/tasks.c **** 		traceTASK_SWITCHED_IN();
 2325              		.loc 1 2952 0 discriminator 3
 2326 004c 03EB8303 		add	r3, r3, r3, lsl #2
 2327              	.LVL196:
 2328 0050 9A00     		lsls	r2, r3, #2
 2329 0052 074B     		ldr	r3, .L198+12
 2330 0054 1A44     		add	r2, r2, r3
 2331 0056 5368     		ldr	r3, [r2, #4]
 2332 0058 DA68     		ldr	r2, [r3, #12]
 2333 005a 064B     		ldr	r3, .L198+16
 2334 005c 1A60     		str	r2, [r3]
 2335              	.LBE51:
 2336              	.LBE48:
2970:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 2337              		.loc 1 2970 0 is_stmt 1 discriminator 3
 2338 005e 30BC     		pop	{r4, r5}
 2339              	.LCFI24:
 2340              		.cfi_restore 5
 2341              		.cfi_restore 4
 2342              		.cfi_def_cfa_offset 0
 2343 0060 7047     		bx	lr
 2344              	.L199:
 2345 0062 00BF     		.align	2
 2346              	.L198:
 2347 0064 00000000 		.word	.LANCHOR16
 2348 0068 00000000 		.word	.LANCHOR20
 2349 006c 00000000 		.word	.LANCHOR13
 2350 0070 00000000 		.word	.LANCHOR4
 2351 0074 00000000 		.word	.LANCHOR10
 2352              		.cfi_endproc
 2353              	.LFE54:
 2355              		.section	.text.vTaskSuspend,"ax",%progbits
 2356              		.align	2
 2357              		.global	vTaskSuspend
 2358              		.thumb
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 139


 2359              		.thumb_func
 2361              	vTaskSuspend:
 2362              	.LFB41:
1669:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
 2363              		.loc 1 1669 0
 2364              		.cfi_startproc
 2365              		@ args = 0, pretend = 0, frame = 0
 2366              		@ frame_needed = 0, uses_anonymous_args = 0
 2367              	.LVL197:
 2368 0000 38B5     		push	{r3, r4, r5, lr}
 2369              	.LCFI25:
 2370              		.cfi_def_cfa_offset 16
 2371              		.cfi_offset 3, -16
 2372              		.cfi_offset 4, -12
 2373              		.cfi_offset 5, -8
 2374              		.cfi_offset 14, -4
 2375 0002 0446     		mov	r4, r0
1672:FreeRTOS/Src/tasks.c **** 		{
 2376              		.loc 1 1672 0
 2377 0004 FFF7FEFF 		bl	vPortEnterCritical
 2378              	.LVL198:
1676:FreeRTOS/Src/tasks.c **** 
 2379              		.loc 1 1676 0
 2380 0008 0CB9     		cbnz	r4, .L201
1676:FreeRTOS/Src/tasks.c **** 
 2381              		.loc 1 1676 0 is_stmt 0 discriminator 1
 2382 000a 284B     		ldr	r3, .L210
 2383 000c 1C68     		ldr	r4, [r3]
 2384              	.LVL199:
 2385              	.L201:
1682:FreeRTOS/Src/tasks.c **** 			{
 2386              		.loc 1 1682 0 is_stmt 1 discriminator 4
 2387 000e 251D     		adds	r5, r4, #4
 2388 0010 2846     		mov	r0, r5
 2389 0012 FFF7FEFF 		bl	uxListRemove
 2390              	.LVL200:
 2391 0016 70B9     		cbnz	r0, .L202
1684:FreeRTOS/Src/tasks.c **** 			}
 2392              		.loc 1 1684 0
 2393 0018 E36A     		ldr	r3, [r4, #44]
 2394 001a 03EB8301 		add	r1, r3, r3, lsl #2
 2395 001e 8A00     		lsls	r2, r1, #2
 2396 0020 2349     		ldr	r1, .L210+4
 2397 0022 8A58     		ldr	r2, [r1, r2]
 2398 0024 3AB9     		cbnz	r2, .L202
1684:FreeRTOS/Src/tasks.c **** 			}
 2399              		.loc 1 1684 0 is_stmt 0 discriminator 1
 2400 0026 0122     		movs	r2, #1
 2401 0028 02FA03F3 		lsl	r3, r2, r3
 2402 002c 2149     		ldr	r1, .L210+8
 2403 002e 0A68     		ldr	r2, [r1]
 2404 0030 22EA0303 		bic	r3, r2, r3
 2405 0034 0B60     		str	r3, [r1]
 2406              	.L202:
1692:FreeRTOS/Src/tasks.c **** 			{
 2407              		.loc 1 1692 0 is_stmt 1
 2408 0036 A36A     		ldr	r3, [r4, #40]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 140


 2409 0038 1BB1     		cbz	r3, .L203
1694:FreeRTOS/Src/tasks.c **** 			}
 2410              		.loc 1 1694 0
 2411 003a 04F11800 		add	r0, r4, #24
 2412 003e FFF7FEFF 		bl	uxListRemove
 2413              	.LVL201:
 2414              	.L203:
1701:FreeRTOS/Src/tasks.c **** 
 2415              		.loc 1 1701 0
 2416 0042 2946     		mov	r1, r5
 2417 0044 1C48     		ldr	r0, .L210+12
 2418 0046 FFF7FEFF 		bl	vListInsertEnd
 2419              	.LVL202:
1705:FreeRTOS/Src/tasks.c **** 				{
 2420              		.loc 1 1705 0
 2421 004a 94F84830 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 2422 004e DBB2     		uxtb	r3, r3
 2423 0050 012B     		cmp	r3, #1
 2424 0052 02D1     		bne	.L204
1709:FreeRTOS/Src/tasks.c **** 				}
 2425              		.loc 1 1709 0
 2426 0054 0023     		movs	r3, #0
 2427 0056 84F84830 		strb	r3, [r4, #72]
 2428              	.L204:
1714:FreeRTOS/Src/tasks.c **** 
 2429              		.loc 1 1714 0
 2430 005a FFF7FEFF 		bl	vPortExitCritical
 2431              	.LVL203:
1716:FreeRTOS/Src/tasks.c **** 		{
 2432              		.loc 1 1716 0
 2433 005e 174B     		ldr	r3, .L210+16
 2434 0060 1B68     		ldr	r3, [r3]
 2435 0062 2BB1     		cbz	r3, .L205
1720:FreeRTOS/Src/tasks.c **** 			{
 2436              		.loc 1 1720 0
 2437 0064 FFF7FEFF 		bl	vPortEnterCritical
 2438              	.LVL204:
1722:FreeRTOS/Src/tasks.c **** 			}
 2439              		.loc 1 1722 0
 2440 0068 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2441              	.LVL205:
1724:FreeRTOS/Src/tasks.c **** 		}
 2442              		.loc 1 1724 0
 2443 006c FFF7FEFF 		bl	vPortExitCritical
 2444              	.LVL206:
 2445              	.L205:
1731:FreeRTOS/Src/tasks.c **** 		{
 2446              		.loc 1 1731 0
 2447 0070 0E4B     		ldr	r3, .L210
 2448 0072 1B68     		ldr	r3, [r3]
 2449 0074 9C42     		cmp	r4, r3
 2450 0076 17D1     		bne	.L200
1733:FreeRTOS/Src/tasks.c **** 			{
 2451              		.loc 1 1733 0
 2452 0078 104B     		ldr	r3, .L210+16
 2453 007a 1B68     		ldr	r3, [r3]
 2454 007c 43B1     		cbz	r3, .L207
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 141


1737:FreeRTOS/Src/tasks.c **** 			}
 2455              		.loc 1 1737 0
 2456 007e 4FF08052 		mov	r2, #268435456
 2457 0082 0F4B     		ldr	r3, .L210+20
 2458 0084 1A60     		str	r2, [r3]
 2459              		.syntax unified
 2460              	@ 1737 "FreeRTOS/Src/tasks.c" 1
 2461 0086 BFF34F8F 		dsb
 2462              	@ 0 "" 2
 2463              	@ 1737 "FreeRTOS/Src/tasks.c" 1
 2464 008a BFF36F8F 		isb
 2465              	@ 0 "" 2
 2466              		.thumb
 2467              		.syntax unified
 2468 008e 38BD     		pop	{r3, r4, r5, pc}
 2469              	.LVL207:
 2470              	.L207:
1744:FreeRTOS/Src/tasks.c **** 				{
 2471              		.loc 1 1744 0
 2472 0090 094B     		ldr	r3, .L210+12
 2473 0092 1A68     		ldr	r2, [r3]
 2474 0094 0B4B     		ldr	r3, .L210+24
 2475 0096 1B68     		ldr	r3, [r3]
 2476 0098 9A42     		cmp	r2, r3
 2477 009a 03D1     		bne	.L208
1750:FreeRTOS/Src/tasks.c **** 				}
 2478              		.loc 1 1750 0
 2479 009c 0022     		movs	r2, #0
 2480 009e 034B     		ldr	r3, .L210
 2481 00a0 1A60     		str	r2, [r3]
 2482 00a2 38BD     		pop	{r3, r4, r5, pc}
 2483              	.LVL208:
 2484              	.L208:
1754:FreeRTOS/Src/tasks.c **** 				}
 2485              		.loc 1 1754 0
 2486 00a4 FFF7FEFF 		bl	vTaskSwitchContext
 2487              	.LVL209:
 2488              	.L200:
 2489 00a8 38BD     		pop	{r3, r4, r5, pc}
 2490              	.LVL210:
 2491              	.L211:
 2492 00aa 00BF     		.align	2
 2493              	.L210:
 2494 00ac 00000000 		.word	.LANCHOR10
 2495 00b0 00000000 		.word	.LANCHOR4
 2496 00b4 00000000 		.word	.LANCHOR13
 2497 00b8 00000000 		.word	.LANCHOR0
 2498 00bc 00000000 		.word	.LANCHOR11
 2499 00c0 04ED00E0 		.word	-536810236
 2500 00c4 00000000 		.word	.LANCHOR9
 2501              		.cfi_endproc
 2502              	.LFE41:
 2504              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2505              		.align	2
 2506              		.global	vTaskPlaceOnEventList
 2507              		.thumb
 2508              		.thumb_func
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 142


 2510              	vTaskPlaceOnEventList:
 2511              	.LFB55:
2974:FreeRTOS/Src/tasks.c **** 	configASSERT( pxEventList );
 2512              		.loc 1 2974 0
 2513              		.cfi_startproc
 2514              		@ args = 0, pretend = 0, frame = 0
 2515              		@ frame_needed = 0, uses_anonymous_args = 0
 2516              	.LVL211:
 2517 0000 10B5     		push	{r4, lr}
 2518              	.LCFI26:
 2519              		.cfi_def_cfa_offset 8
 2520              		.cfi_offset 4, -8
 2521              		.cfi_offset 14, -4
 2522 0002 0C46     		mov	r4, r1
2984:FreeRTOS/Src/tasks.c **** 
 2523              		.loc 1 2984 0
 2524 0004 044B     		ldr	r3, .L214
 2525 0006 1968     		ldr	r1, [r3]
 2526              	.LVL212:
 2527 0008 1831     		adds	r1, r1, #24
 2528 000a FFF7FEFF 		bl	vListInsert
 2529              	.LVL213:
2986:FreeRTOS/Src/tasks.c **** }
 2530              		.loc 1 2986 0
 2531 000e 0121     		movs	r1, #1
 2532 0010 2046     		mov	r0, r4
 2533 0012 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2534              	.LVL214:
 2535 0016 10BD     		pop	{r4, pc}
 2536              	.LVL215:
 2537              	.L215:
 2538              		.align	2
 2539              	.L214:
 2540 0018 00000000 		.word	.LANCHOR10
 2541              		.cfi_endproc
 2542              	.LFE55:
 2544              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2545              		.align	2
 2546              		.global	vTaskPlaceOnUnorderedEventList
 2547              		.thumb
 2548              		.thumb_func
 2550              	vTaskPlaceOnUnorderedEventList:
 2551              	.LFB56:
2991:FreeRTOS/Src/tasks.c **** 	configASSERT( pxEventList );
 2552              		.loc 1 2991 0
 2553              		.cfi_startproc
 2554              		@ args = 0, pretend = 0, frame = 0
 2555              		@ frame_needed = 0, uses_anonymous_args = 0
 2556              	.LVL216:
 2557 0000 10B5     		push	{r4, lr}
 2558              	.LCFI27:
 2559              		.cfi_def_cfa_offset 8
 2560              		.cfi_offset 4, -8
 2561              		.cfi_offset 14, -4
 2562 0002 1446     		mov	r4, r2
3001:FreeRTOS/Src/tasks.c **** 
 2563              		.loc 1 3001 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 143


 2564 0004 064B     		ldr	r3, .L218
 2565 0006 1A68     		ldr	r2, [r3]
 2566              	.LVL217:
 2567 0008 41F00041 		orr	r1, r1, #-2147483648
 2568              	.LVL218:
 2569 000c 9161     		str	r1, [r2, #24]
3008:FreeRTOS/Src/tasks.c **** 
 2570              		.loc 1 3008 0
 2571 000e 1968     		ldr	r1, [r3]
 2572 0010 1831     		adds	r1, r1, #24
 2573 0012 FFF7FEFF 		bl	vListInsertEnd
 2574              	.LVL219:
3010:FreeRTOS/Src/tasks.c **** }
 2575              		.loc 1 3010 0
 2576 0016 0121     		movs	r1, #1
 2577 0018 2046     		mov	r0, r4
 2578 001a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2579              	.LVL220:
 2580 001e 10BD     		pop	{r4, pc}
 2581              	.LVL221:
 2582              	.L219:
 2583              		.align	2
 2584              	.L218:
 2585 0020 00000000 		.word	.LANCHOR10
 2586              		.cfi_endproc
 2587              	.LFE56:
 2589              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2590              		.align	2
 2591              		.global	xTaskRemoveFromEventList
 2592              		.thumb
 2593              		.thumb_func
 2595              	xTaskRemoveFromEventList:
 2596              	.LFB57:
3048:FreeRTOS/Src/tasks.c **** TCB_t *pxUnblockedTCB;
 2597              		.loc 1 3048 0
 2598              		.cfi_startproc
 2599              		@ args = 0, pretend = 0, frame = 0
 2600              		@ frame_needed = 0, uses_anonymous_args = 0
 2601              	.LVL222:
 2602 0000 38B5     		push	{r3, r4, r5, lr}
 2603              	.LCFI28:
 2604              		.cfi_def_cfa_offset 16
 2605              		.cfi_offset 3, -16
 2606              		.cfi_offset 4, -12
 2607              		.cfi_offset 5, -8
 2608              		.cfi_offset 14, -4
3065:FreeRTOS/Src/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2609              		.loc 1 3065 0
 2610 0002 C368     		ldr	r3, [r0, #12]
 2611 0004 DC68     		ldr	r4, [r3, #12]
 2612              	.LVL223:
3067:FreeRTOS/Src/tasks.c **** 
 2613              		.loc 1 3067 0
 2614 0006 04F11805 		add	r5, r4, #24
 2615 000a 2846     		mov	r0, r5
 2616              	.LVL224:
 2617 000c FFF7FEFF 		bl	uxListRemove
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 144


 2618              	.LVL225:
3069:FreeRTOS/Src/tasks.c **** 	{
 2619              		.loc 1 3069 0
 2620 0010 134B     		ldr	r3, .L226
 2621 0012 1B68     		ldr	r3, [r3]
 2622 0014 A3B9     		cbnz	r3, .L221
3071:FreeRTOS/Src/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2623              		.loc 1 3071 0
 2624 0016 251D     		adds	r5, r4, #4
 2625 0018 2846     		mov	r0, r5
 2626 001a FFF7FEFF 		bl	uxListRemove
 2627              	.LVL226:
3072:FreeRTOS/Src/tasks.c **** 	}
 2628              		.loc 1 3072 0
 2629 001e E36A     		ldr	r3, [r4, #44]
 2630 0020 0122     		movs	r2, #1
 2631 0022 02FA03F1 		lsl	r1, r2, r3
 2632 0026 0F48     		ldr	r0, .L226+4
 2633 0028 0268     		ldr	r2, [r0]
 2634 002a 0A43     		orrs	r2, r2, r1
 2635 002c 0260     		str	r2, [r0]
 2636 002e 03EB8303 		add	r3, r3, r3, lsl #2
 2637 0032 9A00     		lsls	r2, r3, #2
 2638 0034 2946     		mov	r1, r5
 2639 0036 0C48     		ldr	r0, .L226+8
 2640 0038 1044     		add	r0, r0, r2
 2641 003a FFF7FEFF 		bl	vListInsertEnd
 2642              	.LVL227:
 2643 003e 03E0     		b	.L222
 2644              	.L221:
3078:FreeRTOS/Src/tasks.c **** 	}
 2645              		.loc 1 3078 0
 2646 0040 2946     		mov	r1, r5
 2647 0042 0A48     		ldr	r0, .L226+12
 2648 0044 FFF7FEFF 		bl	vListInsertEnd
 2649              	.LVL228:
 2650              	.L222:
3081:FreeRTOS/Src/tasks.c **** 	{
 2651              		.loc 1 3081 0
 2652 0048 E26A     		ldr	r2, [r4, #44]
 2653 004a 094B     		ldr	r3, .L226+16
 2654 004c 1B68     		ldr	r3, [r3]
 2655 004e DB6A     		ldr	r3, [r3, #44]
 2656 0050 9A42     		cmp	r2, r3
 2657 0052 03D9     		bls	.L224
 2658              	.LVL229:
3090:FreeRTOS/Src/tasks.c **** 	}
 2659              		.loc 1 3090 0
 2660 0054 0120     		movs	r0, #1
 2661 0056 074B     		ldr	r3, .L226+20
 2662 0058 1860     		str	r0, [r3]
 2663 005a 38BD     		pop	{r3, r4, r5, pc}
 2664              	.LVL230:
 2665              	.L224:
3094:FreeRTOS/Src/tasks.c **** 	}
 2666              		.loc 1 3094 0
 2667 005c 0020     		movs	r0, #0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 145


 2668              	.LVL231:
3112:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 2669              		.loc 1 3112 0
 2670 005e 38BD     		pop	{r3, r4, r5, pc}
 2671              	.LVL232:
 2672              	.L227:
 2673              		.align	2
 2674              	.L226:
 2675 0060 00000000 		.word	.LANCHOR16
 2676 0064 00000000 		.word	.LANCHOR13
 2677 0068 00000000 		.word	.LANCHOR4
 2678 006c 00000000 		.word	.LANCHOR1
 2679 0070 00000000 		.word	.LANCHOR10
 2680 0074 00000000 		.word	.LANCHOR20
 2681              		.cfi_endproc
 2682              	.LFE57:
 2684              		.section	.text.vTaskRemoveFromUnorderedEventList,"ax",%progbits
 2685              		.align	2
 2686              		.global	vTaskRemoveFromUnorderedEventList
 2687              		.thumb
 2688              		.thumb_func
 2690              	vTaskRemoveFromUnorderedEventList:
 2691              	.LFB58:
3116:FreeRTOS/Src/tasks.c **** TCB_t *pxUnblockedTCB;
 2692              		.loc 1 3116 0
 2693              		.cfi_startproc
 2694              		@ args = 0, pretend = 0, frame = 0
 2695              		@ frame_needed = 0, uses_anonymous_args = 0
 2696              	.LVL233:
 2697 0000 38B5     		push	{r3, r4, r5, lr}
 2698              	.LCFI29:
 2699              		.cfi_def_cfa_offset 16
 2700              		.cfi_offset 3, -16
 2701              		.cfi_offset 4, -12
 2702              		.cfi_offset 5, -8
 2703              		.cfi_offset 14, -4
3124:FreeRTOS/Src/tasks.c **** 
 2704              		.loc 1 3124 0
 2705 0002 41F00041 		orr	r1, r1, #-2147483648
 2706              	.LVL234:
 2707 0006 0160     		str	r1, [r0]
3128:FreeRTOS/Src/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2708              		.loc 1 3128 0
 2709 0008 C468     		ldr	r4, [r0, #12]
 2710              	.LVL235:
3130:FreeRTOS/Src/tasks.c **** 
 2711              		.loc 1 3130 0
 2712 000a FFF7FEFF 		bl	uxListRemove
 2713              	.LVL236:
3135:FreeRTOS/Src/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2714              		.loc 1 3135 0
 2715 000e 251D     		adds	r5, r4, #4
 2716 0010 2846     		mov	r0, r5
 2717 0012 FFF7FEFF 		bl	uxListRemove
 2718              	.LVL237:
3136:FreeRTOS/Src/tasks.c **** 
 2719              		.loc 1 3136 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 146


 2720 0016 E36A     		ldr	r3, [r4, #44]
 2721 0018 0122     		movs	r2, #1
 2722 001a 02FA03F1 		lsl	r1, r2, r3
 2723 001e 0B48     		ldr	r0, .L231
 2724 0020 0268     		ldr	r2, [r0]
 2725 0022 0A43     		orrs	r2, r2, r1
 2726 0024 0260     		str	r2, [r0]
 2727 0026 03EB8303 		add	r3, r3, r3, lsl #2
 2728 002a 9A00     		lsls	r2, r3, #2
 2729 002c 2946     		mov	r1, r5
 2730 002e 0848     		ldr	r0, .L231+4
 2731 0030 1044     		add	r0, r0, r2
 2732 0032 FFF7FEFF 		bl	vListInsertEnd
 2733              	.LVL238:
3138:FreeRTOS/Src/tasks.c **** 	{
 2734              		.loc 1 3138 0
 2735 0036 E26A     		ldr	r2, [r4, #44]
 2736 0038 064B     		ldr	r3, .L231+8
 2737 003a 1B68     		ldr	r3, [r3]
 2738 003c DB6A     		ldr	r3, [r3, #44]
 2739 003e 9A42     		cmp	r2, r3
 2740 0040 02D9     		bls	.L228
3144:FreeRTOS/Src/tasks.c **** 	}
 2741              		.loc 1 3144 0
 2742 0042 0122     		movs	r2, #1
 2743 0044 044B     		ldr	r3, .L231+12
 2744 0046 1A60     		str	r2, [r3]
 2745              	.L228:
 2746 0048 38BD     		pop	{r3, r4, r5, pc}
 2747              	.LVL239:
 2748              	.L232:
 2749 004a 00BF     		.align	2
 2750              	.L231:
 2751 004c 00000000 		.word	.LANCHOR13
 2752 0050 00000000 		.word	.LANCHOR4
 2753 0054 00000000 		.word	.LANCHOR10
 2754 0058 00000000 		.word	.LANCHOR20
 2755              		.cfi_endproc
 2756              	.LFE58:
 2758              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2759              		.align	2
 2760              		.global	vTaskSetTimeOutState
 2761              		.thumb
 2762              		.thumb_func
 2764              	vTaskSetTimeOutState:
 2765              	.LFB59:
3150:FreeRTOS/Src/tasks.c **** 	configASSERT( pxTimeOut );
 2766              		.loc 1 3150 0
 2767              		.cfi_startproc
 2768              		@ args = 0, pretend = 0, frame = 0
 2769              		@ frame_needed = 0, uses_anonymous_args = 0
 2770              	.LVL240:
 2771 0000 10B5     		push	{r4, lr}
 2772              	.LCFI30:
 2773              		.cfi_def_cfa_offset 8
 2774              		.cfi_offset 4, -8
 2775              		.cfi_offset 14, -4
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 147


 2776 0002 0446     		mov	r4, r0
3152:FreeRTOS/Src/tasks.c **** 	{
 2777              		.loc 1 3152 0
 2778 0004 FFF7FEFF 		bl	vPortEnterCritical
 2779              	.LVL241:
3154:FreeRTOS/Src/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2780              		.loc 1 3154 0
 2781 0008 044B     		ldr	r3, .L235
 2782 000a 1B68     		ldr	r3, [r3]
 2783 000c 2360     		str	r3, [r4]
3155:FreeRTOS/Src/tasks.c **** 	}
 2784              		.loc 1 3155 0
 2785 000e 044B     		ldr	r3, .L235+4
 2786 0010 1B68     		ldr	r3, [r3]
 2787 0012 6360     		str	r3, [r4, #4]
3157:FreeRTOS/Src/tasks.c **** }
 2788              		.loc 1 3157 0
 2789 0014 FFF7FEFF 		bl	vPortExitCritical
 2790              	.LVL242:
 2791 0018 10BD     		pop	{r4, pc}
 2792              	.LVL243:
 2793              	.L236:
 2794 001a 00BF     		.align	2
 2795              	.L235:
 2796 001c 00000000 		.word	.LANCHOR18
 2797 0020 00000000 		.word	.LANCHOR15
 2798              		.cfi_endproc
 2799              	.LFE59:
 2801              		.section	.text.vTaskInternalSetTimeOutState,"ax",%progbits
 2802              		.align	2
 2803              		.global	vTaskInternalSetTimeOutState
 2804              		.thumb
 2805              		.thumb_func
 2807              	vTaskInternalSetTimeOutState:
 2808              	.LFB60:
3162:FreeRTOS/Src/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2809              		.loc 1 3162 0
 2810              		.cfi_startproc
 2811              		@ args = 0, pretend = 0, frame = 0
 2812              		@ frame_needed = 0, uses_anonymous_args = 0
 2813              		@ link register save eliminated.
 2814              	.LVL244:
3164:FreeRTOS/Src/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2815              		.loc 1 3164 0
 2816 0000 034B     		ldr	r3, .L238
 2817 0002 1B68     		ldr	r3, [r3]
 2818 0004 0360     		str	r3, [r0]
3165:FreeRTOS/Src/tasks.c **** }
 2819              		.loc 1 3165 0
 2820 0006 034B     		ldr	r3, .L238+4
 2821 0008 1B68     		ldr	r3, [r3]
 2822 000a 4360     		str	r3, [r0, #4]
 2823 000c 7047     		bx	lr
 2824              	.L239:
 2825 000e 00BF     		.align	2
 2826              	.L238:
 2827 0010 00000000 		.word	.LANCHOR18
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 148


 2828 0014 00000000 		.word	.LANCHOR15
 2829              		.cfi_endproc
 2830              	.LFE60:
 2832              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2833              		.align	2
 2834              		.global	xTaskCheckForTimeOut
 2835              		.thumb
 2836              		.thumb_func
 2838              	xTaskCheckForTimeOut:
 2839              	.LFB61:
3170:FreeRTOS/Src/tasks.c **** BaseType_t xReturn;
 2840              		.loc 1 3170 0
 2841              		.cfi_startproc
 2842              		@ args = 0, pretend = 0, frame = 0
 2843              		@ frame_needed = 0, uses_anonymous_args = 0
 2844              	.LVL245:
 2845 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2846              	.LCFI31:
 2847              		.cfi_def_cfa_offset 24
 2848              		.cfi_offset 3, -24
 2849              		.cfi_offset 4, -20
 2850              		.cfi_offset 5, -16
 2851              		.cfi_offset 6, -12
 2852              		.cfi_offset 7, -8
 2853              		.cfi_offset 14, -4
 2854 0002 0446     		mov	r4, r0
 2855 0004 0D46     		mov	r5, r1
3176:FreeRTOS/Src/tasks.c **** 	{
 2856              		.loc 1 3176 0
 2857 0006 FFF7FEFF 		bl	vPortEnterCritical
 2858              	.LVL246:
 2859              	.LBB52:
3179:FreeRTOS/Src/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2860              		.loc 1 3179 0
 2861 000a 114B     		ldr	r3, .L247
 2862 000c 1968     		ldr	r1, [r3]
 2863              	.LVL247:
3180:FreeRTOS/Src/tasks.c **** 
 2864              		.loc 1 3180 0
 2865 000e 6268     		ldr	r2, [r4, #4]
 2866 0010 881A     		subs	r0, r1, r2
 2867              	.LVL248:
3194:FreeRTOS/Src/tasks.c **** 			{
 2868              		.loc 1 3194 0
 2869 0012 2B68     		ldr	r3, [r5]
 2870 0014 B3F1FF3F 		cmp	r3, #-1
 2871 0018 13D0     		beq	.L244
3204:FreeRTOS/Src/tasks.c **** 		{
 2872              		.loc 1 3204 0
 2873 001a 2768     		ldr	r7, [r4]
 2874 001c 0D4E     		ldr	r6, .L247+4
 2875 001e 3668     		ldr	r6, [r6]
 2876 0020 B742     		cmp	r7, r6
 2877 0022 01D0     		beq	.L242
3204:FreeRTOS/Src/tasks.c **** 		{
 2878              		.loc 1 3204 0 is_stmt 0 discriminator 1
 2879 0024 9142     		cmp	r1, r2
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 149


 2880 0026 0ED2     		bcs	.L245
 2881              	.L242:
3213:FreeRTOS/Src/tasks.c **** 		{
 2882              		.loc 1 3213 0 is_stmt 1
 2883 0028 9842     		cmp	r0, r3
 2884 002a 06D2     		bcs	.L243
3216:FreeRTOS/Src/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2885              		.loc 1 3216 0
 2886 002c 1B1A     		subs	r3, r3, r0
 2887 002e 2B60     		str	r3, [r5]
3217:FreeRTOS/Src/tasks.c **** 			xReturn = pdFALSE;
 2888              		.loc 1 3217 0
 2889 0030 2046     		mov	r0, r4
 2890              	.LVL249:
 2891 0032 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 2892              	.LVL250:
3218:FreeRTOS/Src/tasks.c **** 		}
 2893              		.loc 1 3218 0
 2894 0036 0024     		movs	r4, #0
 2895              	.LVL251:
 2896 0038 06E0     		b	.L241
 2897              	.LVL252:
 2898              	.L243:
3222:FreeRTOS/Src/tasks.c **** 			xReturn = pdTRUE;
 2899              		.loc 1 3222 0
 2900 003a 0023     		movs	r3, #0
 2901 003c 2B60     		str	r3, [r5]
 2902              	.LVL253:
3223:FreeRTOS/Src/tasks.c **** 		}
 2903              		.loc 1 3223 0
 2904 003e 0124     		movs	r4, #1
 2905              	.LVL254:
 2906 0040 02E0     		b	.L241
 2907              	.LVL255:
 2908              	.L244:
3199:FreeRTOS/Src/tasks.c **** 			}
 2909              		.loc 1 3199 0
 2910 0042 0024     		movs	r4, #0
 2911              	.LVL256:
 2912 0044 00E0     		b	.L241
 2913              	.LVL257:
 2914              	.L245:
3211:FreeRTOS/Src/tasks.c **** 		}
 2915              		.loc 1 3211 0
 2916 0046 0124     		movs	r4, #1
 2917              	.LVL258:
 2918              	.L241:
 2919              	.LBE52:
3226:FreeRTOS/Src/tasks.c **** 
 2920              		.loc 1 3226 0
 2921 0048 FFF7FEFF 		bl	vPortExitCritical
 2922              	.LVL259:
3229:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 2923              		.loc 1 3229 0
 2924 004c 2046     		mov	r0, r4
 2925 004e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2926              	.LVL260:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 150


 2927              	.L248:
 2928              		.align	2
 2929              	.L247:
 2930 0050 00000000 		.word	.LANCHOR15
 2931 0054 00000000 		.word	.LANCHOR18
 2932              		.cfi_endproc
 2933              	.LFE61:
 2935              		.section	.text.vTaskMissedYield,"ax",%progbits
 2936              		.align	2
 2937              		.global	vTaskMissedYield
 2938              		.thumb
 2939              		.thumb_func
 2941              	vTaskMissedYield:
 2942              	.LFB62:
3233:FreeRTOS/Src/tasks.c **** 	xYieldPending = pdTRUE;
 2943              		.loc 1 3233 0
 2944              		.cfi_startproc
 2945              		@ args = 0, pretend = 0, frame = 0
 2946              		@ frame_needed = 0, uses_anonymous_args = 0
 2947              		@ link register save eliminated.
3234:FreeRTOS/Src/tasks.c **** }
 2948              		.loc 1 3234 0
 2949 0000 0122     		movs	r2, #1
 2950 0002 014B     		ldr	r3, .L250
 2951 0004 1A60     		str	r2, [r3]
 2952 0006 7047     		bx	lr
 2953              	.L251:
 2954              		.align	2
 2955              	.L250:
 2956 0008 00000000 		.word	.LANCHOR20
 2957              		.cfi_endproc
 2958              	.LFE62:
 2960              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 2961              		.align	2
 2962              		.global	uxTaskResetEventItemValue
 2963              		.thumb
 2964              		.thumb_func
 2966              	uxTaskResetEventItemValue:
 2967              	.LFB68:
4447:FreeRTOS/Src/tasks.c **** TickType_t uxReturn;
 2968              		.loc 1 4447 0
 2969              		.cfi_startproc
 2970              		@ args = 0, pretend = 0, frame = 0
 2971              		@ frame_needed = 0, uses_anonymous_args = 0
 2972              		@ link register save eliminated.
4450:FreeRTOS/Src/tasks.c **** 
 2973              		.loc 1 4450 0
 2974 0000 044B     		ldr	r3, .L253
 2975 0002 1A68     		ldr	r2, [r3]
 2976 0004 9069     		ldr	r0, [r2, #24]
 2977              	.LVL261:
4454:FreeRTOS/Src/tasks.c **** 
 2978              		.loc 1 4454 0
 2979 0006 1A68     		ldr	r2, [r3]
 2980 0008 1B68     		ldr	r3, [r3]
 2981 000a DB6A     		ldr	r3, [r3, #44]
 2982 000c C3F10503 		rsb	r3, r3, #5
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 151


 2983 0010 9361     		str	r3, [r2, #24]
4457:FreeRTOS/Src/tasks.c **** /*-----------------------------------------------------------*/
 2984              		.loc 1 4457 0
 2985 0012 7047     		bx	lr
 2986              	.L254:
 2987              		.align	2
 2988              	.L253:
 2989 0014 00000000 		.word	.LANCHOR10
 2990              		.cfi_endproc
 2991              	.LFE68:
 2993              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 2994              		.align	2
 2995              		.global	ulTaskNotifyTake
 2996              		.thumb
 2997              		.thumb_func
 2999              	ulTaskNotifyTake:
 3000              	.LFB69:
4480:FreeRTOS/Src/tasks.c **** 	uint32_t ulReturn;
 3001              		.loc 1 4480 0
 3002              		.cfi_startproc
 3003              		@ args = 0, pretend = 0, frame = 0
 3004              		@ frame_needed = 0, uses_anonymous_args = 0
 3005              	.LVL262:
 3006 0000 38B5     		push	{r3, r4, r5, lr}
 3007              	.LCFI32:
 3008              		.cfi_def_cfa_offset 16
 3009              		.cfi_offset 3, -16
 3010              		.cfi_offset 4, -12
 3011              		.cfi_offset 5, -8
 3012              		.cfi_offset 14, -4
 3013 0002 0546     		mov	r5, r0
 3014 0004 0C46     		mov	r4, r1
4483:FreeRTOS/Src/tasks.c **** 		{
 3015              		.loc 1 4483 0
 3016 0006 FFF7FEFF 		bl	vPortEnterCritical
 3017              	.LVL263:
4486:FreeRTOS/Src/tasks.c **** 			{
 3018              		.loc 1 4486 0
 3019 000a 184B     		ldr	r3, .L260
 3020 000c 1B68     		ldr	r3, [r3]
 3021 000e 5B6C     		ldr	r3, [r3, #68]
 3022 0010 8BB9     		cbnz	r3, .L256
4489:FreeRTOS/Src/tasks.c **** 
 3023              		.loc 1 4489 0
 3024 0012 164B     		ldr	r3, .L260
 3025 0014 1B68     		ldr	r3, [r3]
 3026 0016 0122     		movs	r2, #1
 3027 0018 83F84820 		strb	r2, [r3, #72]
4491:FreeRTOS/Src/tasks.c **** 				{
 3028              		.loc 1 4491 0
 3029 001c 5CB1     		cbz	r4, .L256
4493:FreeRTOS/Src/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 3030              		.loc 1 4493 0
 3031 001e 1146     		mov	r1, r2
 3032 0020 2046     		mov	r0, r4
 3033 0022 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3034              	.LVL264:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 152


4500:FreeRTOS/Src/tasks.c **** 				}
 3035              		.loc 1 4500 0
 3036 0026 4FF08052 		mov	r2, #268435456
 3037 002a 114B     		ldr	r3, .L260+4
 3038 002c 1A60     		str	r2, [r3]
 3039              		.syntax unified
 3040              	@ 4500 "FreeRTOS/Src/tasks.c" 1
 3041 002e BFF34F8F 		dsb
 3042              	@ 0 "" 2
 3043              	@ 4500 "FreeRTOS/Src/tasks.c" 1
 3044 0032 BFF36F8F 		isb
 3045              	@ 0 "" 2
 3046              		.thumb
 3047              		.syntax unified
 3048              	.L256:
4512:FreeRTOS/Src/tasks.c **** 
 3049              		.loc 1 4512 0
 3050 0036 FFF7FEFF 		bl	vPortExitCritical
 3051              	.LVL265:
4514:FreeRTOS/Src/tasks.c **** 		{
 3052              		.loc 1 4514 0
 3053 003a FFF7FEFF 		bl	vPortEnterCritical
 3054              	.LVL266:
4517:FreeRTOS/Src/tasks.c **** 
 3055              		.loc 1 4517 0
 3056 003e 0B4B     		ldr	r3, .L260
 3057 0040 1B68     		ldr	r3, [r3]
 3058 0042 5C6C     		ldr	r4, [r3, #68]
 3059              	.LVL267:
4519:FreeRTOS/Src/tasks.c **** 			{
 3060              		.loc 1 4519 0
 3061 0044 4CB1     		cbz	r4, .L257
4521:FreeRTOS/Src/tasks.c **** 				{
 3062              		.loc 1 4521 0
 3063 0046 25B1     		cbz	r5, .L258
4523:FreeRTOS/Src/tasks.c **** 				}
 3064              		.loc 1 4523 0
 3065 0048 084B     		ldr	r3, .L260
 3066 004a 1B68     		ldr	r3, [r3]
 3067 004c 0022     		movs	r2, #0
 3068 004e 5A64     		str	r2, [r3, #68]
 3069 0050 03E0     		b	.L257
 3070              	.L258:
4527:FreeRTOS/Src/tasks.c **** 				}
 3071              		.loc 1 4527 0
 3072 0052 064B     		ldr	r3, .L260
 3073 0054 1B68     		ldr	r3, [r3]
 3074 0056 621E     		subs	r2, r4, #1
 3075 0058 5A64     		str	r2, [r3, #68]
 3076              	.L257:
4535:FreeRTOS/Src/tasks.c **** 		}
 3077              		.loc 1 4535 0
 3078 005a 044B     		ldr	r3, .L260
 3079 005c 1B68     		ldr	r3, [r3]
 3080 005e 0022     		movs	r2, #0
 3081 0060 83F84820 		strb	r2, [r3, #72]
4537:FreeRTOS/Src/tasks.c **** 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 153


 3082              		.loc 1 4537 0
 3083 0064 FFF7FEFF 		bl	vPortExitCritical
 3084              	.LVL268:
4540:FreeRTOS/Src/tasks.c **** 
 3085              		.loc 1 4540 0
 3086 0068 2046     		mov	r0, r4
 3087 006a 38BD     		pop	{r3, r4, r5, pc}
 3088              	.LVL269:
 3089              	.L261:
 3090              		.align	2
 3091              	.L260:
 3092 006c 00000000 		.word	.LANCHOR10
 3093 0070 04ED00E0 		.word	-536810236
 3094              		.cfi_endproc
 3095              	.LFE69:
 3097              		.section	.text.xTaskNotifyWait,"ax",%progbits
 3098              		.align	2
 3099              		.global	xTaskNotifyWait
 3100              		.thumb
 3101              		.thumb_func
 3103              	xTaskNotifyWait:
 3104              	.LFB70:
4548:FreeRTOS/Src/tasks.c **** 	BaseType_t xReturn;
 3105              		.loc 1 4548 0
 3106              		.cfi_startproc
 3107              		@ args = 0, pretend = 0, frame = 0
 3108              		@ frame_needed = 0, uses_anonymous_args = 0
 3109              	.LVL270:
 3110 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3111              	.LCFI33:
 3112              		.cfi_def_cfa_offset 24
 3113              		.cfi_offset 3, -24
 3114              		.cfi_offset 4, -20
 3115              		.cfi_offset 5, -16
 3116              		.cfi_offset 6, -12
 3117              		.cfi_offset 7, -8
 3118              		.cfi_offset 14, -4
 3119 0002 0746     		mov	r7, r0
 3120 0004 0D46     		mov	r5, r1
 3121 0006 1446     		mov	r4, r2
 3122 0008 1E46     		mov	r6, r3
4551:FreeRTOS/Src/tasks.c **** 		{
 3123              		.loc 1 4551 0
 3124 000a FFF7FEFF 		bl	vPortEnterCritical
 3125              	.LVL271:
4554:FreeRTOS/Src/tasks.c **** 			{
 3126              		.loc 1 4554 0
 3127 000e 204B     		ldr	r3, .L268
 3128 0010 1B68     		ldr	r3, [r3]
 3129 0012 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 3130 0016 DBB2     		uxtb	r3, r3
 3131 0018 022B     		cmp	r3, #2
 3132 001a 16D0     		beq	.L263
4559:FreeRTOS/Src/tasks.c **** 
 3133              		.loc 1 4559 0
 3134 001c 1C4B     		ldr	r3, .L268
 3135 001e 1A68     		ldr	r2, [r3]
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 154


 3136 0020 506C     		ldr	r0, [r2, #68]
 3137 0022 20EA0700 		bic	r0, r0, r7
 3138 0026 5064     		str	r0, [r2, #68]
4562:FreeRTOS/Src/tasks.c **** 
 3139              		.loc 1 4562 0
 3140 0028 1B68     		ldr	r3, [r3]
 3141 002a 0122     		movs	r2, #1
 3142 002c 83F84820 		strb	r2, [r3, #72]
4564:FreeRTOS/Src/tasks.c **** 				{
 3143              		.loc 1 4564 0
 3144 0030 5EB1     		cbz	r6, .L263
4566:FreeRTOS/Src/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 3145              		.loc 1 4566 0
 3146 0032 1146     		mov	r1, r2
 3147 0034 3046     		mov	r0, r6
 3148 0036 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3149              	.LVL272:
4573:FreeRTOS/Src/tasks.c **** 				}
 3150              		.loc 1 4573 0
 3151 003a 4FF08052 		mov	r2, #268435456
 3152 003e 154B     		ldr	r3, .L268+4
 3153 0040 1A60     		str	r2, [r3]
 3154              		.syntax unified
 3155              	@ 4573 "FreeRTOS/Src/tasks.c" 1
 3156 0042 BFF34F8F 		dsb
 3157              	@ 0 "" 2
 3158              	@ 4573 "FreeRTOS/Src/tasks.c" 1
 3159 0046 BFF36F8F 		isb
 3160              	@ 0 "" 2
 3161              		.thumb
 3162              		.syntax unified
 3163              	.L263:
4585:FreeRTOS/Src/tasks.c **** 
 3164              		.loc 1 4585 0
 3165 004a FFF7FEFF 		bl	vPortExitCritical
 3166              	.LVL273:
4587:FreeRTOS/Src/tasks.c **** 		{
 3167              		.loc 1 4587 0
 3168 004e FFF7FEFF 		bl	vPortEnterCritical
 3169              	.LVL274:
4591:FreeRTOS/Src/tasks.c **** 			{
 3170              		.loc 1 4591 0
 3171 0052 1CB1     		cbz	r4, .L264
4595:FreeRTOS/Src/tasks.c **** 			}
 3172              		.loc 1 4595 0
 3173 0054 0E4B     		ldr	r3, .L268
 3174 0056 1B68     		ldr	r3, [r3]
 3175 0058 5B6C     		ldr	r3, [r3, #68]
 3176 005a 2360     		str	r3, [r4]
 3177              	.L264:
4602:FreeRTOS/Src/tasks.c **** 			{
 3178              		.loc 1 4602 0
 3179 005c 0C4B     		ldr	r3, .L268
 3180 005e 1B68     		ldr	r3, [r3]
 3181 0060 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 3182 0064 DBB2     		uxtb	r3, r3
 3183 0066 022B     		cmp	r3, #2
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 155


 3184 0068 07D1     		bne	.L266
4611:FreeRTOS/Src/tasks.c **** 				xReturn = pdTRUE;
 3185              		.loc 1 4611 0
 3186 006a 094B     		ldr	r3, .L268
 3187 006c 1A68     		ldr	r2, [r3]
 3188 006e 536C     		ldr	r3, [r2, #68]
 3189 0070 23EA0505 		bic	r5, r3, r5
 3190              	.LVL275:
 3191 0074 5564     		str	r5, [r2, #68]
 3192              	.LVL276:
4612:FreeRTOS/Src/tasks.c **** 			}
 3193              		.loc 1 4612 0
 3194 0076 0124     		movs	r4, #1
 3195              	.LVL277:
 3196 0078 00E0     		b	.L265
 3197              	.LVL278:
 3198              	.L266:
4605:FreeRTOS/Src/tasks.c **** 			}
 3199              		.loc 1 4605 0
 3200 007a 0024     		movs	r4, #0
 3201              	.LVL279:
 3202              	.L265:
4615:FreeRTOS/Src/tasks.c **** 		}
 3203              		.loc 1 4615 0
 3204 007c 044B     		ldr	r3, .L268
 3205 007e 1B68     		ldr	r3, [r3]
 3206 0080 0022     		movs	r2, #0
 3207 0082 83F84820 		strb	r2, [r3, #72]
4617:FreeRTOS/Src/tasks.c **** 
 3208              		.loc 1 4617 0
 3209 0086 FFF7FEFF 		bl	vPortExitCritical
 3210              	.LVL280:
4620:FreeRTOS/Src/tasks.c **** 
 3211              		.loc 1 4620 0
 3212 008a 2046     		mov	r0, r4
 3213 008c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3214              	.LVL281:
 3215              	.L269:
 3216 008e 00BF     		.align	2
 3217              	.L268:
 3218 0090 00000000 		.word	.LANCHOR10
 3219 0094 04ED00E0 		.word	-536810236
 3220              		.cfi_endproc
 3221              	.LFE70:
 3223              		.section	.text.xTaskGenericNotify,"ax",%progbits
 3224              		.align	2
 3225              		.global	xTaskGenericNotify
 3226              		.thumb
 3227              		.thumb_func
 3229              	xTaskGenericNotify:
 3230              	.LFB71:
4628:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
 3231              		.loc 1 4628 0
 3232              		.cfi_startproc
 3233              		@ args = 0, pretend = 0, frame = 0
 3234              		@ frame_needed = 0, uses_anonymous_args = 0
 3235              	.LVL282:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 156


 3236 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3237              	.LCFI34:
 3238              		.cfi_def_cfa_offset 24
 3239              		.cfi_offset 3, -24
 3240              		.cfi_offset 4, -20
 3241              		.cfi_offset 5, -16
 3242              		.cfi_offset 6, -12
 3243              		.cfi_offset 7, -8
 3244              		.cfi_offset 14, -4
 3245 0002 0446     		mov	r4, r0
 3246 0004 0F46     		mov	r7, r1
 3247 0006 1546     		mov	r5, r2
 3248 0008 1E46     		mov	r6, r3
 3249              	.LVL283:
4636:FreeRTOS/Src/tasks.c **** 		{
 3250              		.loc 1 4636 0
 3251 000a FFF7FEFF 		bl	vPortEnterCritical
 3252              	.LVL284:
4638:FreeRTOS/Src/tasks.c **** 			{
 3253              		.loc 1 4638 0
 3254 000e 0EB1     		cbz	r6, .L271
4640:FreeRTOS/Src/tasks.c **** 			}
 3255              		.loc 1 4640 0
 3256 0010 636C     		ldr	r3, [r4, #68]
 3257 0012 3360     		str	r3, [r6]
 3258              	.L271:
4643:FreeRTOS/Src/tasks.c **** 
 3259              		.loc 1 4643 0
 3260 0014 94F84830 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 3261 0018 DBB2     		uxtb	r3, r3
 3262              	.LVL285:
4645:FreeRTOS/Src/tasks.c **** 
 3263              		.loc 1 4645 0
 3264 001a 0222     		movs	r2, #2
 3265 001c 84F84820 		strb	r2, [r4, #72]
4647:FreeRTOS/Src/tasks.c **** 			{
 3266              		.loc 1 4647 0
 3267 0020 6A1E     		subs	r2, r5, #1
 3268 0022 032A     		cmp	r2, #3
 3269 0024 15D8     		bhi	.L279
 3270 0026 DFE802F0 		tbb	[pc, r2]
 3271              	.L274:
 3272 002a 02       		.byte	(.L273-.L274)/2
 3273 002b 07       		.byte	(.L275-.L274)/2
 3274 002c 0C       		.byte	(.L276-.L274)/2
 3275 002d 0F       		.byte	(.L277-.L274)/2
 3276              		.p2align 1
 3277              	.L273:
4650:FreeRTOS/Src/tasks.c **** 					break;
 3278              		.loc 1 4650 0
 3279 002e 626C     		ldr	r2, [r4, #68]
 3280 0030 1743     		orrs	r7, r7, r2
 3281              	.LVL286:
 3282 0032 6764     		str	r7, [r4, #68]
4630:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
 3283              		.loc 1 4630 0
 3284 0034 0125     		movs	r5, #1
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 157


4651:FreeRTOS/Src/tasks.c **** 
 3285              		.loc 1 4651 0
 3286 0036 0FE0     		b	.L272
 3287              	.LVL287:
 3288              	.L275:
4654:FreeRTOS/Src/tasks.c **** 					break;
 3289              		.loc 1 4654 0
 3290 0038 626C     		ldr	r2, [r4, #68]
 3291 003a 0132     		adds	r2, r2, #1
 3292 003c 6264     		str	r2, [r4, #68]
4630:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
 3293              		.loc 1 4630 0
 3294 003e 0125     		movs	r5, #1
4655:FreeRTOS/Src/tasks.c **** 
 3295              		.loc 1 4655 0
 3296 0040 0AE0     		b	.L272
 3297              	.L276:
4658:FreeRTOS/Src/tasks.c **** 					break;
 3298              		.loc 1 4658 0
 3299 0042 6764     		str	r7, [r4, #68]
4630:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
 3300              		.loc 1 4630 0
 3301 0044 0125     		movs	r5, #1
4659:FreeRTOS/Src/tasks.c **** 
 3302              		.loc 1 4659 0
 3303 0046 07E0     		b	.L272
 3304              	.L277:
4662:FreeRTOS/Src/tasks.c **** 					{
 3305              		.loc 1 4662 0
 3306 0048 022B     		cmp	r3, #2
 3307 004a 04D0     		beq	.L280
4664:FreeRTOS/Src/tasks.c **** 					}
 3308              		.loc 1 4664 0
 3309 004c 6764     		str	r7, [r4, #68]
4630:FreeRTOS/Src/tasks.c **** 	uint8_t ucOriginalNotifyState;
 3310              		.loc 1 4630 0
 3311 004e 0125     		movs	r5, #1
 3312 0050 02E0     		b	.L272
 3313              	.L279:
 3314 0052 0125     		movs	r5, #1
 3315 0054 00E0     		b	.L272
 3316              	.L280:
4669:FreeRTOS/Src/tasks.c **** 					}
 3317              		.loc 1 4669 0
 3318 0056 0025     		movs	r5, #0
 3319              	.LVL288:
 3320              	.L272:
4691:FreeRTOS/Src/tasks.c **** 			{
 3321              		.loc 1 4691 0
 3322 0058 012B     		cmp	r3, #1
 3323 005a 21D1     		bne	.L278
4693:FreeRTOS/Src/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3324              		.loc 1 4693 0
 3325 005c 261D     		adds	r6, r4, #4
 3326              	.LVL289:
 3327 005e 3046     		mov	r0, r6
 3328 0060 FFF7FEFF 		bl	uxListRemove
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 158


 3329              	.LVL290:
4694:FreeRTOS/Src/tasks.c **** 
 3330              		.loc 1 4694 0
 3331 0064 E36A     		ldr	r3, [r4, #44]
 3332 0066 0122     		movs	r2, #1
 3333 0068 02FA03F1 		lsl	r1, r2, r3
 3334 006c 0E48     		ldr	r0, .L282
 3335 006e 0268     		ldr	r2, [r0]
 3336 0070 0A43     		orrs	r2, r2, r1
 3337 0072 0260     		str	r2, [r0]
 3338 0074 03EB8303 		add	r3, r3, r3, lsl #2
 3339 0078 9A00     		lsls	r2, r3, #2
 3340 007a 3146     		mov	r1, r6
 3341 007c 0B48     		ldr	r0, .L282+4
 3342 007e 1044     		add	r0, r0, r2
 3343 0080 FFF7FEFF 		bl	vListInsertEnd
 3344              	.LVL291:
4715:FreeRTOS/Src/tasks.c **** 				{
 3345              		.loc 1 4715 0
 3346 0084 E26A     		ldr	r2, [r4, #44]
 3347 0086 0A4B     		ldr	r3, .L282+8
 3348 0088 1B68     		ldr	r3, [r3]
 3349 008a DB6A     		ldr	r3, [r3, #44]
 3350 008c 9A42     		cmp	r2, r3
 3351 008e 07D9     		bls	.L278
4719:FreeRTOS/Src/tasks.c **** 				}
 3352              		.loc 1 4719 0
 3353 0090 4FF08052 		mov	r2, #268435456
 3354 0094 074B     		ldr	r3, .L282+12
 3355 0096 1A60     		str	r2, [r3]
 3356              		.syntax unified
 3357              	@ 4719 "FreeRTOS/Src/tasks.c" 1
 3358 0098 BFF34F8F 		dsb
 3359              	@ 0 "" 2
 3360              	@ 4719 "FreeRTOS/Src/tasks.c" 1
 3361 009c BFF36F8F 		isb
 3362              	@ 0 "" 2
 3363              		.thumb
 3364              		.syntax unified
 3365              	.L278:
4731:FreeRTOS/Src/tasks.c **** 
 3366              		.loc 1 4731 0
 3367 00a0 FFF7FEFF 		bl	vPortExitCritical
 3368              	.LVL292:
4734:FreeRTOS/Src/tasks.c **** 
 3369              		.loc 1 4734 0
 3370 00a4 2846     		mov	r0, r5
 3371 00a6 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3372              	.LVL293:
 3373              	.L283:
 3374              		.align	2
 3375              	.L282:
 3376 00a8 00000000 		.word	.LANCHOR13
 3377 00ac 00000000 		.word	.LANCHOR4
 3378 00b0 00000000 		.word	.LANCHOR10
 3379 00b4 04ED00E0 		.word	-536810236
 3380              		.cfi_endproc
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 159


 3381              	.LFE71:
 3383              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 3384              		.align	2
 3385              		.global	xTaskGenericNotifyFromISR
 3386              		.thumb
 3387              		.thumb_func
 3389              	xTaskGenericNotifyFromISR:
 3390              	.LFB72:
4742:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
 3391              		.loc 1 4742 0
 3392              		.cfi_startproc
 3393              		@ args = 4, pretend = 0, frame = 0
 3394              		@ frame_needed = 0, uses_anonymous_args = 0
 3395              	.LVL294:
 3396 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3397              	.LCFI35:
 3398              		.cfi_def_cfa_offset 24
 3399              		.cfi_offset 3, -24
 3400              		.cfi_offset 4, -20
 3401              		.cfi_offset 5, -16
 3402              		.cfi_offset 6, -12
 3403              		.cfi_offset 7, -8
 3404              		.cfi_offset 14, -4
 3405              	.LVL295:
 3406              	.LBB53:
 3407              	.LBB54:
 211:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 3408              		.loc 2 211 0
 3409              		.syntax unified
 3410              	@ 211 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3411 0002 EFF31185 			mrs r5, basepri											
 3412 0006 4FF0BF04 		mov r4, #191												
 3413 000a 84F31188 		msr basepri, r4											
 3414 000e BFF36F8F 		isb														
 3415 0012 BFF34F8F 		dsb														
 3416              	
 3417              	@ 0 "" 2
 3418              		.thumb
 3419              		.syntax unified
 3420              	.LBE54:
 3421              	.LBE53:
4772:FreeRTOS/Src/tasks.c **** 			{
 3422              		.loc 1 4772 0
 3423 0016 0BB1     		cbz	r3, .L285
4774:FreeRTOS/Src/tasks.c **** 			}
 3424              		.loc 1 4774 0
 3425 0018 446C     		ldr	r4, [r0, #68]
 3426 001a 1C60     		str	r4, [r3]
 3427              	.L285:
4777:FreeRTOS/Src/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3428              		.loc 1 4777 0
 3429 001c 90F84830 		ldrb	r3, [r0, #72]	@ zero_extendqisi2
 3430              	.LVL296:
 3431 0020 DBB2     		uxtb	r3, r3
 3432              	.LVL297:
4778:FreeRTOS/Src/tasks.c **** 
 3433              		.loc 1 4778 0
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 160


 3434 0022 0224     		movs	r4, #2
 3435 0024 80F84840 		strb	r4, [r0, #72]
4780:FreeRTOS/Src/tasks.c **** 			{
 3436              		.loc 1 4780 0
 3437 0028 013A     		subs	r2, r2, #1
 3438              	.LVL298:
 3439 002a 032A     		cmp	r2, #3
 3440 002c 15D8     		bhi	.L296
 3441 002e DFE802F0 		tbb	[pc, r2]
 3442              	.L288:
 3443 0032 02       		.byte	(.L287-.L288)/2
 3444 0033 07       		.byte	(.L289-.L288)/2
 3445 0034 0C       		.byte	(.L290-.L288)/2
 3446 0035 0F       		.byte	(.L291-.L288)/2
 3447              		.p2align 1
 3448              	.L287:
4783:FreeRTOS/Src/tasks.c **** 					break;
 3449              		.loc 1 4783 0
 3450 0036 426C     		ldr	r2, [r0, #68]
 3451 0038 1143     		orrs	r1, r1, r2
 3452              	.LVL299:
 3453 003a 4164     		str	r1, [r0, #68]
4745:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 3454              		.loc 1 4745 0
 3455 003c 0124     		movs	r4, #1
4784:FreeRTOS/Src/tasks.c **** 
 3456              		.loc 1 4784 0
 3457 003e 0FE0     		b	.L286
 3458              	.LVL300:
 3459              	.L289:
4787:FreeRTOS/Src/tasks.c **** 					break;
 3460              		.loc 1 4787 0
 3461 0040 426C     		ldr	r2, [r0, #68]
 3462 0042 0132     		adds	r2, r2, #1
 3463 0044 4264     		str	r2, [r0, #68]
4745:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 3464              		.loc 1 4745 0
 3465 0046 0124     		movs	r4, #1
4788:FreeRTOS/Src/tasks.c **** 
 3466              		.loc 1 4788 0
 3467 0048 0AE0     		b	.L286
 3468              	.L290:
4791:FreeRTOS/Src/tasks.c **** 					break;
 3469              		.loc 1 4791 0
 3470 004a 4164     		str	r1, [r0, #68]
4745:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 3471              		.loc 1 4745 0
 3472 004c 0124     		movs	r4, #1
4792:FreeRTOS/Src/tasks.c **** 
 3473              		.loc 1 4792 0
 3474 004e 07E0     		b	.L286
 3475              	.L291:
4795:FreeRTOS/Src/tasks.c **** 					{
 3476              		.loc 1 4795 0
 3477 0050 022B     		cmp	r3, #2
 3478 0052 04D0     		beq	.L297
4797:FreeRTOS/Src/tasks.c **** 					}
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 161


 3479              		.loc 1 4797 0
 3480 0054 4164     		str	r1, [r0, #68]
4745:FreeRTOS/Src/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
 3481              		.loc 1 4745 0
 3482 0056 0124     		movs	r4, #1
 3483 0058 02E0     		b	.L286
 3484              	.L296:
 3485 005a 0124     		movs	r4, #1
 3486 005c 00E0     		b	.L286
 3487              	.L297:
4802:FreeRTOS/Src/tasks.c **** 					}
 3488              		.loc 1 4802 0
 3489 005e 0024     		movs	r4, #0
 3490              	.LVL301:
 3491              	.L286:
4823:FreeRTOS/Src/tasks.c **** 			{
 3492              		.loc 1 4823 0
 3493 0060 012B     		cmp	r3, #1
 3494 0062 2BD1     		bne	.L292
 3495 0064 0646     		mov	r6, r0
4828:FreeRTOS/Src/tasks.c **** 				{
 3496              		.loc 1 4828 0
 3497 0066 174B     		ldr	r3, .L299
 3498              	.LVL302:
 3499 0068 1B68     		ldr	r3, [r3]
 3500 006a A3B9     		cbnz	r3, .L293
4830:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3501              		.loc 1 4830 0
 3502 006c 071D     		adds	r7, r0, #4
 3503 006e 3846     		mov	r0, r7
 3504              	.LVL303:
 3505 0070 FFF7FEFF 		bl	uxListRemove
 3506              	.LVL304:
4831:FreeRTOS/Src/tasks.c **** 				}
 3507              		.loc 1 4831 0
 3508 0074 F36A     		ldr	r3, [r6, #44]
 3509 0076 0122     		movs	r2, #1
 3510 0078 02FA03F1 		lsl	r1, r2, r3
 3511 007c 1248     		ldr	r0, .L299+4
 3512 007e 0268     		ldr	r2, [r0]
 3513 0080 0A43     		orrs	r2, r2, r1
 3514 0082 0260     		str	r2, [r0]
 3515 0084 03EB8303 		add	r3, r3, r3, lsl #2
 3516 0088 9A00     		lsls	r2, r3, #2
 3517 008a 3946     		mov	r1, r7
 3518 008c 0F48     		ldr	r0, .L299+8
 3519 008e 1044     		add	r0, r0, r2
 3520 0090 FFF7FEFF 		bl	vListInsertEnd
 3521              	.LVL305:
 3522 0094 04E0     		b	.L294
 3523              	.LVL306:
 3524              	.L293:
4837:FreeRTOS/Src/tasks.c **** 				}
 3525              		.loc 1 4837 0
 3526 0096 00F11801 		add	r1, r0, #24
 3527 009a 0D48     		ldr	r0, .L299+12
 3528              	.LVL307:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 162


 3529 009c FFF7FEFF 		bl	vListInsertEnd
 3530              	.LVL308:
 3531              	.L294:
4840:FreeRTOS/Src/tasks.c **** 				{
 3532              		.loc 1 4840 0
 3533 00a0 F26A     		ldr	r2, [r6, #44]
 3534 00a2 0C4B     		ldr	r3, .L299+16
 3535 00a4 1B68     		ldr	r3, [r3]
 3536 00a6 DB6A     		ldr	r3, [r3, #44]
 3537 00a8 9A42     		cmp	r2, r3
 3538 00aa 07D9     		bls	.L292
4844:FreeRTOS/Src/tasks.c **** 					{
 3539              		.loc 1 4844 0
 3540 00ac 069B     		ldr	r3, [sp, #24]
 3541 00ae 13B1     		cbz	r3, .L295
4846:FreeRTOS/Src/tasks.c **** 					}
 3542              		.loc 1 4846 0
 3543 00b0 0123     		movs	r3, #1
 3544 00b2 069A     		ldr	r2, [sp, #24]
 3545 00b4 1360     		str	r3, [r2]
 3546              	.L295:
4852:FreeRTOS/Src/tasks.c **** 				}
 3547              		.loc 1 4852 0
 3548 00b6 0122     		movs	r2, #1
 3549 00b8 074B     		ldr	r3, .L299+20
 3550 00ba 1A60     		str	r2, [r3]
 3551              	.LVL309:
 3552              	.L292:
 3553              	.LBB55:
 3554              	.LBB56:
 3555              		.loc 2 229 0
 3556              		.syntax unified
 3557              	@ 229 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3558 00bc 85F31188 			msr basepri, r5	
 3559              	@ 0 "" 2
 3560              	.LVL310:
 3561              		.thumb
 3562              		.syntax unified
 3563              	.LBE56:
 3564              	.LBE55:
4863:FreeRTOS/Src/tasks.c **** 
 3565              		.loc 1 4863 0
 3566 00c0 2046     		mov	r0, r4
 3567 00c2 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3568              	.LVL311:
 3569              	.L300:
 3570              		.align	2
 3571              	.L299:
 3572 00c4 00000000 		.word	.LANCHOR16
 3573 00c8 00000000 		.word	.LANCHOR13
 3574 00cc 00000000 		.word	.LANCHOR4
 3575 00d0 00000000 		.word	.LANCHOR1
 3576 00d4 00000000 		.word	.LANCHOR10
 3577 00d8 00000000 		.word	.LANCHOR20
 3578              		.cfi_endproc
 3579              	.LFE72:
 3581              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 163


 3582              		.align	2
 3583              		.global	vTaskNotifyGiveFromISR
 3584              		.thumb
 3585              		.thumb_func
 3587              	vTaskNotifyGiveFromISR:
 3588              	.LFB73:
4871:FreeRTOS/Src/tasks.c **** 	TCB_t * pxTCB;
 3589              		.loc 1 4871 0
 3590              		.cfi_startproc
 3591              		@ args = 0, pretend = 0, frame = 0
 3592              		@ frame_needed = 0, uses_anonymous_args = 0
 3593              	.LVL312:
 3594 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3595              	.LCFI36:
 3596              		.cfi_def_cfa_offset 24
 3597              		.cfi_offset 3, -24
 3598              		.cfi_offset 4, -20
 3599              		.cfi_offset 5, -16
 3600              		.cfi_offset 6, -12
 3601              		.cfi_offset 7, -8
 3602              		.cfi_offset 14, -4
 3603              	.LVL313:
 3604              	.LBB57:
 3605              	.LBB58:
 211:FreeRTOS/ARM_CM3/portmacro.h **** 	(
 3606              		.loc 2 211 0
 3607              		.syntax unified
 3608              	@ 211 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3609 0002 EFF31185 			mrs r5, basepri											
 3610 0006 4FF0BF03 		mov r3, #191												
 3611 000a 83F31188 		msr basepri, r3											
 3612 000e BFF36F8F 		isb														
 3613 0012 BFF34F8F 		dsb														
 3614              	
 3615              	@ 0 "" 2
 3616              		.thumb
 3617              		.syntax unified
 3618              	.LBE58:
 3619              	.LBE57:
4900:FreeRTOS/Src/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3620              		.loc 1 4900 0
 3621 0016 90F84830 		ldrb	r3, [r0, #72]	@ zero_extendqisi2
 3622 001a DBB2     		uxtb	r3, r3
 3623              	.LVL314:
4901:FreeRTOS/Src/tasks.c **** 
 3624              		.loc 1 4901 0
 3625 001c 0222     		movs	r2, #2
 3626 001e 80F84820 		strb	r2, [r0, #72]
4905:FreeRTOS/Src/tasks.c **** 
 3627              		.loc 1 4905 0
 3628 0022 426C     		ldr	r2, [r0, #68]
 3629 0024 0132     		adds	r2, r2, #1
 3630 0026 4264     		str	r2, [r0, #68]
4911:FreeRTOS/Src/tasks.c **** 			{
 3631              		.loc 1 4911 0
 3632 0028 012B     		cmp	r3, #1
 3633 002a 2AD1     		bne	.L302
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 164


 3634 002c 0E46     		mov	r6, r1
 3635 002e 0446     		mov	r4, r0
4916:FreeRTOS/Src/tasks.c **** 				{
 3636              		.loc 1 4916 0
 3637 0030 154B     		ldr	r3, .L307
 3638              	.LVL315:
 3639 0032 1B68     		ldr	r3, [r3]
 3640 0034 A3B9     		cbnz	r3, .L303
4918:FreeRTOS/Src/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3641              		.loc 1 4918 0
 3642 0036 071D     		adds	r7, r0, #4
 3643 0038 3846     		mov	r0, r7
 3644              	.LVL316:
 3645 003a FFF7FEFF 		bl	uxListRemove
 3646              	.LVL317:
4919:FreeRTOS/Src/tasks.c **** 				}
 3647              		.loc 1 4919 0
 3648 003e E36A     		ldr	r3, [r4, #44]
 3649 0040 0122     		movs	r2, #1
 3650 0042 02FA03F1 		lsl	r1, r2, r3
 3651 0046 1148     		ldr	r0, .L307+4
 3652 0048 0268     		ldr	r2, [r0]
 3653 004a 0A43     		orrs	r2, r2, r1
 3654 004c 0260     		str	r2, [r0]
 3655 004e 03EB8303 		add	r3, r3, r3, lsl #2
 3656 0052 9A00     		lsls	r2, r3, #2
 3657 0054 3946     		mov	r1, r7
 3658 0056 0E48     		ldr	r0, .L307+8
 3659 0058 1044     		add	r0, r0, r2
 3660 005a FFF7FEFF 		bl	vListInsertEnd
 3661              	.LVL318:
 3662 005e 04E0     		b	.L304
 3663              	.LVL319:
 3664              	.L303:
4925:FreeRTOS/Src/tasks.c **** 				}
 3665              		.loc 1 4925 0
 3666 0060 00F11801 		add	r1, r0, #24
 3667              	.LVL320:
 3668 0064 0B48     		ldr	r0, .L307+12
 3669              	.LVL321:
 3670 0066 FFF7FEFF 		bl	vListInsertEnd
 3671              	.LVL322:
 3672              	.L304:
4928:FreeRTOS/Src/tasks.c **** 				{
 3673              		.loc 1 4928 0
 3674 006a E26A     		ldr	r2, [r4, #44]
 3675 006c 0A4B     		ldr	r3, .L307+16
 3676 006e 1B68     		ldr	r3, [r3]
 3677 0070 DB6A     		ldr	r3, [r3, #44]
 3678 0072 9A42     		cmp	r2, r3
 3679 0074 05D9     		bls	.L302
4932:FreeRTOS/Src/tasks.c **** 					{
 3680              		.loc 1 4932 0
 3681 0076 0EB1     		cbz	r6, .L305
4934:FreeRTOS/Src/tasks.c **** 					}
 3682              		.loc 1 4934 0
 3683 0078 0123     		movs	r3, #1
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 165


 3684 007a 3360     		str	r3, [r6]
 3685              	.L305:
4940:FreeRTOS/Src/tasks.c **** 				}
 3686              		.loc 1 4940 0
 3687 007c 0122     		movs	r2, #1
 3688 007e 074B     		ldr	r3, .L307+20
 3689 0080 1A60     		str	r2, [r3]
 3690              	.LVL323:
 3691              	.L302:
 3692              	.LBB59:
 3693              	.LBB60:
 3694              		.loc 2 229 0
 3695              		.syntax unified
 3696              	@ 229 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3697 0082 85F31188 			msr basepri, r5	
 3698              	@ 0 "" 2
 3699              	.LVL324:
 3700              		.thumb
 3701              		.syntax unified
 3702 0086 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3703              	.L308:
 3704              		.align	2
 3705              	.L307:
 3706 0088 00000000 		.word	.LANCHOR16
 3707 008c 00000000 		.word	.LANCHOR13
 3708 0090 00000000 		.word	.LANCHOR4
 3709 0094 00000000 		.word	.LANCHOR1
 3710 0098 00000000 		.word	.LANCHOR10
 3711 009c 00000000 		.word	.LANCHOR20
 3712              	.LBE60:
 3713              	.LBE59:
 3714              		.cfi_endproc
 3715              	.LFE73:
 3717              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 3718              		.align	2
 3719              		.global	xTaskNotifyStateClear
 3720              		.thumb
 3721              		.thumb_func
 3723              	xTaskNotifyStateClear:
 3724              	.LFB74:
4958:FreeRTOS/Src/tasks.c **** 	TCB_t *pxTCB;
 3725              		.loc 1 4958 0
 3726              		.cfi_startproc
 3727              		@ args = 0, pretend = 0, frame = 0
 3728              		@ frame_needed = 0, uses_anonymous_args = 0
 3729              	.LVL325:
 3730 0000 10B5     		push	{r4, lr}
 3731              	.LCFI37:
 3732              		.cfi_def_cfa_offset 8
 3733              		.cfi_offset 4, -8
 3734              		.cfi_offset 14, -4
4964:FreeRTOS/Src/tasks.c **** 
 3735              		.loc 1 4964 0
 3736 0002 0446     		mov	r4, r0
 3737 0004 08B9     		cbnz	r0, .L310
4964:FreeRTOS/Src/tasks.c **** 
 3738              		.loc 1 4964 0 is_stmt 0 discriminator 1
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 166


 3739 0006 094B     		ldr	r3, .L314
 3740 0008 1C68     		ldr	r4, [r3]
 3741              	.LVL326:
 3742              	.L310:
4966:FreeRTOS/Src/tasks.c **** 		{
 3743              		.loc 1 4966 0 is_stmt 1 discriminator 4
 3744 000a FFF7FEFF 		bl	vPortEnterCritical
 3745              	.LVL327:
4968:FreeRTOS/Src/tasks.c **** 			{
 3746              		.loc 1 4968 0 discriminator 4
 3747 000e 94F84830 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 3748 0012 DBB2     		uxtb	r3, r3
 3749 0014 022B     		cmp	r3, #2
 3750 0016 04D1     		bne	.L312
4970:FreeRTOS/Src/tasks.c **** 				xReturn = pdPASS;
 3751              		.loc 1 4970 0
 3752 0018 0023     		movs	r3, #0
 3753 001a 84F84830 		strb	r3, [r4, #72]
 3754              	.LVL328:
4971:FreeRTOS/Src/tasks.c **** 			}
 3755              		.loc 1 4971 0
 3756 001e 0124     		movs	r4, #1
 3757              	.LVL329:
 3758 0020 00E0     		b	.L311
 3759              	.LVL330:
 3760              	.L312:
4975:FreeRTOS/Src/tasks.c **** 			}
 3761              		.loc 1 4975 0
 3762 0022 0024     		movs	r4, #0
 3763              	.LVL331:
 3764              	.L311:
4978:FreeRTOS/Src/tasks.c **** 
 3765              		.loc 1 4978 0
 3766 0024 FFF7FEFF 		bl	vPortExitCritical
 3767              	.LVL332:
4981:FreeRTOS/Src/tasks.c **** 
 3768              		.loc 1 4981 0
 3769 0028 2046     		mov	r0, r4
 3770 002a 10BD     		pop	{r4, pc}
 3771              	.LVL333:
 3772              	.L315:
 3773              		.align	2
 3774              	.L314:
 3775 002c 00000000 		.word	.LANCHOR10
 3776              		.cfi_endproc
 3777              	.LFE74:
 3779              		.global	pxCurrentTCB
 3780              		.section	.bss.xNumOfOverflows,"aw",%nobits
 3781              		.align	2
 3782              		.set	.LANCHOR18,. + 0
 3785              	xNumOfOverflows:
 3786 0000 00000000 		.space	4
 3787              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 3788              		.align	2
 3789              		.set	.LANCHOR2,. + 0
 3792              	pxDelayedTaskList:
 3793 0000 00000000 		.space	4
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 167


 3794              		.section	.bss.xSchedulerRunning,"aw",%nobits
 3795              		.align	2
 3796              		.set	.LANCHOR11,. + 0
 3799              	xSchedulerRunning:
 3800 0000 00000000 		.space	4
 3801              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 3802              		.align	2
 3803              		.set	.LANCHOR7,. + 0
 3806              	xTasksWaitingTermination:
 3807 0000 00000000 		.space	20
 3807      00000000 
 3807      00000000 
 3807      00000000 
 3807      00000000 
 3808              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 3809              		.align	2
 3810              		.set	.LANCHOR8,. + 0
 3813              	pxOverflowDelayedTaskList:
 3814 0000 00000000 		.space	4
 3815              		.section	.bss.uxPendedTicks,"aw",%nobits
 3816              		.align	2
 3817              		.set	.LANCHOR19,. + 0
 3820              	uxPendedTicks:
 3821 0000 00000000 		.space	4
 3822              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 3823              		.align	2
 3824              		.set	.LANCHOR4,. + 0
 3827              	pxReadyTasksLists:
 3828 0000 00000000 		.space	100
 3828      00000000 
 3828      00000000 
 3828      00000000 
 3828      00000000 
 3829              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 3830              		.align	2
 3831              		.set	.LANCHOR16,. + 0
 3834              	uxSchedulerSuspended:
 3835 0000 00000000 		.space	4
 3836              		.section	.bss.uxDeletedTasksWaitingCleanUp,"aw",%nobits
 3837              		.align	2
 3838              		.set	.LANCHOR14,. + 0
 3841              	uxDeletedTasksWaitingCleanUp:
 3842 0000 00000000 		.space	4
 3843              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 3844              		.align	2
 3845              		.set	.LANCHOR9,. + 0
 3848              	uxCurrentNumberOfTasks:
 3849 0000 00000000 		.space	4
 3850              		.section	.bss.pxCurrentTCB,"aw",%nobits
 3851              		.align	2
 3852              		.set	.LANCHOR10,. + 0
 3855              	pxCurrentTCB:
 3856 0000 00000000 		.space	4
 3857              		.section	.bss.xPendingReadyList,"aw",%nobits
 3858              		.align	2
 3859              		.set	.LANCHOR1,. + 0
 3862              	xPendingReadyList:
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 168


 3863 0000 00000000 		.space	20
 3863      00000000 
 3863      00000000 
 3863      00000000 
 3863      00000000 
 3864              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 3865              		.align	2
 3866              		.set	.LANCHOR17,. + 0
 3869              	xIdleTaskHandle:
 3870 0000 00000000 		.space	4
 3871              		.section	.bss.xTickCount,"aw",%nobits
 3872              		.align	2
 3873              		.set	.LANCHOR15,. + 0
 3876              	xTickCount:
 3877 0000 00000000 		.space	4
 3878              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 3879              		.align	2
 3880              		.set	.LANCHOR3,. + 0
 3883              	xNextTaskUnblockTime:
 3884 0000 00000000 		.space	4
 3885              		.section	.rodata.str1.4,"aMS",%progbits,1
 3886              		.align	2
 3887              	.LC0:
 3888 0000 49444C45 		.ascii	"IDLE\000"
 3888      00
 3889              		.section	.bss.uxTaskNumber,"aw",%nobits
 3890              		.align	2
 3891              		.set	.LANCHOR12,. + 0
 3894              	uxTaskNumber:
 3895 0000 00000000 		.space	4
 3896              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 3897              		.align	2
 3898              		.set	.LANCHOR5,. + 0
 3901              	xDelayedTaskList1:
 3902 0000 00000000 		.space	20
 3902      00000000 
 3902      00000000 
 3902      00000000 
 3902      00000000 
 3903              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 3904              		.align	2
 3905              		.set	.LANCHOR6,. + 0
 3908              	xDelayedTaskList2:
 3909 0000 00000000 		.space	20
 3909      00000000 
 3909      00000000 
 3909      00000000 
 3909      00000000 
 3910              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 3911              		.align	2
 3912              		.set	.LANCHOR0,. + 0
 3915              	xSuspendedTaskList:
 3916 0000 00000000 		.space	20
 3916      00000000 
 3916      00000000 
 3916      00000000 
 3916      00000000 
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 169


 3917              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 3918              		.align	2
 3919              		.set	.LANCHOR13,. + 0
 3922              	uxTopReadyPriority:
 3923 0000 00000000 		.space	4
 3924              		.section	.bss.xYieldPending,"aw",%nobits
 3925              		.align	2
 3926              		.set	.LANCHOR20,. + 0
 3929              	xYieldPending:
 3930 0000 00000000 		.space	4
 3931              		.text
 3932              	.Letext0:
 3933              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20160926/lib/gcc/arm-none-eabi/5.4.1/include/stddef.h
 3934              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20160926/arm-none-eabi/include/machine/_default_types
 3935              		.file 5 "/usr/local/Cellar/gcc-arm-none-eabi/20160926/arm-none-eabi/include/sys/_stdint.h"
 3936              		.file 6 "FreeRTOS/Inc/projdefs.h"
 3937              		.file 7 "FreeRTOS/Inc/list.h"
 3938              		.file 8 "FreeRTOS/Inc/task.h"
 3939              		.file 9 "FreeRTOS/Inc/portable.h"
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 170


DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:20     .text.prvTaskIsTaskSuspended:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:24     .text.prvTaskIsTaskSuspended:0000000000000000 prvTaskIsTaskSuspended
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:69     .text.prvTaskIsTaskSuspended:0000000000000024 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:75     .text.prvResetNextTaskUnblockTime:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:79     .text.prvResetNextTaskUnblockTime:0000000000000000 prvResetNextTaskUnblockTime
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:112    .text.prvResetNextTaskUnblockTime:0000000000000024 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:118    .text.prvDeleteTCB:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:122    .text.prvDeleteTCB:0000000000000000 prvDeleteTCB
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:149    .text.prvInitialiseNewTask:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:153    .text.prvInitialiseNewTask:0000000000000000 prvInitialiseNewTask
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:259    .text.prvInitialiseTaskLists:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:263    .text.prvInitialiseTaskLists:0000000000000000 prvInitialiseTaskLists
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:329    .text.prvInitialiseTaskLists:0000000000000048 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:341    .text.prvAddNewTaskToReadyList:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:345    .text.prvAddNewTaskToReadyList:0000000000000000 prvAddNewTaskToReadyList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:450    .text.prvAddNewTaskToReadyList:000000000000008c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:461    .text.prvCheckTasksWaitingTermination:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:465    .text.prvCheckTasksWaitingTermination:0000000000000000 prvCheckTasksWaitingTermination
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:521    .text.prvCheckTasksWaitingTermination:0000000000000038 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:528    .text.prvIdleTask:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:532    .text.prvIdleTask:0000000000000000 prvIdleTask
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:572    .text.prvIdleTask:0000000000000020 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:578    .text.prvAddCurrentTaskToDelayedList:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:582    .text.prvAddCurrentTaskToDelayedList:0000000000000000 prvAddCurrentTaskToDelayedList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:679    .text.prvAddCurrentTaskToDelayedList:000000000000007c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:690    .text.xTaskCreate:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:695    .text.xTaskCreate:0000000000000000 xTaskCreate
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:792    .text.vTaskDelete:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:797    .text.vTaskDelete:0000000000000000 vTaskDelete
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:917    .text.vTaskDelete:000000000000009c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:930    .text.uxTaskPriorityGet:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:935    .text.uxTaskPriorityGet:0000000000000000 uxTaskPriorityGet
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:971    .text.uxTaskPriorityGet:0000000000000018 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:976    .text.uxTaskPriorityGetFromISR:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:981    .text.uxTaskPriorityGetFromISR:0000000000000000 uxTaskPriorityGetFromISR
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1033   .text.uxTaskPriorityGetFromISR:0000000000000024 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1038   .text.vTaskPrioritySet:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1043   .text.vTaskPrioritySet:0000000000000000 vTaskPrioritySet
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1197   .text.vTaskPrioritySet:00000000000000bc $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1205   .text.vTaskResume:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1210   .text.vTaskResume:0000000000000000 vTaskResume
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1290   .text.vTaskResume:0000000000000064 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1298   .text.xTaskResumeFromISR:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1303   .text.xTaskResumeFromISR:0000000000000000 xTaskResumeFromISR
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1414   .text.xTaskResumeFromISR:0000000000000078 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1423   .text.vTaskStartScheduler:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1428   .text.vTaskStartScheduler:0000000000000000 vTaskStartScheduler
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1494   .text.vTaskStartScheduler:0000000000000048 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1504   .text.vTaskEndScheduler:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1509   .text.vTaskEndScheduler:0000000000000000 vTaskEndScheduler
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1546   .text.vTaskEndScheduler:0000000000000020 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1551   .text.vTaskSuspendAll:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1556   .text.vTaskSuspendAll:0000000000000000 vTaskSuspendAll
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1572   .text.vTaskSuspendAll:000000000000000c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1577   .text.xTaskGetTickCount:0000000000000000 $t
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 171


/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1582   .text.xTaskGetTickCount:0000000000000000 xTaskGetTickCount
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1598   .text.xTaskGetTickCount:0000000000000008 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1603   .text.xTaskGetTickCountFromISR:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1608   .text.xTaskGetTickCountFromISR:0000000000000000 xTaskGetTickCountFromISR
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1625   .text.xTaskGetTickCountFromISR:0000000000000008 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1630   .text.uxTaskGetNumberOfTasks:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1635   .text.uxTaskGetNumberOfTasks:0000000000000000 uxTaskGetNumberOfTasks
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1650   .text.uxTaskGetNumberOfTasks:0000000000000008 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1655   .text.pcTaskGetName:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1660   .text.pcTaskGetName:0000000000000000 pcTaskGetName
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1682   .text.pcTaskGetName:0000000000000010 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1687   .text.xTaskIncrementTick:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1692   .text.xTaskIncrementTick:0000000000000000 xTaskIncrementTick
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1874   .text.xTaskIncrementTick:00000000000000d8 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1889   .text.xTaskResumeAll:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:1894   .text.xTaskResumeAll:0000000000000000 xTaskResumeAll
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2056   .text.xTaskResumeAll:00000000000000bc $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2069   .text.vTaskDelayUntil:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2074   .text.vTaskDelayUntil:0000000000000000 vTaskDelayUntil
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2180   .text.vTaskDelayUntil:0000000000000060 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2186   .text.vTaskDelay:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2191   .text.vTaskDelay:0000000000000000 vTaskDelay
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2245   .text.vTaskDelay:0000000000000030 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2250   .text.vTaskSwitchContext:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2255   .text.vTaskSwitchContext:0000000000000000 vTaskSwitchContext
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2347   .text.vTaskSwitchContext:0000000000000064 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2356   .text.vTaskSuspend:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2361   .text.vTaskSuspend:0000000000000000 vTaskSuspend
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2494   .text.vTaskSuspend:00000000000000ac $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2505   .text.vTaskPlaceOnEventList:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2510   .text.vTaskPlaceOnEventList:0000000000000000 vTaskPlaceOnEventList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2540   .text.vTaskPlaceOnEventList:0000000000000018 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2545   .text.vTaskPlaceOnUnorderedEventList:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2550   .text.vTaskPlaceOnUnorderedEventList:0000000000000000 vTaskPlaceOnUnorderedEventList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2585   .text.vTaskPlaceOnUnorderedEventList:0000000000000020 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2590   .text.xTaskRemoveFromEventList:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2595   .text.xTaskRemoveFromEventList:0000000000000000 xTaskRemoveFromEventList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2675   .text.xTaskRemoveFromEventList:0000000000000060 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2685   .text.vTaskRemoveFromUnorderedEventList:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2690   .text.vTaskRemoveFromUnorderedEventList:0000000000000000 vTaskRemoveFromUnorderedEventList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2751   .text.vTaskRemoveFromUnorderedEventList:000000000000004c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2759   .text.vTaskSetTimeOutState:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2764   .text.vTaskSetTimeOutState:0000000000000000 vTaskSetTimeOutState
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2796   .text.vTaskSetTimeOutState:000000000000001c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2802   .text.vTaskInternalSetTimeOutState:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2807   .text.vTaskInternalSetTimeOutState:0000000000000000 vTaskInternalSetTimeOutState
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2827   .text.vTaskInternalSetTimeOutState:0000000000000010 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2833   .text.xTaskCheckForTimeOut:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2838   .text.xTaskCheckForTimeOut:0000000000000000 xTaskCheckForTimeOut
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2930   .text.xTaskCheckForTimeOut:0000000000000050 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2936   .text.vTaskMissedYield:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2941   .text.vTaskMissedYield:0000000000000000 vTaskMissedYield
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2956   .text.vTaskMissedYield:0000000000000008 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2961   .text.uxTaskResetEventItemValue:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2966   .text.uxTaskResetEventItemValue:0000000000000000 uxTaskResetEventItemValue
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2989   .text.uxTaskResetEventItemValue:0000000000000014 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2994   .text.ulTaskNotifyTake:0000000000000000 $t
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 172


/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:2999   .text.ulTaskNotifyTake:0000000000000000 ulTaskNotifyTake
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3092   .text.ulTaskNotifyTake:000000000000006c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3098   .text.xTaskNotifyWait:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3103   .text.xTaskNotifyWait:0000000000000000 xTaskNotifyWait
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3218   .text.xTaskNotifyWait:0000000000000090 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3224   .text.xTaskGenericNotify:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3229   .text.xTaskGenericNotify:0000000000000000 xTaskGenericNotify
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3272   .text.xTaskGenericNotify:000000000000002a $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3276   .text.xTaskGenericNotify:000000000000002e $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3376   .text.xTaskGenericNotify:00000000000000a8 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3384   .text.xTaskGenericNotifyFromISR:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3389   .text.xTaskGenericNotifyFromISR:0000000000000000 xTaskGenericNotifyFromISR
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3443   .text.xTaskGenericNotifyFromISR:0000000000000032 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3447   .text.xTaskGenericNotifyFromISR:0000000000000036 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3572   .text.xTaskGenericNotifyFromISR:00000000000000c4 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3582   .text.vTaskNotifyGiveFromISR:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3587   .text.vTaskNotifyGiveFromISR:0000000000000000 vTaskNotifyGiveFromISR
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3706   .text.vTaskNotifyGiveFromISR:0000000000000088 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3718   .text.xTaskNotifyStateClear:0000000000000000 $t
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3723   .text.xTaskNotifyStateClear:0000000000000000 xTaskNotifyStateClear
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3775   .text.xTaskNotifyStateClear:000000000000002c $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3855   .bss.pxCurrentTCB:0000000000000000 pxCurrentTCB
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3781   .bss.xNumOfOverflows:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3785   .bss.xNumOfOverflows:0000000000000000 xNumOfOverflows
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3788   .bss.pxDelayedTaskList:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3792   .bss.pxDelayedTaskList:0000000000000000 pxDelayedTaskList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3795   .bss.xSchedulerRunning:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3799   .bss.xSchedulerRunning:0000000000000000 xSchedulerRunning
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3802   .bss.xTasksWaitingTermination:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3806   .bss.xTasksWaitingTermination:0000000000000000 xTasksWaitingTermination
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3809   .bss.pxOverflowDelayedTaskList:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3813   .bss.pxOverflowDelayedTaskList:0000000000000000 pxOverflowDelayedTaskList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3816   .bss.uxPendedTicks:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3820   .bss.uxPendedTicks:0000000000000000 uxPendedTicks
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3823   .bss.pxReadyTasksLists:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3827   .bss.pxReadyTasksLists:0000000000000000 pxReadyTasksLists
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3830   .bss.uxSchedulerSuspended:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3834   .bss.uxSchedulerSuspended:0000000000000000 uxSchedulerSuspended
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3837   .bss.uxDeletedTasksWaitingCleanUp:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3841   .bss.uxDeletedTasksWaitingCleanUp:0000000000000000 uxDeletedTasksWaitingCleanUp
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3844   .bss.uxCurrentNumberOfTasks:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3848   .bss.uxCurrentNumberOfTasks:0000000000000000 uxCurrentNumberOfTasks
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3851   .bss.pxCurrentTCB:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3858   .bss.xPendingReadyList:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3862   .bss.xPendingReadyList:0000000000000000 xPendingReadyList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3865   .bss.xIdleTaskHandle:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3869   .bss.xIdleTaskHandle:0000000000000000 xIdleTaskHandle
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3872   .bss.xTickCount:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3876   .bss.xTickCount:0000000000000000 xTickCount
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3879   .bss.xNextTaskUnblockTime:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3883   .bss.xNextTaskUnblockTime:0000000000000000 xNextTaskUnblockTime
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3886   .rodata.str1.4:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3890   .bss.uxTaskNumber:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3894   .bss.uxTaskNumber:0000000000000000 uxTaskNumber
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3897   .bss.xDelayedTaskList1:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3901   .bss.xDelayedTaskList1:0000000000000000 xDelayedTaskList1
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3904   .bss.xDelayedTaskList2:0000000000000000 $d
ARM GAS  /var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s 			page 173


/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3908   .bss.xDelayedTaskList2:0000000000000000 xDelayedTaskList2
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3911   .bss.xSuspendedTaskList:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3915   .bss.xSuspendedTaskList:0000000000000000 xSuspendedTaskList
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3918   .bss.uxTopReadyPriority:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3922   .bss.uxTopReadyPriority:0000000000000000 uxTopReadyPriority
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3925   .bss.xYieldPending:0000000000000000 $d
/var/folders/g9/bbpj86ld7fx45vd1b3pqxmp00000gn/T//ccFTponL.s:3929   .bss.xYieldPending:0000000000000000 xYieldPending
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
vPortFree
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vPortEnterCritical
vListInsertEnd
vPortExitCritical
uxListRemove
vListInsert
pvPortMalloc
xPortStartScheduler
vPortEndScheduler
